<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 3: Processes - CS330</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f4f4f4;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
        }

        header {
            background: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%);
            color: white;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            border-radius: 10px;
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        h2 {
            color: #0072ff;
            font-size: 1.8em;
            margin: 35px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #00c6ff;
        }

        h3 {
            color: #00a2ff;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }

        /* Process State Diagram */
        .state-diagram {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            padding: 30px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .state-container {
            position: relative;
            width: 600px;
            height: 400px;
        }

        .state-box {
            position: absolute;
            padding: 20px 30px;
            background: #3498db;
            color: white;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }

        .state-new { top: 50px; left: 50px; background: #2ecc71; }
        .state-ready { top: 50px; left: 250px; background: #f39c12; }
        .state-running { top: 50px; right: 50px; background: #e74c3c; }
        .state-waiting { bottom: 100px; left: 250px; background: #9b59b6; }
        .state-terminated { bottom: 50px; right: 50px; background: #95a5a6; }

        .arrow {
            position: absolute;
            font-size: 20px;
            color: #34495e;
        }

        /* PCB Diagram */
        .pcb-diagram {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        .pcb-structure {
            border: 3px solid #2c3e50;
            border-radius: 10px;
            overflow: hidden;
            width: 400px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .pcb-field {
            padding: 15px;
            text-align: center;
            font-weight: bold;
            border-bottom: 2px solid #2c3e50;
        }

        .pcb-field:nth-child(odd) { background: #ecf0f1; }
        .pcb-field:nth-child(even) { background: #bdc3c7; }
        .pcb-field:last-child { border-bottom: none; }

        /* Context Switch Visualization */
        .context-switch {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            padding: 30px;
            background: #f0f8ff;
            border-radius: 10px;
        }

        .process-block {
            padding: 30px;
            background: #3498db;
            color: white;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
            min-width: 150px;
        }

        .os-block {
            padding: 20px;
            background: #e74c3c;
            color: white;
            border-radius: 10px;
            text-align: center;
            font-weight: bold;
        }

        .switch-arrow {
            font-size: 30px;
            color: #2c3e50;
        }

        /* Queue Visualization */
        .queue-diagram {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9ff;
            border-radius: 10px;
        }

        .queue {
            display: flex;
            align-items: center;
            margin: 20px 0;
        }

        .queue-label {
            background: #2c3e50;
            color: white;
            padding: 15px;
            border-radius: 5px 0 0 5px;
            min-width: 120px;
            text-align: center;
            font-weight: bold;
        }

        .queue-item {
            background: #3498db;
            color: white;
            padding: 10px 15px;
            margin-left: 10px;
            border-radius: 5px;
            font-weight: bold;
        }

        /* IPC Comparison */
        .ipc-comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 30px 0;
        }

        .ipc-method {
            padding: 25px;
            border-radius: 10px;
            border: 2px solid #ddd;
        }

        .shared-memory {
            background: #e8f8f5;
            border-color: #27ae60;
        }

        .message-passing {
            background: #fef5e7;
            border-color: #f39c12;
        }

        /* Code Blocks */
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .code-comment {
            color: #95a5a6;
        }

        .code-keyword {
            color: #3498db;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        th {
            background: #0072ff;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px 15px;
            border: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f8f9ff;
        }

        /* Concept Box */
        .concept-box {
            background: #f0f8ff;
            border-left: 4px solid #0072ff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .highlight {
            background: #ffd700;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        /* Example Box */
        .example-box {
            background: #e8f8f5;
            border: 2px solid #27ae60;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        /* Warning Box */
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }

        /* Exam Section */
        .exam-section {
            background: #fff8dc;
            border: 2px solid #ffd700;
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .exam-question {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .mcq-options {
            list-style: none;
            margin-top: 15px;
        }

        .mcq-options li {
            background: #f8f9ff;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 3px solid transparent;
        }

        .correct-answer {
            background: #d4edda !important;
            border-left: 3px solid #28a745 !important;
        }

        /* Image Placeholder */
        .image-placeholder {
            background: #95a5a6;
            color: white;
            padding: 60px 20px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #7f8c8d;
        }

        /* Process Cards */
        .process-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .process-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }

        .process-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .process-card h4 {
            color: #0072ff;
            margin-bottom: 10px;
        }

        footer {
            background: #0072ff;
            color: white;
            text-align: center;
            padding: 25px;
            margin-top: 40px;
            border-radius: 10px;
        }

        .subsection {
            margin-left: 20px;
            padding-left: 20px;
            border-left: 2px solid #ecf0f1;
        }

        /* Process Creation Tree */
        .tree-diagram {
            display: flex;
            justify-content: center;
            margin: 30px 0;
        }

        .tree-node {
            text-align: center;
            padding: 10px 20px;
            background: #3498db;
            color: white;
            border-radius: 8px;
            margin: 0 10px;
            position: relative;
        }

        .tree-children {
            display: flex;
            justify-content: center;
            margin-top: 30px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Chapter 3: Processes</h1>
            <p style="font-size: 1.2em;">CS330 - Operating Systems</p>
            <p>Process Concept, Scheduling, IPC, and Management</p>
        </header>

        <!-- Section 1: Process Concept -->
        <section>
            <h2>3.1 Process Concept</h2>
            
            <div class="concept-box">
                <p>A <span class="highlight">process</span> is a program in execution. It is the unit of work in most systems. A process is more than just program code (text section); it includes current activity represented by program counter and processor registers.</p>
            </div>

            <h3>Process vs Program</h3>
            <table>
                <tr>
                    <th>Program</th>
                    <th>Process</th>
                </tr>
                <tr>
                    <td>Passive entity stored on disk</td>
                    <td>Active entity with program counter</td>
                </tr>
                <tr>
                    <td>Executable file (code)</td>
                    <td>Program loaded into memory</td>
                </tr>
                <tr>
                    <td>Static</td>
                    <td>Dynamic, has state</td>
                </tr>
                <tr>
                    <td>One program</td>
                    <td>Can have multiple processes</td>
                </tr>
            </table>

            <h3>Process in Memory</h3>
            <div class="concept-box">
                <p>A process includes:</p>
                <ul>
                    <li><strong>Text Section:</strong> Program code</li>
                    <li><strong>Data Section:</strong> Global variables</li>
                    <li><strong>Heap:</strong> Memory dynamically allocated during runtime</li>
                    <li><strong>Stack:</strong> Temporary data (function parameters, return addresses, local variables)</li>
                </ul>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Important:</h4>
                <p>Text and data sections have fixed size, while heap and stack can grow dynamically. Stack and heap grow toward each other but must not overlap!</p>
            </div>
        </section>

        <!-- Section 2: Process States -->
        <section>
            <h2>3.2 Process States</h2>
            
            <div class="concept-box">
                <p>As a process executes, it changes state. A process may be in one of the following states:</p>
            </div>

            <div class="state-diagram">
                <div style="text-align: center;">
                    <h4>Five-State Process Model</h4>
                    <svg width="600" height="400" style="margin-top: 20px;">
                        <!-- State boxes -->
                        <rect x="50" y="50" width="100" height="50" fill="#2ecc71" rx="5"/>
                        <text x="100" y="80" text-anchor="middle" fill="white" font-weight="bold">New</text>
                        
                        <rect x="200" y="50" width="100" height="50" fill="#f39c12" rx="5"/>
                        <text x="250" y="80" text-anchor="middle" fill="white" font-weight="bold">Ready</text>
                        
                        <rect x="350" y="50" width="100" height="50" fill="#e74c3c" rx="5"/>
                        <text x="400" y="80" text-anchor="middle" fill="white" font-weight="bold">Running</text>
                        
                        <rect x="200" y="200" width="100" height="50" fill="#9b59b6" rx="5"/>
                        <text x="250" y="230" text-anchor="middle" fill="white" font-weight="bold">Waiting</text>
                        
                        <rect x="350" y="300" width="100" height="50" fill="#95a5a6" rx="5"/>
                        <text x="400" y="330" text-anchor="middle" fill="white" font-weight="bold">Terminated</text>
                        
                        <!-- Arrows with labels -->
                        <defs>
                            <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="8" refY="3" orient="auto">
                                <polygon points="0 0, 10 3, 0 6" fill="#34495e" />
                            </marker>
                        </defs>
                        
                        <!-- New to Ready -->
                        <line x1="150" y1="75" x2="200" y2="75" stroke="#34495e" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <text x="175" y="65" text-anchor="middle" font-size="12">admitted</text>
                        
                        <!-- Ready to Running -->
                        <line x1="300" y1="75" x2="350" y2="75" stroke="#34495e" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <text x="325" y="65" text-anchor="middle" font-size="12">dispatch</text>
                        
                        <!-- Running to Ready -->
                        <path d="M 380 50 Q 325 20 270 50" stroke="#34495e" stroke-width="2" fill="none" marker-end="url(#arrowhead)"/>
                        <text x="325" y="30" text-anchor="middle" font-size="12">interrupt</text>
                        
                        <!-- Running to Waiting -->
                        <line x1="380" y1="100" x2="270" y2="200" stroke="#34495e" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <text x="340" y="145" text-anchor="middle" font-size="12">I/O or wait</text>
                        
                        <!-- Waiting to Ready -->
                        <line x1="250" y1="200" x2="250" y2="100" stroke="#34495e" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <text x="200" y="150" text-anchor="middle" font-size="12">I/O done</text>
                        
                        <!-- Running to Terminated -->
                        <line x1="400" y1="100" x2="400" y2="300" stroke="#34495e" stroke-width="2" marker-end="url(#arrowhead)"/>
                        <text x="420" y="200" text-anchor="middle" font-size="12">exit</text>
                    </svg>
                </div>
            </div>

            <table>
                <tr>
                    <th>State</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td><strong>New</strong></td>
                    <td>The process is being created</td>
                </tr>
                <tr>
                    <td><strong>Ready</strong></td>
                    <td>The process is waiting to be assigned to a processor</td>
                </tr>
                <tr>
                    <td><strong>Running</strong></td>
                    <td>Instructions are being executed</td>
                </tr>
                <tr>
                    <td><strong>Waiting</strong></td>
                    <td>The process is waiting for some event to occur (I/O completion or signal)</td>
                </tr>
                <tr>
                    <td><strong>Terminated</strong></td>
                    <td>The process has finished execution</td>
                </tr>
            </table>

            <div class="exam-section">
                <h4>üìù Exam Question (From CS330 Final):</h4>
                <div class="exam-question">
                    <p><strong>Q:</strong> A process that is currently in the 'Running' state can next go to which states?</p>
                    <div class="example-box">
                        <p><strong>Answer:</strong> A running process can go to:</p>
                        <ul>
                            <li>(i) Terminated state (process completes)</li>
                            <li>(ii) Waiting state (I/O request)</li>
                            <li>(iii) Ready state (interrupt/time slice expired)</li>
                        </ul>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 3: Process Control Block -->
        <section>
            <h2>3.3 Process Control Block (PCB)</h2>
            
            <div class="concept-box">
                <p>Each process is represented in the OS by a <span class="highlight">Process Control Block (PCB)</span>, also called a Task Control Block (TCB). The PCB contains all information associated with a specific process.</p>
            </div>

            <div class="pcb-diagram">
                <div class="pcb-structure">
                    <div class="pcb-field">Process State</div>
                    <div class="pcb-field">Process Number (PID)</div>
                    <div class="pcb-field">Program Counter</div>
                    <div class="pcb-field">CPU Registers</div>
                    <div class="pcb-field">CPU Scheduling Info</div>
                    <div class="pcb-field">Memory Management Info</div>
                    <div class="pcb-field">Accounting Information</div>
                    <div class="pcb-field">I/O Status Information</div>
                </div>
            </div>

            <h3>PCB Information Details:</h3>
            <table>
                <tr>
                    <th>Field</th>
                    <th>Contains</th>
                </tr>
                <tr>
                    <td><strong>Process State</strong></td>
                    <td>New, ready, running, waiting, terminated</td>
                </tr>
                <tr>
                    <td><strong>Program Counter</strong></td>
                    <td>Address of next instruction to execute</td>
                </tr>
                <tr>
                    <td><strong>CPU Registers</strong></td>
                    <td>Contents of all process-centric registers</td>
                </tr>
                <tr>
                    <td><strong>CPU Scheduling Info</strong></td>
                    <td>Priority, scheduling queue pointers</td>
                </tr>
                <tr>
                    <td><strong>Memory Management</strong></td>
                    <td>Page tables, memory limits, segment tables</td>
                </tr>
                <tr>
                    <td><strong>Accounting Info</strong></td>
                    <td>CPU used, clock time elapsed, time limits</td>
                </tr>
                <tr>
                    <td><strong>I/O Status</strong></td>
                    <td>List of I/O devices allocated, open files</td>
                </tr>
            </table>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Key Points:</h4>
                <ul>
                    <li>PCB is constructed at process creation</li>
                    <li>PCB includes pointer for queue management</li>
                    <li>PCB saves process information during context switch</li>
                </ul>
            </div>
        </section>

        <!-- Section 4: Process Scheduling -->
        <section>
            <h2>3.4 Process Scheduling</h2>
            
            <div class="concept-box">
                <p>The <span class="highlight">process scheduler</span> selects among available processes for next execution on CPU core. The goal is to maximize CPU utilization and quickly switch processes onto CPU.</p>
            </div>

            <h3>Scheduling Queues</h3>
            <div class="queue-diagram">
                <div class="queue">
                    <div class="queue-label">Ready Queue</div>
                    <div class="queue-item">PCB‚Çá</div>
                    <div class="queue-item">PCB‚ÇÇ</div>
                    <div class="queue-item">PCB‚ÇÖ</div>
                    <div class="queue-item">‚Üí</div>
                </div>
                <div class="queue">
                    <div class="queue-label">Wait Queue</div>
                    <div class="queue-item">PCB‚ÇÉ</div>
                    <div class="queue-item">PCB‚ÇÅ‚ÇÑ</div>
                    <div class="queue-item">PCB‚ÇÜ</div>
                    <div class="queue-item">‚Üí</div>
                </div>
            </div>

            <div class="concept-box">
                <h4>Types of Scheduling Queues:</h4>
                <ul>
                    <li><strong>Ready Queue:</strong> Set of all processes in main memory, ready and waiting to execute</li>
                    <li><strong>Wait Queues:</strong> Set of processes waiting for an event (e.g., I/O)</li>
                    <li><strong>Device Queues:</strong> Set of processes waiting for a particular I/O device</li>
                </ul>
                <p>Processes migrate among the various queues during their lifetime.</p>
            </div>

            <h3>Types of Schedulers</h3>
            <table>
                <tr>
                    <th>Scheduler Type</th>
                    <th>Function</th>
                    <th>Frequency</th>
                </tr>
                <tr>
                    <td><strong>Long-term</strong></td>
                    <td>Selects processes from job pool to load into memory</td>
                    <td>Infrequent (seconds, minutes)</td>
                </tr>
                <tr>
                    <td><strong>Short-term</strong></td>
                    <td>Selects from ready queue to execute on CPU</td>
                    <td>Very frequent (milliseconds)</td>
                </tr>
                <tr>
                    <td><strong>Medium-term</strong></td>
                    <td>Swapping - removes process from memory temporarily</td>
                    <td>As needed</td>
                </tr>
            </table>

            <div class="image-placeholder">
                <h4>üìä Representation of Process Scheduling</h4>
                <p>[Insert scheduling queues diagram from Chapter_3.pdf]</p>
                <p>Shows flow between ready queue, CPU, and I/O queues</p>
            </div>
        </section>

        <!-- Section 5: Context Switch -->
        <section>
            <h2>3.5 Context Switch</h2>
            
            <div class="concept-box">
                <p>When CPU switches to another process, the system must save the state of the old process and load the saved state for the new process via a <span class="highlight">context switch</span>.</p>
            </div>

            <div class="context-switch">
                <div class="process-block">Process P‚ÇÄ<br>executing</div>
                <span class="switch-arrow">‚Üí</span>
                <div class="os-block">
                    Operating System<br>
                    <small>1. Save state to PCB‚ÇÄ<br>
                    2. Reload state from PCB‚ÇÅ</small>
                </div>
                <span class="switch-arrow">‚Üí</span>
                <div class="process-block">Process P‚ÇÅ<br>executing</div>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Context Switch Overhead:</h4>
                <ul>
                    <li>Context-switch time is pure overhead - no useful work while switching</li>
                    <li>Time depends on hardware support</li>
                    <li>Typical times: < 10 microseconds</li>
                    <li>More complex OS and PCB ‚Üí longer context switch</li>
                    <li>Some hardware provides multiple register sets to speed up switching</li>
                </ul>
            </div>

            <div class="exam-section">
                <h4>üìù Practice Question:</h4>
                <div class="exam-question">
                    <p><strong>Q:</strong> Describe the actions taken by a kernel to context-switch between processes.</p>
                    <div class="example-box">
                        <p><strong>Answer:</strong></p>
                        <ol>
                            <li>Save the context of current process (PC, SP, registers) in its PCB</li>
                            <li>Update PCB state (running ‚Üí ready/waiting)</li>
                            <li>Move PCB to appropriate queue</li>
                            <li>Select another process from ready queue</li>
                            <li>Update new process PCB state (ready ‚Üí running)</li>
                            <li>Restore context from new process PCB into CPU</li>
                        </ol>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 6: Process Creation -->
        <section>
            <h2>3.6 Operations on Processes</h2>
            
            <h3>Process Creation</h3>
            <div class="concept-box">
                <p>A process may create several new processes. The creating process is the <span class="highlight">parent</span>, and new processes are <span class="highlight">children</span>, forming a tree of processes.</p>
            </div>

            <h4>Resource Sharing Options:</h4>
            <ul>
                <li>Parent and children share all resources</li>
                <li>Children share subset of parent's resources</li>
                <li>Parent and child share no resources</li>
            </ul>

            <h4>Execution Options:</h4>
            <ul>
                <li>Parent and children execute concurrently</li>
                <li>Parent waits until children terminate</li>
            </ul>

            <h4>Address Space Options:</h4>
            <ul>
                <li>Child is duplicate of parent (same program and data)</li>
                <li>Child has new program loaded into it</li>
            </ul>

            <h3>UNIX Process Creation</h3>
            <div class="code-block">
<span class="code-comment">// Process creation example in C</span>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/wait.h&gt;

int main() {
    <span class="code-keyword">pid_t</span> pid;
    
    <span class="code-comment">// fork() creates new process</span>
    pid = <span class="code-keyword">fork</span>();
    
    if (pid < 0) {  <span class="code-comment">// Error occurred</span>
        fprintf(stderr, "Fork Failed\n");
        return 1;
    }
    else if (pid == 0) {  <span class="code-comment">// Child process</span>
        printf("Child Process: PID = %d\n", getpid());
        
        <span class="code-comment">// exec() replaces process memory space</span>
        execlp("/bin/ls", "ls", NULL);
    }
    else {  <span class="code-comment">// Parent process</span>
        printf("Parent Process: PID = %d\n", getpid());
        printf("Child PID = %d\n", pid);
        
        <span class="code-comment">// wait() for child to complete</span>
        wait(NULL);
        printf("Child Complete\n");
    }
    
    return 0;
}
            </div>

            <div class="exam-section">
                <h4>üìù Exam Question (CS330 Assignment):</h4>
                <div class="exam-question">
                    <p><strong>Q:</strong> What will be the output at lines A, B, C, and D? (Assume parent PID=2600, child PID=2603)</p>
                    <div class="code-block">
pid = fork();
if (pid == 0) {  <span class="code-comment">/* child process */</span>
    pid1 = getpid();
    printf("child: pid = %d", pid);   <span class="code-comment">/* A */</span>
    printf("child: pid1 = %d", pid1); <span class="code-comment">/* B */</span>
} else {  <span class="code-comment">/* parent process */</span>
    pid1 = getpid();
    printf("parent: pid = %d", pid);  <span class="code-comment">/* C */</span>
    printf("parent: pid1 = %d", pid1);<span class="code-comment">/* D */</span>
}
                    </div>
                    <div class="example-box">
                        <p><strong>Answer:</strong></p>
                        <ul>
                            <li>Line A: child: pid = 0</li>
                            <li>Line B: child: pid1 = 2603</li>
                            <li>Line C: parent: pid = 2603</li>
                            <li>Line D: parent: pid1 = 2600</li>
                        </ul>
                    </div>
                </div>
            </div>

            <h3>Process Termination</h3>
            <div class="concept-box">
                <p>A process terminates when it finishes executing its final statement and calls <code>exit()</code> system call.</p>
            </div>

            <h4>Process may terminate due to:</h4>
            <ul>
                <li>Normal exit (voluntary)</li>
                <li>Error exit (voluntary)</li>
                <li>Fatal error (involuntary)</li>
                <li>Killed by another process (involuntary)</li>
            </ul>

            <h4>Parent may terminate child because:</h4>
            <ul>
                <li>Child has exceeded allocated resources</li>
                <li>Task assigned to child is no longer required</li>
                <li>Parent is exiting (cascading termination)</li>
            </ul>
        </section>

        <!-- Section 7: IPC -->
        <section>
            <h2>3.7 Interprocess Communication (IPC)</h2>
            
            <div class="concept-box">
                <p>Processes may be <span class="highlight">independent</span> or <span class="highlight">cooperating</span>. Cooperating processes need IPC mechanisms to exchange data and information.</p>
            </div>

            <h3>Reasons for Process Cooperation:</h3>
            <div class="process-grid">
                <div class="process-card">
                    <h4>üìä Information Sharing</h4>
                    <p>Several users may need same information</p>
                </div>
                <div class="process-card">
                    <h4>‚ö° Computation Speedup</h4>
                    <p>Break task into subtasks running in parallel</p>
                </div>
                <div class="process-card">
                    <h4>üß© Modularity</h4>
                    <p>Divide system functions into separate processes</p>
                </div>
                <div class="process-card">
                    <h4>üéØ Convenience</h4>
                    <p>User may work on many tasks simultaneously</p>
                </div>
            </div>

            <h3>IPC Models</h3>
            <div class="ipc-comparison">
                <div class="ipc-method shared-memory">
                    <h4>üîó Shared Memory</h4>
                    <ul>
                        <li>Processes share region of memory</li>
                        <li>Fast - no kernel intervention after setup</li>
                        <li>Requires synchronization</li>
                        <li>Good for large amounts of data</li>
                    </ul>
                    <div class="code-block" style="margin-top: 15px;">
<span class="code-comment">// Producer example</span>
while (true) {
    <span class="code-comment">/* produce item */</span>
    while (((in + 1) % BUFFER_SIZE) == out)
        ; <span class="code-comment">/* buffer full - wait */</span>
    buffer[in] = next_produced;
    in = (in + 1) % BUFFER_SIZE;
}
                    </div>
                </div>
                <div class="ipc-method message-passing">
                    <h4>‚úâÔ∏è Message Passing</h4>
                    <ul>
                        <li>Exchange messages between processes</li>
                        <li>Slower - requires system calls</li>
                        <li>No shared memory needed</li>
                        <li>Good for distributed systems</li>
                    </ul>
                    <div class="code-block" style="margin-top: 15px;">
<span class="code-comment">// Message passing operations</span>
send(message);     <span class="code-comment">// Send message</span>
receive(message);  <span class="code-comment">// Receive message</span>

<span class="code-comment">// Message size:</span>
<span class="code-comment">// - Fixed size</span>
<span class="code-comment">// - Variable size</span>
                    </div>
                </div>
            </div>

            <h3>Message Passing Implementation</h3>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>Options</th>
                </tr>
                <tr>
                    <td><strong>Naming</strong></td>
                    <td>
                        ‚Ä¢ Direct: send(P, message), receive(Q, message)<br>
                        ‚Ä¢ Indirect: via mailboxes/ports
                    </td>
                </tr>
                <tr>
                    <td><strong>Synchronization</strong></td>
                    <td>
                        ‚Ä¢ Blocking (synchronous)<br>
                        ‚Ä¢ Non-blocking (asynchronous)
                    </td>
                </tr>
                <tr>
                    <td><strong>Buffering</strong></td>
                    <td>
                        ‚Ä¢ Zero capacity (no buffering)<br>
                        ‚Ä¢ Bounded capacity (finite buffer)<br>
                        ‚Ä¢ Unbounded capacity (infinite buffer)
                    </td>
                </tr>
            </table>

            <h3>UNIX IPC: Pipes</h3>
            <div class="code-block">
<span class="code-comment">// Pipe example in C</span>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

int main() {
    int fd[2];  <span class="code-comment">// File descriptors for pipe</span>
    pid_t pid;
    char write_msg[] = "Hello from parent";
    char read_msg[100];
    
    <span class="code-comment">// Create pipe</span>
    if (pipe(fd) < 0) {
        fprintf(stderr, "Pipe failed");
        return 1;
    }
    
    pid = fork();
    
    if (pid > 0) {  <span class="code-comment">// Parent process</span>
        close(fd[0]);  <span class="code-comment">// Close read end</span>
        write(fd[1], write_msg, strlen(write_msg) + 1);
        close(fd[1]);
    }
    else {  <span class="code-comment">// Child process</span>
        close(fd[1]);  <span class="code-comment">// Close write end</span>
        read(fd[0], read_msg, 100);
        printf("Child read: %s\n", read_msg);
        close(fd[0]);
    }
    
    return 0;
}
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Pipe Limitations:</h4>
                <ul>
                    <li>Unidirectional - data flows in one direction</li>
                    <li>Can only be used between related processes</li>
                    <li>Exist only while processes are communicating</li>
                    <li>For bidirectional, use two pipes</li>
                </ul>
            </div>
        </section>

        <!-- Section 8: Client-Server Communication -->
        <section>
            <h2>3.8 Communication in Client-Server Systems</h2>
            
            <h3>Communication Methods:</h3>
            <div class="process-grid">
                <div class="process-card">
                    <h4>üîå Sockets</h4>
                    <p>Endpoint for communication. Identified by IP address + port number.</p>
                </div>
                <div class="process-card">
                    <h4>üì° Remote Procedure Calls (RPC)</h4>
                    <p>Allows calling procedures on remote systems as if they were local.</p>
                </div>
                <div class="process-card">
                    <h4>üö™ Remote Method Invocation (RMI)</h4>
                    <p>Java mechanism similar to RPC for invoking methods on remote objects.</p>
                </div>
            </div>

            <h3>Socket Communication</h3>
            <div class="code-block">
<span class="code-comment">// Socket example (simplified)</span>
<span class="code-comment">// Server side</span>
int server_socket = socket(AF_INET, SOCK_STREAM, 0);
bind(server_socket, address, sizeof(address));
listen(server_socket, 3);
int new_socket = accept(server_socket, address, addrlen);
read(new_socket, buffer, 1024);

<span class="code-comment">// Client side</span>
int client_socket = socket(AF_INET, SOCK_STREAM, 0);
connect(client_socket, address, sizeof(address));
send(client_socket, message, strlen(message), 0);
            </div>
        </section>

        <!-- Section 9: Practice Problems -->
        <section>
            <h2>3.9 Exam-Style Practice Questions</h2>
            
            <div class="exam-section">
                <h3>Multiple Choice Questions</h3>
                
                <div class="exam-question">
                    <p><strong>Q1.</strong> Which of the following is NOT stored in the PCB?</p>
                    <ul class="mcq-options">
                        <li>a) Program counter</li>
                        <li>b) CPU registers</li>
                        <li class="correct-answer">c) Program source code</li>
                        <li>d) Process state</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q2.</strong> The main objective of multiprogramming is to improve:</p>
                    <ul class="mcq-options">
                        <li class="correct-answer">a) CPU utilization</li>
                        <li>b) Memory usage</li>
                        <li>c) User response time</li>
                        <li>d) System security</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q3.</strong> When a process creates a new process using fork(), which is shared?</p>
                    <ul class="mcq-options">
                        <li>a) Stack</li>
                        <li>b) Heap</li>
                        <li class="correct-answer">c) Shared memory segments</li>
                        <li>d) Program counter</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q4.</strong> Context switch time is:</p>
                    <ul class="mcq-options">
                        <li class="correct-answer">a) Pure overhead</li>
                        <li>b) Useful computation time</li>
                        <li>c) I/O time</li>
                        <li>d) User time</li>
                    </ul>
                </div>

                <h3>Short Answer Questions</h3>
                
                <div class="exam-question">
                    <p><strong>Q5.</strong> Explain the difference between long-term, medium-term, and short-term scheduling. (6 marks)</p>
                    <div class="example-box">
                        <h4>Answer:</h4>
                        <ul>
                            <li><strong>Long-term (Job Scheduler):</strong> Selects processes from job pool to load into memory. Controls degree of multiprogramming. Executes infrequently.</li>
                            <li><strong>Medium-term (Swapper):</strong> Removes processes from memory temporarily (swapping) to reduce multiprogramming degree. Can later reintroduce process.</li>
                            <li><strong>Short-term (CPU Scheduler):</strong> Selects from ready queue which process executes next on CPU. Executes very frequently (milliseconds).</li>
                        </ul>
                    </div>
                </div>

                <div class="exam-question">
                    <p><strong>Q6.</strong> How many processes are created by this program? (4 marks)</p>
                    <div class="code-block">
for (int i = 0; i < 4; i++)
    fork();
                    </div>
                    <div class="example-box">
                        <h4>Answer:</h4>
                        <p>2‚Å¥ = 16 processes total (including the initial parent)</p>
                        <p>Each fork() doubles the number of processes.</p>
                    </div>
                </div>

                <div class="exam-question">
                    <p><strong>Q7.</strong> What happens when a context switch occurs if the new context is already loaded in a register set? (3 marks)</p>
                    <div class="example-box">
                        <h4>Answer:</h4>
                        <p>If hardware provides multiple register sets and the new context is already loaded, the context switch is much faster - just switch the pointer to the active register set. No need to save/restore register values to/from memory.</p>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 10: Key Terms -->
        <section>
            <h2>3.10 Key Terms and Definitions</h2>
            
            <table>
                <tr>
                    <th>Term</th>
                    <th>Definition</th>
                </tr>
                <tr>
                    <td><strong>Process</strong></td>
                    <td>Program in execution; active entity with program counter</td>
                </tr>
                <tr>
                    <td><strong>PCB</strong></td>
                    <td>Process Control Block - data structure containing process information</td>
                </tr>
                <tr>
                    <td><strong>Context Switch</strong></td>
                    <td>Saving state of one process and loading state of another</td>
                </tr>
                <tr>
                    <td><strong>fork()</strong></td>
                    <td>System call that creates new process (child) in UNIX</td>
                </tr>
                <tr>
                    <td><strong>exec()</strong></td>
                    <td>System call that replaces process memory with new program</td>
                </tr>
                <tr>
                    <td><strong>wait()</strong></td>
                    <td>System call where parent waits for child to terminate</td>
                </tr>
                <tr>
                    <td><strong>IPC</strong></td>
                    <td>Interprocess Communication - mechanisms for process cooperation</td>
                </tr>
                <tr>
                    <td><strong>Pipe</strong></td>
                    <td>Unidirectional communication channel between processes</td>
                </tr>
                <tr>
                    <td><strong>Ready Queue</strong></td>
                    <td>List of processes ready and waiting to execute</td>
                </tr>
                <tr>
                    <td><strong>Degree of Multiprogramming</strong></td>
                    <td>Number of processes in memory</td>
                </tr>
            </table>
        </section>

        <!-- Image Placeholders -->
        <section>
            <h2>3.11 Diagrams from Slides</h2>
            
            <div class="image-placeholder">
                <h4>üìä Process State Diagram</h4>
                <p>[Insert detailed state transition diagram from Chapter_3.pdf]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä PCB Structure</h4>
                <p>[Insert PCB diagram showing all fields]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Context Switch Timeline</h4>
                <p>[Insert context switch between P0 and P1]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Ready and Wait Queue Structure</h4>
                <p>[Insert queue diagram with PCB links]</p>
            </div>

            <div class="warning-box">
                <p><strong>Note:</strong> Please provide the actual diagrams from your Chapter_3.pdf slides to replace these placeholders.</p>
            </div>
        </section>

        <footer>
            <p>CS330 - Operating Systems</p>
            <p>Chapter 3: Processes</p>
            <p><strong>Created by: Shoug Alomran</strong></p>
        </footer>
    </div>
</body>
</html>