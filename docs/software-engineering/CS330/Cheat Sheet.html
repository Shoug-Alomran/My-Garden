<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operating Systems CS330 - Comprehensive Cheatsheet</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .content {
            padding: 30px;
        }
        
        .chapter {
            margin-bottom: 40px;
            border-left: 4px solid #667eea;
            padding-left: 20px;
        }
        
        .chapter-title {
            font-size: 2em;
            color: #667eea;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
        }
        
        .chapter-number {
            background: #667eea;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin-right: 15px;
            font-weight: bold;
        }
        
        .section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
        }
        
        .section h3 {
            color: #764ba2;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 2px solid #764ba2;
            padding-bottom: 5px;
        }
        
        .key-concept {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .tip {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .tip::before {
            content: "üí° TIP: ";
            font-weight: bold;
            color: #ff9800;
        }
        
        .exam-example {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
        }
        
        .exam-example::before {
            content: "üìù PAST EXAM: ";
            font-weight: bold;
            color: #9c27b0;
        }
        
        .formula {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            text-align: center;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: white;
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 12px;
            text-align: left;
        }
        
        td {
            padding: 12px;
            border: 1px solid #ddd;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        code {
            background: #263238;
            color: #aed581;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }
        
        .code-block {
            background: #263238;
            color: #aed581;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
        }
        
        ul, ol {
            margin-left: 20px;
            margin-top: 10px;
        }
        
        li {
            margin: 8px 0;
        }
        
        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 15px 0;
        }
        
        .comparison-item {
            background: white;
            padding: 15px;
            border-radius: 5px;
            border: 2px solid #667eea;
        }
        
        .comparison-item h4 {
            color: #667eea;
            margin-bottom: 10px;
        }
        
        .state-diagram {
            background: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            margin: 15px 0;
            border: 2px solid #667eea;
        }
        
        @media print {
            body {
                background: white;
            }
            .container {
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Operating Systems CS330</h1>
            <p>Comprehensive Exam Cheatsheet</p>
            <p>Prince Sultan University</p>
        </header>
        
        <div class="content">
            
            <!-- CHAPTER 1: INTRODUCTION -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">1</span>
                    Introduction to Operating Systems
                </h2>
                
                <div class="section">
                    <h3>üéØ What is an Operating System?</h3>
                    <div class="key-concept">
                        <strong>Definition:</strong> A program that acts as an intermediary between users and computer hardware.
                        <ul>
                            <li><strong>Goals:</strong> Execute user programs, make system convenient, use hardware efficiently</li>
                            <li><strong>Kernel:</strong> The one program running at all times (core of OS)</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        Remember the 4 components: Hardware ‚Üí OS ‚Üí Applications ‚Üí Users
                    </div>
                </div>
                
                <div class="section">
                    <h3>üíæ Computer System Organization</h3>
                    
                    <table>
                        <tr>
                            <th>Component</th>
                            <th>Access Time</th>
                            <th>Volatility</th>
                        </tr>
                        <tr>
                            <td>Registers</td>
                            <td>~1 ns</td>
                            <td>Volatile</td>
                        </tr>
                        <tr>
                            <td>Cache</td>
                            <td>~2-10 ns</td>
                            <td>Volatile</td>
                        </tr>
                        <tr>
                            <td>Main Memory (RAM)</td>
                            <td>~100 ns</td>
                            <td>Volatile</td>
                        </tr>
                        <tr>
                            <td>SSD</td>
                            <td>~100 Œºs</td>
                            <td>Non-volatile</td>
                        </tr>
                        <tr>
                            <td>Magnetic Disk</td>
                            <td>~8-50 ms</td>
                            <td>Non-volatile</td>
                        </tr>
                    </table>
                    
                    <div class="tip">
                        Mnemonic: "RegistersCacheRAM" ‚Üí RCR ‚Üí Faster and more expensive
                    </div>
                </div>
                
                <div class="section">
                    <h3>‚ö° Interrupts</h3>
                    
                    <div class="key-concept">
                        <strong>Types:</strong>
                        <ul>
                            <li><strong>Hardware Interrupt:</strong> From I/O devices (keyboard, mouse, disk)</li>
                            <li><strong>Software Interrupt (Trap/Exception):</strong> From errors or system calls</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Interrupt Handling Process:</strong>
                        <ol>
                            <li>Save PCB (Program Counter and Registers)</li>
                            <li>Determine interrupt type (polling or vectored)</li>
                            <li>Execute Interrupt Service Routine (ISR)</li>
                            <li>Restore saved information</li>
                            <li>Resume execution</li>
                        </ol>
                    </div>
                    
                    <div class="tip">
                        Interrupt Vector = Table of addresses pointing to ISRs
                    </div>
                </div>
                
                <div class="section">
                    <h3>üöÄ DMA (Direct Memory Access)</h3>
                    
                    <div class="key-concept">
                        <ul>
                            <li>Used for high-speed I/O devices</li>
                            <li>Transfers data directly between I/O and memory WITHOUT CPU</li>
                            <li>Only ONE interrupt per block (not per byte)</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        Q: Which is efficient for moving large amounts of data between I/O devices and main memory without CPU?<br>
                        <strong>Answer: DMA</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üñ•Ô∏è Multiprocessor Systems</h3>
                    
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h4>Symmetric (SMP)</h4>
                            <ul>
                                <li>Each processor performs ALL tasks</li>
                                <li>No master-slave relationship</li>
                                <li>Equal processors</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h4>Asymmetric (AMP)</h4>
                            <ul>
                                <li>Master processor controls slaves</li>
                                <li>Boss-worker relationship</li>
                                <li>Used in large systems</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Advantages:</strong>
                        <ol>
                            <li><strong>Increased Throughput:</strong> More work in less time</li>
                            <li><strong>Economy of Scale:</strong> Cost less than multiple single-processors</li>
                            <li><strong>Increased Reliability:</strong> Graceful degradation/fault tolerance</li>
                        </ol>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîê Dual-Mode Operation</h3>
                    
                    <div class="key-concept">
                        <table>
                            <tr>
                                <th>Mode</th>
                                <th>Bit Value</th>
                                <th>Purpose</th>
                            </tr>
                            <tr>
                                <td>Kernel/System Mode</td>
                                <td>0</td>
                                <td>OS execution, privileged instructions</td>
                            </tr>
                            <tr>
                                <td>User Mode</td>
                                <td>1</td>
                                <td>User application execution</td>
                            </tr>
                        </table>
                    </div>
                    
                    <div class="tip">
                        System call changes mode to kernel, return resets to user
                    </div>
                    
                    <div class="exam-example">
                        Q: Privileged instructions can only be executed in?<br>
                        <strong>Answer: Kernel mode (mode bit = 0)</strong>
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 2: OS STRUCTURES -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">2</span>
                    Operating System Structures
                </h2>
                
                <div class="section">
                    <h3>üõ†Ô∏è OS Services</h3>
                    
                    <div class="key-concept">
                        <strong>For Users:</strong>
                        <ul>
                            <li><strong>User Interface:</strong> CLI, GUI, Touchscreen</li>
                            <li><strong>Program Execution:</strong> Load, run, end programs</li>
                            <li><strong>I/O Operations:</strong> Users can't do I/O directly</li>
                            <li><strong>File System Manipulation:</strong> Read, write, create, delete</li>
                            <li><strong>Communications:</strong> Shared memory or message passing</li>
                            <li><strong>Error Detection:</strong> Detect CPU, memory, I/O errors</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>For System Efficiency:</strong>
                        <ul>
                            <li><strong>Resource Allocation:</strong> Manage CPU, memory, files</li>
                            <li><strong>Accounting:</strong> Track usage statistics</li>
                            <li><strong>Protection & Security:</strong> Control access, defend attacks</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üìû System Calls</h3>
                    
                    <div class="key-concept">
                        <strong>Definition:</strong> Interface between running program and OS
                        <ul>
                            <li>Accessed via API (Win32, POSIX, Java)</li>
                            <li>Each system call has a number</li>
                            <li>System-call interface maintains indexed table</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Parameter Passing Methods:</strong>
                        <ol>
                            <li><strong>Registers:</strong> Simplest, limited by register count</li>
                            <li><strong>Block/Table in Memory:</strong> Pass address of block</li>
                            <li><strong>Stack:</strong> Push parameters, pop by OS</li>
                        </ol>
                    </div>
                    
                    <table>
                        <tr>
                            <th>Category</th>
                            <th>Examples</th>
                        </tr>
                        <tr>
                            <td>Process Control</td>
                            <td>fork(), exec(), exit(), wait()</td>
                        </tr>
                        <tr>
                            <td>File Management</td>
                            <td>open(), close(), read(), write()</td>
                        </tr>
                        <tr>
                            <td>Device Management</td>
                            <td>request(), release(), read(), write()</td>
                        </tr>
                        <tr>
                            <td>Information Maintenance</td>
                            <td>getpid(), time(), date()</td>
                        </tr>
                        <tr>
                            <td>Communications</td>
                            <td>send(), receive(), create/delete connection</td>
                        </tr>
                    </table>
                </div>
                
                <div class="section">
                    <h3>üèóÔ∏è OS Structure Types</h3>
                    
                    <div class="key-concept">
                        <strong>1. Monolithic (Simple Structure - MS-DOS)</strong>
                        <ul>
                            <li>All functionality in one binary</li>
                            <li>Fast but hard to maintain</li>
                            <li>Changes affect entire system</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Layered Approach</strong>
                        <ul>
                            <li>Layer 0 = Hardware, Layer N = User Interface</li>
                            <li>Each layer uses only lower layers</li>
                            <li>Easy debugging but performance overhead</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Microkernel</strong>
                        <ul>
                            <li>Move non-essential components to user space</li>
                            <li>Communication via message passing</li>
                            <li><strong>Advantages:</strong> Easy to extend, portable, reliable, secure</li>
                            <li><strong>Disadvantages:</strong> Communication overhead</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>4. Modules (Modern Approach)</strong>
                        <ul>
                            <li>Core kernel + loadable modules</li>
                            <li>Similar to layers but more flexible</li>
                            <li>Used in Linux, macOS, Solaris, Windows</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        Q: Which allows direct communication among all OS services?<br>
                        <strong>Answer: Modular approach (any module can call any other)</strong>
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 3: PROCESSES -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">3</span>
                    Processes
                </h2>
                
                <div class="section">
                    <h3>üìã Process Concept</h3>
                    
                    <div class="key-concept">
                        <strong>Process = Program in Execution</strong>
                        <ul>
                            <li><strong>Program:</strong> Passive entity (executable file on disk)</li>
                            <li><strong>Process:</strong> Active entity (program loaded in memory)</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Process Memory Layout:</strong>
                        <ul>
                            <li><strong>Text Section:</strong> Program code (read-only)</li>
                            <li><strong>Data Section:</strong> Global variables</li>
                            <li><strong>Heap:</strong> Dynamically allocated memory (grows upward)</li>
                            <li><strong>Stack:</strong> Function parameters, return addresses, local variables (grows downward)</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        Remember: "Text Data Heap Stack" ‚Üí TDHS ‚Üí From low to high memory addresses
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîÑ Process States</h3>
                    
                    <div class="state-diagram">
                        <strong>Process State Diagram:</strong><br><br>
                        NEW ‚Üí [admitted] ‚Üí READY ‚Üí [scheduler dispatch] ‚Üí RUNNING<br>
                        ‚Üë_____________‚Üê_[I/O or event completion]_‚Üê_WAITING_‚Üê_[I/O or event wait]_‚Üê_‚Üì<br>
                        RUNNING ‚Üí [interrupt] ‚Üí READY<br>
                        RUNNING ‚Üí [exit] ‚Üí TERMINATED
                    </div>
                    
                    <table>
                        <tr>
                            <th>State</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>NEW</td>
                            <td>Process is being created, PCB is being initialized</td>
                        </tr>
                        <tr>
                            <td>READY</td>
                            <td>Waiting to be assigned to CPU</td>
                        </tr>
                        <tr>
                            <td>RUNNING</td>
                            <td>Instructions are being executed</td>
                        </tr>
                        <tr>
                            <td>WAITING</td>
                            <td>Waiting for I/O or event to occur</td>
                        </tr>
                        <tr>
                            <td>TERMINATED</td>
                            <td>Process has finished execution</td>
                        </tr>
                    </table>
                    
                    <div class="exam-example">
                        Q: A process in Running state can next go to which states?<br>
                        <strong>Answer: Ready, Waiting, Terminated</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üì¶ Process Control Block (PCB)</h3>
                    
                    <div class="key-concept">
                        <strong>PCB Contains:</strong>
                        <ul>
                            <li>Process ID (PID)</li>
                            <li>Process State (Ready, Running, etc.)</li>
                            <li>Program Counter (PC)</li>
                            <li>CPU Registers</li>
                            <li>CPU Scheduling Information (priority, queues)</li>
                            <li>Memory Management Information</li>
                            <li>Accounting Information (CPU time, time limits)</li>
                            <li>I/O Status Information (open files, I/O devices)</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        PCB is stored in KERNEL MEMORY, NOT in text section of process
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîÄ Context Switch</h3>
                    
                    <div class="key-concept">
                        <strong>Steps:</strong>
                        <ol>
                            <li>Save PCB of current process (registers, PC, state)</li>
                            <li>Load PCB of new process</li>
                            <li>Resume execution of new process</li>
                        </ol>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Context Switch Time:</strong>
                        <ul>
                            <li>Pure overhead (no useful work done)</li>
                            <li>Depends on hardware support (some CPUs have multiple register sets)</li>
                            <li>Typically 1-1000 microseconds</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üìÖ Process Scheduling</h3>
                    
                    <table>
                        <tr>
                            <th>Scheduler</th>
                            <th>Also Known As</th>
                            <th>Purpose</th>
                            <th>Frequency</th>
                        </tr>
                        <tr>
                            <td>Long-term</td>
                            <td>Job Scheduler</td>
                            <td>Select which jobs to bring to ready queue</td>
                            <td>Infrequent (seconds/minutes)</td>
                        </tr>
                        <tr>
                            <td>Short-term</td>
                            <td>CPU Scheduler</td>
                            <td>Select which ready process gets CPU</td>
                            <td>Very frequent (milliseconds)</td>
                        </tr>
                        <tr>
                            <td>Medium-term</td>
                            <td>Swapper</td>
                            <td>Swap processes in/out of memory</td>
                            <td>Intermediate</td>
                        </tr>
                    </table>
                    
                    <div class="key-concept">
                        <strong>Process Types:</strong>
                        <ul>
                            <li><strong>I/O Bound:</strong> More time doing I/O, many short CPU bursts</li>
                            <li><strong>CPU Bound:</strong> More time computing, few long CPU bursts</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        Long-term scheduler controls DEGREE OF MULTIPROGRAMMING
                    </div>
                </div>
                
                <div class="section">
                    <h3>üë∂ Process Creation - fork()</h3>
                    
                    <div class="key-concept">
                        <strong>fork() System Call:</strong>
                        <ul>
                            <li>Creates a child process (copy of parent)</li>
                            <li>Returns 0 to child process</li>
                            <li>Returns child PID to parent process</li>
                            <li>Returns -1 on error</li>
                        </ul>
                    </div>
                    
                    <div class="code-block">
pid_t pid = fork();

if (pid < 0) {
    // Error occurred
    fprintf(stderr, "Fork Failed");
}
else if (pid == 0) {
    // Child process
    printf("I am child, pid = %d", getpid());
}
else {
    // Parent process
    printf("I am parent, my child's pid = %d", pid);
    wait(NULL);  // Wait for child to terminate
}
                    </div>
                    
                    <div class="exam-example">
                        Q: Given actual PIDs are parent=3600, child=3608:<br>
                        Line A (child): pid = <strong>0</strong><br>
                        Line B (child): pid1 = <strong>3608</strong><br>
                        Line C (parent): pid = <strong>3608</strong><br>
                        Line D (parent): pid1 = <strong>3600</strong>
                    </div>
                    
                    <div class="exam-example">
                        Q: How many processes created by 4 fork() calls in a loop?<br>
                        <strong>Answer: 2^4 = 16 processes (including parent)</strong>
                    </div>
                    
                    <div class="tip">
                        Child gets COPY of parent's memory (data, heap, stack), NOT shared!
                    </div>
                </div>
                
                <div class="section">
                    <h3>üí¨ Interprocess Communication (IPC)</h3>
                    
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h4>Shared Memory</h4>
                            <ul>
                                <li><strong>Faster</strong> - no system calls after setup</li>
                                <li>Direct memory access</li>
                                <li>Requires synchronization</li>
                                <li>Good for large data</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h4>Message Passing</h4>
                            <ul>
                                <li><strong>Easier</strong> - OS handles synchronization</li>
                                <li>send() and receive() system calls</li>
                                <li>Slower due to system calls</li>
                                <li>Good for small messages</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 4: THREADS -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">4</span>
                    Threads and Concurrency
                </h2>
                
                <div class="section">
                    <h3>üßµ Thread Basics</h3>
                    
                    <div class="key-concept">
                        <strong>Thread = Lightweight Process</strong>
                        <p>A thread is a basic unit of CPU utilization comprising:</p>
                        <ul>
                            <li>Thread ID</li>
                            <li>Program Counter</li>
                            <li>Register Set</li>
                            <li>Stack</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Threads SHARE within a process:</strong>
                        <ul>
                            <li>Code Section</li>
                            <li>Data Section (global variables)</li>
                            <li>Heap</li>
                            <li>Open Files</li>
                            <li>OS Resources</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Each thread has OWN:</strong>
                        <ul>
                            <li>Stack</li>
                            <li>Program Counter</li>
                            <li>Registers</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        Q: Which is NOT shared by threads?<br>
                        <strong>Answer: Program counter and stack</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>‚úÖ Benefits of Multithreading</h3>
                    
                    <div class="key-concept">
                        <ol>
                            <li><strong>Responsiveness:</strong> Program continues even if part blocked (e.g., web browser loading image while user interacts)</li>
                            <li><strong>Resource Sharing:</strong> Threads share memory and resources (easier than IPC)</li>
                            <li><strong>Economy:</strong> 
                                <ul>
                                    <li>Thread creation: 30x faster than process (Solaris)</li>
                                    <li>Context switch between threads: faster</li>
                                </ul>
                            </li>
                            <li><strong>Scalability:</strong> Utilizes multiprocessor architectures</li>
                        </ol>
                    </div>
                    
                    <div class="exam-example">
                        Q: Why threads instead of processes?<br>
                        <strong>Answer: Faster creation, faster context switch, easier communication (shared memory)</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîó Multithreading Models</h3>
                    
                    <div class="key-concept">
                        <strong>1. Many-to-One</strong>
                        <ul>
                            <li>Many user threads ‚Üí One kernel thread</li>
                            <li>Managed by thread library (efficient)</li>
                            <li>‚ùå Entire process blocks if one thread blocks</li>
                            <li>‚ùå Cannot run in parallel on multiprocessors</li>
                            <li>Example: Green Threads</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. One-to-One</strong>
                        <ul>
                            <li>Each user thread ‚Üí One kernel thread</li>
                            <li>‚úÖ More concurrency (one thread blocks, others run)</li>
                            <li>‚úÖ Can run in parallel on multiprocessors</li>
                            <li>‚ùå Overhead of creating kernel threads</li>
                            <li>Example: Windows, Linux</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Many-to-Many</strong>
                        <ul>
                            <li>Many user threads ‚Üí Many kernel threads</li>
                            <li>‚úÖ Best of both worlds</li>
                            <li>‚úÖ Can run in parallel</li>
                            <li>‚úÖ If one blocks, can schedule another</li>
                            <li>Example: Solaris prior to version 9</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>‚ö° Concurrency vs Parallelism</h3>
                    
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h4>Concurrency</h4>
                            <ul>
                                <li>Multiple tasks make progress</li>
                                <li>Time-sharing on single core</li>
                                <li>Interleaved execution</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h4>Parallelism</h4>
                            <ul>
                                <li>Multiple tasks execute simultaneously</li>
                                <li>Requires multiple cores</li>
                                <li>True simultaneous execution</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Types of Parallelism:</strong>
                        <ul>
                            <li><strong>Data Parallelism:</strong> Same operation on different data subsets (e.g., image processing)</li>
                            <li><strong>Task Parallelism:</strong> Different tasks on different cores</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 5: CPU SCHEDULING -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">5</span>
                    CPU Scheduling
                </h2>
                
                <div class="section">
                    <h3>üìä Scheduling Criteria</h3>
                    
                    <table>
                        <tr>
                            <th>Criterion</th>
                            <th>Goal</th>
                            <th>Formula/Description</th>
                        </tr>
                        <tr>
                            <td>CPU Utilization</td>
                            <td>Maximize</td>
                            <td>Keep CPU busy (40%-90%)</td>
                        </tr>
                        <tr>
                            <td>Throughput</td>
                            <td>Maximize</td>
                            <td># processes completed per time unit</td>
                        </tr>
                        <tr>
                            <td>Turnaround Time</td>
                            <td>Minimize</td>
                            <td>Finish Time - Arrival Time</td>
                        </tr>
                        <tr>
                            <td>Waiting Time</td>
                            <td>Minimize</td>
                            <td>Turnaround Time - Burst Time</td>
                        </tr>
                        <tr>
                            <td>Response Time</td>
                            <td>Minimize</td>
                            <td>First Response - Arrival Time</td>
                        </tr>
                    </table>
                    
                    <div class="formula">
                        Turnaround Time = Waiting Time + Burst Time<br>
                        Waiting Time = Turnaround Time - Burst Time
                    </div>
                </div>
                
                <div class="section">
                    <h3>üéØ Scheduling Algorithms</h3>
                    
                    <div class="key-concept">
                        <strong>1. First-Come First-Served (FCFS)</strong>
                        <ul>
                            <li><strong>Type:</strong> Non-preemptive</li>
                            <li><strong>Order:</strong> Process arrival order</li>
                            <li>‚ùå Convoy effect (short processes wait for long ones)</li>
                            <li>‚úÖ Simple to implement</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Shortest Job First (SJF)</strong>
                        <ul>
                            <li><strong>Type:</strong> Can be preemptive or non-preemptive</li>
                            <li><strong>Order:</strong> Shortest burst time first</li>
                            <li>‚úÖ Optimal (minimum average waiting time)</li>
                            <li>‚ùå Cannot know future burst times (must estimate)</li>
                            <li>‚ùå Starvation possible for long processes</li>
                        </ul>
                    </div>
                    
                    <div class="formula">
                        Exponential Averaging for predicting next CPU burst:<br>
                        œÑ(n+1) = Œ± √ó t(n) + (1-Œ±) √ó œÑ(n)<br>
                        where Œ± typically = 0.5
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Priority Scheduling</strong>
                        <ul>
                            <li><strong>Type:</strong> Can be preemptive or non-preemptive</li>
                            <li><strong>Order:</strong> Highest priority first (smaller number = higher priority)</li>
                            <li>‚ùå Starvation problem</li>
                            <li>‚úÖ Solution: Aging (increase priority over time)</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>4. Round Robin (RR)</strong>
                        <ul>
                            <li><strong>Type:</strong> Preemptive</li>
                            <li><strong>Order:</strong> Each process gets time quantum (10-100ms)</li>
                            <li>‚úÖ Good for time-sharing systems</li>
                            <li>‚úÖ Fair allocation</li>
                            <li>‚ö†Ô∏è If quantum too large ‚Üí becomes FCFS</li>
                            <li>‚ö†Ô∏è If quantum too small ‚Üí too many context switches</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        Rule: 80% of CPU bursts should be shorter than time quantum
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM: Processes with different burst times and priorities</strong><br>
                        Given: P1(BT=4, Pri=3), P2(BT=3, Pri=1), P3(BT=8, Pri=4), P4(BT=7, Pri=2), P5(BT=5, Pri=3)<br>
                        All arrive at time 0.<br><br>
                        
                        <strong>Priority Scheduling (smaller # = higher priority):</strong><br>
                        Gantt: P2(0-3) | P4(3-10) | P1(10-14) | P5(14-19) | P3(19-27)<br>
                        Waiting Times: P1=10, P2=0, P3=19-8=11, P4=3, P5=14-5=9
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîÑ Preemptive vs Non-Preemptive</h3>
                    
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h4>Non-Preemptive</h4>
                            <ul>
                                <li>Process keeps CPU until terminates or waits</li>
                                <li>Examples: FCFS, SJF (non-preemptive)</li>
                                <li>No race conditions on shared data</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h4>Preemptive</h4>
                            <ul>
                                <li>Process can be interrupted</li>
                                <li>Examples: RR, SJF (preemptive/SRTF), Priority (preemptive)</li>
                                <li>Can cause race conditions</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üìê Practice Problem</h3>
                    
                    <div class="exam-example">
                        <strong>PRACTICE:</strong> Calculate waiting time and turnaround time<br><br>
                        Processes: P1(BT=24), P2(BT=3), P3(BT=3)<br>
                        Order: P1, P2, P3, all arrive at t=0<br><br>
                        
                        <strong>FCFS:</strong><br>
                        Gantt: P1(0-24) | P2(24-27) | P3(27-30)<br>
                        WT: P1=0, P2=24, P3=27<br>
                        Average WT = (0+24+27)/3 = 17ms<br><br>
                        
                        <strong>SJF:</strong><br>
                        Gantt: P2(0-3) | P3(3-6) | P1(6-30)<br>
                        WT: P1=6, P2=0, P3=3<br>
                        Average WT = (6+0+3)/3 = 3ms ‚úÖ OPTIMAL!
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 6: SYNCHRONIZATION -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">6</span>
                    Process Synchronization
                </h2>
                
                <div class="section">
                    <h3>‚ö†Ô∏è Critical Section Problem</h3>
                    
                    <div class="key-concept">
                        <strong>Race Condition:</strong> Multiple processes access shared data concurrently, outcome depends on execution order
                    </div>
                    
                    <div class="key-concept">
                        <strong>Critical Section:</strong> Code segment accessing shared resources
                    </div>
                    
                    <div class="key-concept">
                        <strong>Solution Must Satisfy 3 Requirements:</strong>
                        <ol>
                            <li><strong>Mutual Exclusion:</strong> Only ONE process in CS at a time</li>
                            <li><strong>Progress:</strong> Only processes NOT in remainder section can decide who enters CS next</li>
                            <li><strong>Bounded Waiting:</strong> Limit on # times others enter CS before a waiting process</li>
                        </ol>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîí Semaphores</h3>
                    
                    <div class="key-concept">
                        <strong>Semaphore S:</strong> Integer variable accessed only by:
                        <ul>
                            <li><strong>wait(S):</strong> S--; if S<0, block</li>
                            <li><strong>signal(S):</strong> S++; wake up blocked process if any</li>
                        </ul>
                    </div>
                    
                    <div class="code-block">
// Traditional wait (busy waiting)
wait(S) {
    while (S <= 0);  // busy wait
    S--;
}

// Traditional signal
signal(S) {
    S++;
}

// Modern implementation (no busy waiting)
wait(S) {
    S--;
    if (S < 0) {
        add this process to S->list;
        block();
    }
}

signal(S) {
    S++;
    if (S <= 0) {
        remove process P from S->list;
        wakeup(P);
    }
}
                    </div>
                    
                    <div class="key-concept">
                        <strong>Types:</strong>
                        <ul>
                            <li><strong>Binary Semaphore (Mutex):</strong> Value 0 or 1</li>
                            <li><strong>Counting Semaphore:</strong> Value can be any integer</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        Semaphore initialized to 1 = Mutex lock!
                    </div>
                </div>
                
                <div class="section">
                    <h3>üçù Classic Problems</h3>
                    
                    <div class="key-concept">
                        <strong>1. Bounded Buffer (Producer-Consumer)</strong>
                        <div class="code-block">
// Shared data
semaphore mutex = 1;     // mutual exclusion
semaphore empty = n;     // count empty slots
semaphore full = 0;      // count full slots

// Producer
do {
    // produce item
    wait(empty);         // wait for empty slot
    wait(mutex);         // enter CS
    // add item to buffer
    signal(mutex);       // exit CS
    signal(full);        // increment full count
} while(true);

// Consumer
do {
    wait(full);          // wait for full slot
    wait(mutex);         // enter CS
    // remove item from buffer
    signal(mutex);       // exit CS
    signal(empty);       // increment empty count
    // consume item
} while(true);
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Readers-Writers Problem</strong>
                        <div class="code-block">
// Shared data
semaphore rw_mutex = 1;  // mutual exclusion for writers
semaphore mutex = 1;      // protects readcount
int readcount = 0;

// Writer
do {
    wait(rw_mutex);
    // writing performed
    signal(rw_mutex);
} while(true);

// Reader
do {
    wait(mutex);
    readcount++;
    if (readcount == 1)  // first reader
        wait(rw_mutex);   // lock out writers
    signal(mutex);
    
    // reading performed
    
    wait(mutex);
    readcount--;
    if (readcount == 0)  // last reader
        signal(rw_mutex);  // allow writers
    signal(mutex);
} while(true);
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Dining Philosophers</strong>
                        <ul>
                            <li>5 philosophers, 5 chopsticks</li>
                            <li>Need 2 chopsticks to eat</li>
                            <li>‚ùå Deadlock if all pick up left chopstick</li>
                        </ul>
                        <strong>Solutions:</strong>
                        <ul>
                            <li>Allow only 4 philosophers at table</li>
                            <li>Pick up both chopsticks atomically</li>
                            <li>Odd philosophers pick left first, even pick right first</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üíÄ Deadlock</h3>
                    
                    <div class="key-concept">
                        <strong>Necessary Conditions (ALL must hold):</strong>
                        <ol>
                            <li><strong>Mutual Exclusion:</strong> At least one resource non-sharable</li>
                            <li><strong>Hold and Wait:</strong> Process holds resources while waiting for more</li>
                            <li><strong>No Preemption:</strong> Resources cannot be forcibly taken</li>
                            <li><strong>Circular Wait:</strong> P1 waits for P2, P2 for P3, ..., Pn for P1</li>
                        </ol>
                    </div>
                    
                    <div class="tip">
                        Mnemonic: "My Husband Never Comes" ‚Üí Mutual Exclusion, Hold and Wait, No Preemption, Circular Wait
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 8: MEMORY MANAGEMENT -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">8</span>
                    Main Memory Management
                </h2>
                
                <div class="section">
                    <h3>üìç Address Binding</h3>
                    
                    <div class="key-concept">
                        <strong>Logical vs Physical Address:</strong>
                        <ul>
                            <li><strong>Logical (Virtual):</strong> Generated by CPU, seen by program</li>
                            <li><strong>Physical:</strong> Actual location in RAM, seen by memory unit</li>
                        </ul>
                    </div>
                    
                    <table>
                        <tr>
                            <th>Binding Time</th>
                            <th>When</th>
                            <th>Relocatable?</th>
                        </tr>
                        <tr>
                            <td>Compile Time</td>
                            <td>If memory location known in advance</td>
                            <td>No (absolute code)</td>
                        </tr>
                        <tr>
                            <td>Load Time</td>
                            <td>When program loaded into memory</td>
                            <td>Yes (relocatable code)</td>
                        </tr>
                        <tr>
                            <td>Execution Time</td>
                            <td>During program execution</td>
                            <td>Yes (requires MMU)</td>
                        </tr>
                    </table>
                </div>
                
                <div class="section">
                    <h3>üó∫Ô∏è Memory Management Unit (MMU)</h3>
                    
                    <div class="key-concept">
                        <strong>MMU:</strong> Hardware device that maps logical to physical addresses
                    </div>
                    
                    <div class="formula">
                        Physical Address = Base Register + Logical Address
                    </div>
                    
                    <div class="key-concept">
                        <strong>Base and Limit Registers:</strong>
                        <ul>
                            <li><strong>Base:</strong> Starting physical address</li>
                            <li><strong>Limit:</strong> Size of logical address space</li>
                            <li>Protection: If (logical address >= limit) ‚Üí error!</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üß© Contiguous Memory Allocation</h3>
                    
                    <div class="key-concept">
                        <strong>Fixed Partitioning:</strong>
                        <ul>
                            <li>Memory divided into fixed-size partitions</li>
                            <li>‚ùå Internal fragmentation</li>
                            <li>‚ùå Limits multiprogramming</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Variable Partitioning:</strong>
                        <ul>
                            <li>Dynamic allocation based on process size</li>
                            <li>‚ùå External fragmentation</li>
                            <li>Solution: Compaction (requires dynamic relocation)</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Allocation Algorithms:</strong>
                        <ul>
                            <li><strong>First-Fit:</strong> Allocate first hole big enough (fastest)</li>
                            <li><strong>Best-Fit:</strong> Allocate smallest hole big enough (smallest leftover)</li>
                            <li><strong>Worst-Fit:</strong> Allocate largest hole (largest leftover)</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong> Memory partitions: 300KB, 600KB, 350KB, 200KB, 750KB, 125KB<br>
                        Processes: 115KB, 500KB, 358KB, 200KB, 375KB<br><br>
                        
                        <strong>Best-Fit:</strong><br>
                        115KB ‚Üí 125KB (10KB left)<br>
                        500KB ‚Üí 600KB (100KB left)<br>
                        358KB ‚Üí 750KB (392KB left)<br>
                        200KB ‚Üí 200KB (0KB left)<br>
                        375KB ‚Üí 392KB ‚úÖ All fit!
                    </div>
                </div>
                
                <div class="section">
                    <h3>üìÑ Paging</h3>
                    
                    <div class="key-concept">
                        <strong>Concept:</strong>
                        <ul>
                            <li>Divide logical memory into <strong>pages</strong> (fixed-size)</li>
                            <li>Divide physical memory into <strong>frames</strong> (same size)</li>
                            <li>Page size = Frame size (power of 2, e.g., 4KB)</li>
                            <li>‚úÖ No external fragmentation</li>
                            <li>‚ùå Internal fragmentation (last page)</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Logical Address Structure:</strong>
                        <div class="formula">
                            Logical Address = [Page Number | Page Offset]<br>
                            If logical address space = 2^m, page size = 2^n<br>
                            Page number = m - n bits<br>
                            Page offset = n bits
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Address Translation:</strong>
                        <ol>
                            <li>Extract page number (p) from logical address</li>
                            <li>Look up frame number (f) in page table[p]</li>
                            <li>Physical address = (f √ó frame_size) + offset</li>
                        </ol>
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong> Process has 4 pages, page size = 1KB<br>
                        Page table: [0‚Üí5, 1‚Üí10, 2‚Üí13, 3‚Üí7]<br>
                        Logical address = 1500<br><br>
                        
                        <strong>Solution:</strong><br>
                        Page size = 1024 bytes<br>
                        Page number = 1500 / 1024 = 1<br>
                        Offset = 1500 % 1024 = 476<br>
                        Frame number = page_table[1] = 10<br>
                        Physical address = 10 √ó 1024 + 476 = <strong>10716</strong>
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong> Logical address space = 256 pages, page size = 4KB<br>
                        Physical memory = 64 frames<br><br>
                        
                        <strong>a) Bits in logical address?</strong><br>
                        256 √ó 4KB = 256 √ó 4096 = 2^8 √ó 2^12 = 2^20<br>
                        Answer: <strong>20 bits</strong><br><br>
                        
                        <strong>b) Bits in physical address?</strong><br>
                        64 √ó 4KB = 64 √ó 4096 = 2^6 √ó 2^12 = 2^18<br>
                        Answer: <strong>18 bits</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>‚ö° Translation Lookaside Buffer (TLB)</h3>
                    
                    <div class="key-concept">
                        <strong>TLB:</strong> Fast associative cache for page table entries
                        <ul>
                            <li>Small (64-1024 entries)</li>
                            <li>Parallel search</li>
                            <li>Contains recent page translations</li>
                        </ul>
                    </div>
                    
                    <div class="formula">
                        <strong>Effective Access Time (EAT):</strong><br>
                        EAT = hit_ratio √ó (TLB_time + Memory_time)<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;+ (1 - hit_ratio) √ó (TLB_time + Page_Table_time + Memory_time)
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong><br>
                        Memory access = 50ns<br>
                        TLB access = 2ns<br>
                        Hit ratio = 75%<br><br>
                        
                        EAT = 0.75 √ó (2 + 50) + 0.25 √ó (2 + 50 + 50)<br>
                        EAT = 0.75 √ó 52 + 0.25 √ó 102<br>
                        EAT = 39 + 25.5 = <strong>64.5ns</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üóÇÔ∏è Segmentation</h3>
                    
                    <div class="key-concept">
                        <strong>Concept:</strong>
                        <ul>
                            <li>Divide memory by <strong>logical units</strong> (function, array, stack)</li>
                            <li>Variable-size segments</li>
                            <li>Programmer's view of memory</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Logical Address:</strong>
                        <div class="formula">
                            &lt;segment number, offset&gt;
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Segment Table:</strong>
                        <ul>
                            <li><strong>Base:</strong> Starting physical address</li>
                            <li><strong>Limit:</strong> Length of segment</li>
                            <li>Protection: If (offset >= limit) ‚Üí error!</li>
                        </ul>
                    </div>
                    
                    <div class="formula">
                        If offset < limit:<br>
                        &nbsp;&nbsp;Physical Address = Base + Offset<br>
                        Else:<br>
                        &nbsp;&nbsp;Segmentation Fault!
                    </div>
                    
                    <div class="exam-example">
                        <strong>EXAMPLE:</strong> Segment table<br>
                        [Seg 0: base=1200, limit=1000]<br>
                        [Seg 1: base=4000, limit=600]<br>
                        [Seg 2: base=2000, limit=1400]<br><br>
                        
                        Logical address &lt;1, 500&gt;:<br>
                        500 < 600 ‚úÖ Valid<br>
                        Physical = 4000 + 500 = <strong>4500</strong><br><br>
                        
                        Logical address &lt;1, 600&gt;:<br>
                        600 >= 600 ‚ùå <strong>Illegal!</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>‚öñÔ∏è Paging vs Segmentation</h3>
                    
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h4>Paging</h4>
                            <ul>
                                <li>Fixed-size pages</li>
                                <li>Physical view</li>
                                <li>No external fragmentation</li>
                                <li>Internal fragmentation</li>
                                <li>Transparent to programmer</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h4>Segmentation</h4>
                            <ul>
                                <li>Variable-size segments</li>
                                <li>Logical view</li>
                                <li>External fragmentation</li>
                                <li>No internal fragmentation</li>
                                <li>Visible to programmer</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 9: VIRTUAL MEMORY -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">9</span>
                    Virtual Memory
                </h2>
                
                <div class="section">
                    <h3>üí≠ Virtual Memory Concept</h3>
                    
                    <div class="key-concept">
                        <strong>Benefits:</strong>
                        <ul>
                            <li>Logical address space > Physical memory</li>
                            <li>More programs in memory simultaneously</li>
                            <li>Less I/O for loading</li>
                            <li>Faster program start</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Demand Paging:</strong>
                        <ul>
                            <li>Load pages only when needed</li>
                            <li>Lazy swapper (never swaps unless needed)</li>
                            <li>Uses valid-invalid bit in page table</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üí• Page Fault</h3>
                    
                    <div class="key-concept">
                        <strong>Page Fault Occurs When:</strong>
                        <ul>
                            <li>Process references a page not in memory</li>
                            <li>Page table entry has invalid bit set</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Page Fault Handling Steps:</strong>
                        <ol>
                            <li>Check internal table (PCB) - valid or invalid reference?</li>
                            <li>If invalid ‚Üí terminate process</li>
                            <li>If valid but not in memory ‚Üí page it in:
                                <ul>
                                    <li>Get empty frame</li>
                                    <li>Swap page from disk to frame</li>
                                    <li>Update page table (set valid bit)</li>
                                    <li>Restart instruction</li>
                                </ul>
                            </li>
                        </ol>
                    </div>
                    
                    <div class="formula">
                        <strong>Effective Access Time (EAT):</strong><br>
                        EAT = (1 - p) √ó memory_access + p √ó page_fault_time<br>
                        where p = page fault rate (0 ‚â§ p ‚â§ 1)
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong><br>
                        Memory access = 200ns<br>
                        Page fault service time = 8ms = 8,000,000ns<br>
                        Page fault rate = 1/1000 = 0.001<br><br>
                        
                        EAT = (1 - 0.001) √ó 200 + 0.001 √ó 8,000,000<br>
                        EAT = 0.999 √ó 200 + 8,000<br>
                        EAT = 199.8 + 8,000 = <strong>8,199.8ns ‚âà 8.2Œºs</strong>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîÑ Page Replacement Algorithms</h3>
                    
                    <div class="key-concept">
                        <strong>When to Use:</strong> When there are no free frames available
                    </div>
                    
                    <div class="key-concept">
                        <strong>1. FIFO (First-In-First-Out)</strong>
                        <ul>
                            <li>Replace oldest page in memory</li>
                            <li>Simple to implement</li>
                            <li>‚ùå Suffers from Belady's Anomaly (more frames ‚Üí more faults possible)</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Optimal (OPT)</strong>
                        <ul>
                            <li>Replace page that won't be used for longest time</li>
                            <li>‚úÖ Minimum page faults</li>
                            <li>‚ùå Impossible to implement (requires future knowledge)</li>
                            <li>Used as benchmark</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. LRU (Least Recently Used)</strong>
                        <ul>
                            <li>Replace page not used for longest time</li>
                            <li>‚úÖ Good approximation of optimal</li>
                            <li>‚úÖ Does not suffer from Belady's Anomaly</li>
                            <li>Implementation: Stack or counters</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong> Reference string: 7,2,3,1,2,5,3,4,6,7,7,1,0,5,4,6,2,3,0,1<br>
                        3 frames available<br><br>
                        
                        <strong>LRU Solution:</strong><br>
                        <table>
                            <tr>
                                <td>7</td><td>2</td><td>3</td><td>1</td><td>2</td><td>5</td><td>3</td><td>4</td><td>6</td><td>7</td><td>7</td><td>1</td><td>0</td><td>5</td><td>4</td><td>6</td><td>2</td><td>3</td><td>0</td><td>1</td>
                            </tr>
                            <tr>
                                <td>7</td><td>7</td><td>7</td><td>1</td><td>1</td><td>1</td><td>3</td><td>3</td><td>3</td><td>7</td><td>7</td><td>7</td><td>7</td><td>5</td><td>5</td><td>5</td><td>2</td><td>2</td><td>2</td><td>1</td>
                            </tr>
                            <tr>
                                <td></td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>2</td><td>4</td><td>4</td><td>4</td><td>4</td><td>1</td><td>1</td><td>1</td><td>4</td><td>4</td><td>4</td><td>3</td><td>3</td><td>3</td>
                            </tr>
                            <tr>
                                <td></td><td></td><td>3</td><td>3</td><td>3</td><td>5</td><td>5</td><td>5</td><td>6</td><td>6</td><td>6</td><td>6</td><td>0</td><td>0</td><td>0</td><td>6</td><td>6</td><td>6</td><td>0</td><td>0</td>
                            </tr>
                        </table>
                        <strong>Total Page Faults: 18</strong>
                    </div>
                    
                    <div class="tip">
                        Quick comparison: FIFO simple but Belady's; OPT best but impossible; LRU practical and good
                    </div>
                </div>
                
                <div class="section">
                    <h3>üåÄ Thrashing</h3>
                    
                    <div class="key-concept">
                        <strong>Thrashing:</strong> Process spends more time paging than executing
                    </div>
                    
                    <div class="key-concept">
                        <strong>Causes:</strong>
                        <ul>
                            <li>Process doesn't have enough frames</li>
                            <li>High degree of multiprogramming</li>
                            <li>Insufficient physical memory</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Solutions:</strong>
                        <ul>
                            <li>Decrease degree of multiprogramming</li>
                            <li>Increase physical memory (RAM)</li>
                            <li>Use local replacement algorithm</li>
                            <li>Provide enough frames per process</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong> System measurements:<br>
                        CPU utilization: 10%<br>
                        Paging disk: 97.7%<br><br>
                        
                        <strong>Diagnosis:</strong> System is thrashing!<br>
                        <strong>Solutions:</strong> (1) Decrease multiprogramming (2) Increase RAM
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 11: FILE SYSTEMS -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">11</span>
                    File Systems
                </h2>
                
                <div class="section">
                    <h3>üìÅ File Concept</h3>
                    
                    <div class="key-concept">
                        <strong>File:</strong> Named collection of related information stored on secondary storage
                    </div>
                    
                    <div class="key-concept">
                        <strong>File Attributes:</strong>
                        <ul>
                            <li><strong>Name:</strong> Human-readable form</li>
                            <li><strong>Identifier:</strong> Unique tag (inode number)</li>
                            <li><strong>Type:</strong> Text, binary, executable</li>
                            <li><strong>Location:</strong> Pointer to device and location</li>
                            <li><strong>Size:</strong> Current file size</li>
                            <li><strong>Protection:</strong> Read, write, execute permissions</li>
                            <li><strong>Time, date:</strong> Creation, last access, last modification</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>File Operations:</strong>
                        <ul>
                            <li><strong>Create:</strong> Find space, add directory entry</li>
                            <li><strong>Open:</strong> Load FCB to memory (open-file table)</li>
                            <li><strong>Read/Write:</strong> Use file pointer</li>
                            <li><strong>Seek:</strong> Reposition file pointer</li>
                            <li><strong>Close:</strong> Remove from open-file table</li>
                            <li><strong>Delete:</strong> Remove directory entry, free space</li>
                            <li><strong>Truncate:</strong> Delete contents, keep attributes</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üìÇ Directory Structure</h3>
                    
                    <div class="key-concept">
                        <strong>1. Single-Level Directory</strong>
                        <ul>
                            <li>All files in one directory</li>
                            <li>‚úÖ Simple</li>
                            <li>‚ùå Naming problem (all names must be unique)</li>
                            <li>‚ùå No grouping</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Two-Level Directory</strong>
                        <ul>
                            <li>Master File Directory (MFD) + User File Directories (UFD)</li>
                            <li>‚úÖ Isolates users</li>
                            <li>‚úÖ Efficient searching</li>
                            <li>‚ùå No grouping capability</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Tree-Structured Directory</strong>
                        <ul>
                            <li>Hierarchical structure (most common)</li>
                            <li>‚úÖ Efficient searching</li>
                            <li>‚úÖ Grouping capability</li>
                            <li>‚úÖ Current directory concept</li>
                            <li>Absolute path: /home/user/file.txt</li>
                            <li>Relative path: ../file.txt</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>4. Acyclic-Graph Directory</strong>
                        <ul>
                            <li>Allows sharing of files/subdirectories</li>
                            <li>Uses links (hard or symbolic)</li>
                            <li>‚ö†Ô∏è Deletion problem (dangling pointers)</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üîê File Protection</h3>
                    
                    <div class="key-concept">
                        <strong>Access Control List (ACL):</strong> Specifies users and allowed operations
                    </div>
                    
                    <div class="key-concept">
                        <strong>UNIX Protection (rwx):</strong>
                        <table>
                            <tr>
                                <th>Category</th>
                                <th>Description</th>
                            </tr>
                            <tr>
                                <td>Owner</td>
                                <td>File creator</td>
                            </tr>
                            <tr>
                                <td>Group</td>
                                <td>Set of users who share access</td>
                            </tr>
                            <tr>
                                <td>Universe (Others)</td>
                                <td>All other users</td>
                            </tr>
                        </table>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Permissions:</strong>
                        <ul>
                            <li><strong>r (read):</strong> Read file contents</li>
                            <li><strong>w (write):</strong> Write/modify file</li>
                            <li><strong>x (execute):</strong> Execute file</li>
                        </ul>
                        Example: rwxr-xr-- = Owner: rwx, Group: r-x, Others: r--
                    </div>
                </div>
                
                <div class="section">
                    <h3>üéØ Access Methods</h3>
                    
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h4>Sequential Access</h4>
                            <ul>
                                <li>Records processed in order</li>
                                <li>Like tape drive</li>
                                <li>Used by editors, compilers</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h4>Direct Access (Random)</h4>
                            <ul>
                                <li>Access any record directly</li>
                                <li>Fixed-length records</li>
                                <li>Used by databases</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Indexed Access:</strong>
                        <ul>
                            <li>Index file points to actual data</li>
                            <li>Can have multi-level indexes</li>
                            <li>Example: ISAM (Indexed Sequential Access Method)</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- CHAPTER 12: FILE SYSTEM IMPLEMENTATION -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">12</span>
                    File System Implementation
                </h2>
                
                <div class="section">
                    <h3>üíæ Disk Structure</h3>
                    
                    <div class="key-concept">
                        <strong>Magnetic Disk:</strong>
                        <ul>
                            <li><strong>Platters:</strong> Circular disks</li>
                            <li><strong>Tracks:</strong> Concentric circles on platter</li>
                            <li><strong>Sectors:</strong> Subdivisions of tracks (smallest addressable unit)</li>
                            <li><strong>Cylinder:</strong> All tracks at same radius on all platters</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Disk Access Time:</strong>
                        <div class="formula">
                            Access Time = Seek Time + Rotational Latency + Transfer Time
                        </div>
                        <ul>
                            <li><strong>Seek Time:</strong> Move head to correct cylinder (5-15ms)</li>
                            <li><strong>Rotational Latency:</strong> Wait for sector to rotate under head (4-8ms)</li>
                            <li><strong>Transfer Time:</strong> Read/write data (negligible)</li>
                        </ul>
                    </div>
                    
                    <div class="tip">
                        Typical total access time: 8-50ms (much slower than RAM!)
                    </div>
                </div>
                
                <div class="section">
                    <h3>üì¶ Allocation Methods</h3>
                    
                    <div class="key-concept">
                        <strong>1. Contiguous Allocation</strong>
                        <ul>
                            <li>Each file occupies contiguous blocks</li>
                            <li>‚úÖ Simple, best performance for sequential access</li>
                            <li>‚úÖ Direct access easy</li>
                            <li>‚ùå External fragmentation</li>
                            <li>‚ùå Files cannot grow</li>
                            <li>‚ùå Must know file size in advance</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Linked Allocation</strong>
                        <ul>
                            <li>Each block contains pointer to next block</li>
                            <li>‚úÖ No external fragmentation</li>
                            <li>‚úÖ Files can grow dynamically</li>
                            <li>‚ùå Slow sequential access</li>
                            <li>‚ùå No direct access</li>
                            <li>‚ùå Pointers use space</li>
                            <li>‚ùå Reliability (one bad pointer breaks chain)</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Indexed Allocation</strong>
                        <ul>
                            <li>Index block contains pointers to all blocks</li>
                            <li>‚úÖ Direct access supported</li>
                            <li>‚úÖ No external fragmentation</li>
                            <li>‚ùå Overhead of index block</li>
                            <li>‚ùå Wasted space if file is small</li>
                        </ul>
                    </div>
                    
                    <div class="exam-example">
                        <strong>PAST EXAM:</strong> File of 100 blocks. Insert block in middle (as 15th).<br>
                        How many disk I/O operations?<br><br>
                        
                        <strong>Contiguous:</strong> 201 (read 50 blocks + write 50 blocks + write new block)<br>
                        <strong>Linked:</strong> 15 reads + 2 writes = 17<br>
                        <strong>Indexed:</strong> 1 write + 1 update index = 2
                    </div>
                </div>
                
                <div class="section">
                    <h3>üÜì Free Space Management</h3>
                    
                    <div class="key-concept">
                        <strong>1. Bit Vector (Bitmap)</strong>
                        <ul>
                            <li>1 bit per block (0=allocated, 1=free)</li>
                            <li>‚úÖ Simple, efficient to find free blocks</li>
                            <li>‚ùå Must keep entire bitmap in memory</li>
                        </ul>
                        <div class="formula">
                            Bitmap size = (disk_size / block_size) / 8 bytes<br>
                            Example: 1TB disk, 4KB blocks ‚Üí 32MB bitmap
                        </div>
                    </div>
                    
                    <div class="key-concept">
                        <strong>2. Linked List</strong>
                        <ul>
                            <li>Link all free blocks together</li>
                            <li>‚úÖ No waste of space</li>
                            <li>‚ùå Cannot get contiguous space easily</li>
                            <li>‚ùå Traversal requires many I/O</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>3. Grouping</strong>
                        <ul>
                            <li>First free block contains addresses of n free blocks</li>
                            <li>Last of these points to another block with n addresses</li>
                            <li>‚úÖ Can find many free blocks quickly</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>4. Counting</strong>
                        <ul>
                            <li>Store address of first free block + count of contiguous free blocks</li>
                            <li>‚úÖ Efficient if space allocated/freed in large chunks</li>
                        </ul>
                    </div>
                </div>
                
                <div class="section">
                    <h3>üóÑÔ∏è Directory Implementation</h3>
                    
                    <div class="key-concept">
                        <strong>Linear List:</strong>
                        <ul>
                            <li>Simple to implement</li>
                            <li>‚ùå Time-consuming to search (O(n))</li>
                        </ul>
                    </div>
                    
                    <div class="key-concept">
                        <strong>Hash Table:</strong>
                        <ul>
                            <li>Fast lookup (O(1) average)</li>
                            <li>‚ùå Collisions must be handled</li>
                            <li>‚ùå Fixed size (or expensive to resize)</li>
                        </ul>
                    </div>
                </div>
            </div>
            
            <!-- QUICK REFERENCE -->
            <div class="chapter">
                <h2 class="chapter-title">
                    <span class="chapter-number">‚ö°</span>
                    Quick Reference & Formulas
                </h2>
                
                <div class="section">
                    <h3>üìê Essential Formulas</h3>
                    
                    <div class="formula">
                        <strong>Paging:</strong><br>
                        Page Number = Logical Address / Page Size<br>
                        Page Offset = Logical Address % Page Size<br>
                        Physical Address = (Frame Number √ó Frame Size) + Offset<br><br>
                        
                        Logical Address Bits = log‚ÇÇ(Pages √ó Page Size)<br>
                        Physical Address Bits = log‚ÇÇ(Frames √ó Frame Size)
                    </div>
                    
                    <div class="formula">
                        <strong>TLB Effective Access Time:</strong><br>
                        EAT = h √ó (TLB_time + Memory_time) + (1-h) √ó (TLB_time + Page_Table_time + Memory_time)<br>
                        where h = hit ratio
                    </div>
                    
                    <div class="formula">
                        <strong>Page Fault EAT:</strong><br>
                        EAT = (1-p) √ó memory_access + p √ó page_fault_service_time<br>
                        where p = page fault rate
                    </div>
                    
                    <div class="formula">
                        <strong>Scheduling:</strong><br>
                        Turnaround Time = Completion Time - Arrival Time<br>
                        Waiting Time = Turnaround Time - Burst Time<br>
                        Response Time = First Response - Arrival Time
                    </div>
                    
                    <div class="formula">
                        <strong>Disk Access:</strong><br>
                        Access Time = Seek Time + Rotational Latency + Transfer Time
                    </div>
                </div>
                
                <div class="section">
                    <h3>üéØ Quick Tips for Exams</h3>
                    
                    <div class="tip">
                        <strong>Process vs Thread:</strong> Process = heavyweight, separate memory; Thread = lightweight, shared memory
                    </div>
                    
                    <div class="tip">
                        <strong>fork() Returns:</strong> 0 to child, child PID to parent, -1 on error
                    </div>
                    
                    <div class="tip">
                        <strong>Mode Bit:</strong> 0 = Kernel mode, 1 = User mode
                    </div>
                    
                    <div class="tip">
                        <strong>External Fragmentation:</strong> Variable partition, Segmentation<br>
                        <strong>Internal Fragmentation:</strong> Fixed partition, Paging
                    </div>
                    
                    <div class="tip">
                        <strong>Page Size = Frame Size</strong> (always equal!)
                    </div>
                    
                    <div class="tip">
                        <strong>Belady's Anomaly:</strong> Only FIFO suffers (not LRU or Optimal)
                    </div>
                    
                    <div class="tip">
                        <strong>Deadlock Conditions (ALL required):</strong> Mutual Exclusion, Hold & Wait, No Preemption, Circular Wait
                    </div>
                    
                    <div class="tip">
                        <strong>Preemptive Algorithms:</strong> RR, SRTF, Preemptive Priority<br>
                        <strong>Non-Preemptive:</strong> FCFS, SJF, Non-preemptive Priority
                    </div>
                </div>
                
                <div class="section">
                    <h3>üî¢ Common Conversions</h3>
                    
                    <table>
                        <tr>
                            <th>Unit</th>
                            <th>Value</th>
                        </tr>
                        <tr>
                            <td>1 KB</td>
                            <td>1024 bytes = 2^10</td>
                        </tr>
                        <tr>
                            <td>1 MB</td>
                            <td>1024 KB = 2^20 bytes</td>
                        </tr>
                        <tr>
                            <td>1 GB</td>
                            <td>1024 MB = 2^30 bytes</td>
                        </tr>
                        <tr>
                            <td>1 ms</td>
                            <td>1,000 Œºs = 1,000,000 ns</td>
                        </tr>
                        <tr>
                            <td>1 Œºs</td>
                            <td>1,000 ns</td>
                        </tr>
                    </table>
                </div>
                
                <div class="section">
                    <h3>‚úÖ Common Exam Mistakes to Avoid</h3>
                    
                    <div class="exam-example">
                        ‚ùå <strong>Mistake:</strong> Thinking page size ‚â† frame size<br>
                        ‚úÖ <strong>Correct:</strong> Page size ALWAYS equals frame size
                    </div>
                    
                    <div class="exam-example">
                        ‚ùå <strong>Mistake:</strong> fork() returns child PID to child<br>
                        ‚úÖ <strong>Correct:</strong> fork() returns 0 to child, child PID to parent
                    </div>
                    
                    <div class="exam-example">
                        ‚ùå <strong>Mistake:</strong> Threads share stack<br>
                        ‚úÖ <strong>Correct:</strong> Each thread has its own stack; they share code, data, heap
                    </div>
                    
                    <div class="exam-example">
                        ‚ùå <strong>Mistake:</strong> Waiting time includes burst time<br>
                        ‚úÖ <strong>Correct:</strong> Waiting time = Turnaround time - Burst time
                    </div>
                    
                    <div class="exam-example">
                        ‚ùå <strong>Mistake:</strong> Paging causes external fragmentation<br>
                        ‚úÖ <strong>Correct:</strong> Paging eliminates external fragmentation, but causes internal fragmentation
                    </div>
                </div>
                
                <div class="section">
                    <h3>üìù Final Checklist</h3>
                    
                    <div class="key-concept">
                        <strong>Before the exam, make sure you can:</strong>
                        <ul>
                            <li>‚úÖ Calculate page number and offset from logical address</li>
                            <li>‚úÖ Convert logical to physical address using page table</li>
                            <li>‚úÖ Calculate effective access time with TLB</li>
                            <li>‚úÖ Draw Gantt charts for all scheduling algorithms</li>
                            <li>‚úÖ Calculate waiting time and turnaround time</li>
                            <li>‚úÖ Trace fork() execution and count processes created</li>
                            <li>‚úÖ Implement producer-consumer with semaphores</li>
                            <li>‚úÖ Perform page replacement (FIFO, LRU, Optimal)</li>
                            <li>‚úÖ Calculate bits needed for logical/physical addresses</li>
                            <li>‚úÖ Understand difference between process and thread</li>
                            <li>‚úÖ Know when to use each allocation algorithm (First-fit, Best-fit, Worst-fit)</li>
                            <li>‚úÖ Identify deadlock conditions</li>
                            <li>‚úÖ Understand virtual memory benefits and page faults</li>
                        </ul>
                    </div>
                </div>
            </div>
            
        </div>
        
        <footer style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; text-align: center;">
            <h3 style="margin-bottom: 15px;">üéì Study Tips</h3>
            <p style="margin-bottom: 10px;">‚úì Practice past exams multiple times</p>
            <p style="margin-bottom: 10px;">‚úì Draw diagrams for process states, memory layouts, and page tables</p>
            <p style="margin-bottom: 10px;">‚úì Memorize key formulas (EAT, page translation, scheduling metrics)</p>
            <p style="margin-bottom: 10px;">‚úì Understand concepts, don't just memorize</p>
            <p style="margin-bottom: 20px;">‚úì Code fork() examples to understand process creation</p>
            <p style="font-size: 0.9em; opacity: 0.8;">Good luck on your CS330 exam! üöÄ</p>
        </footer>
    </div>
</body>
</html>