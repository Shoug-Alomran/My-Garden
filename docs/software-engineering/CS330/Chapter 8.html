<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 8: Main Memory Management - CS330</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f4f4f4;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
        }

        header {
            background: linear-gradient(135deg, #00c9ff 0%, #92fe9d 100%);
            color: white;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            border-radius: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        h2 {
            color: #00acc1;
            font-size: 1.8em;
            margin: 35px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #00c9ff;
        }

        h3 {
            color: #0097a7;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }

        /* Memory Block Visualization */
        .memory-visual {
            display: flex;
            justify-content: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .memory-block {
            width: 120px;
            height: 150px;
            border: 2px solid #00acc1;
            margin: 10px;
            display: flex;
            flex-direction: column;
            border-radius: 5px;
            overflow: hidden;
        }

        .memory-header {
            background: #00acc1;
            color: white;
            padding: 8px;
            text-align: center;
            font-weight: bold;
        }

        .memory-content {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: #e0f7fa;
        }

        .os-block {
            background: #ff6b6b;
        }

        .process-block {
            background: #4ecdc4;
        }

        .free-block {
            background: #95e77e;
        }

        /* Address Translation Diagram */
        .address-translation {
            background: #f8f9ff;
            border: 2px solid #00c9ff;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
        }

        .address-flow {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .address-box {
            background: white;
            border: 2px solid #00acc1;
            padding: 15px;
            border-radius: 8px;
            min-width: 150px;
            text-align: center;
            margin: 10px;
        }

        .arrow {
            font-size: 30px;
            color: #00acc1;
            margin: 0 10px;
        }

        /* Page Table Visualization */
        .page-table-container {
            display: flex;
            justify-content: space-around;
            align-items: flex-start;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .page-table {
            border: 2px solid #00acc1;
            border-radius: 8px;
            overflow: hidden;
            margin: 10px;
        }

        .page-table-header {
            background: #00acc1;
            color: white;
            padding: 10px;
            text-align: center;
            font-weight: bold;
        }

        .page-entry {
            display: flex;
            border-bottom: 1px solid #ddd;
        }

        .page-entry:last-child {
            border-bottom: none;
        }

        .page-number {
            background: #e0f7fa;
            padding: 10px;
            width: 60px;
            text-align: center;
            border-right: 1px solid #ddd;
        }

        .frame-number {
            padding: 10px;
            flex: 1;
            text-align: center;
        }

        /* Segmentation Table */
        .segment-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .segment-table th {
            background: #00acc1;
            color: white;
            padding: 15px;
            text-align: left;
        }

        .segment-table td {
            padding: 12px 15px;
            border: 1px solid #ddd;
        }

        .segment-table tr:nth-child(even) {
            background: #f0f8ff;
        }

        /* TLB Visualization */
        .tlb-container {
            background: #fff3e0;
            border: 2px solid #ff9800;
            border-radius: 10px;
            padding: 25px;
            margin: 30px 0;
        }

        .tlb-visual {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }

        .tlb-entry {
            background: white;
            border: 1px solid #ff9800;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
        }

        /* Fragmentation Comparison */
        .fragmentation-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .fragmentation-card {
            background: white;
            border: 2px solid #00c9ff;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .fragmentation-card h4 {
            color: #00acc1;
            margin-bottom: 15px;
            font-size: 1.2em;
        }

        .frag-visual {
            display: flex;
            flex-direction: column;
            margin: 10px 0;
        }

        .memory-segment {
            height: 30px;
            margin: 2px 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .allocated {
            background: #4ecdc4;
        }

        .internal-frag {
            background: #ffeb3b;
            color: #333;
        }

        .external-frag {
            background: #ff9800;
        }

        /* Code blocks */
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .code-comment {
            color: #95a5a6;
        }

        .code-keyword {
            color: #3498db;
        }

        /* Concept Box */
        .concept-box {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }

        .info-box {
            background: #f0f8ff;
            border: 2px solid #00acc1;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        /* Allocation Strategies */
        .allocation-strategies {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .strategy-card {
            background: linear-gradient(135deg, #00c9ff15, #92fe9d15);
            border: 2px solid #00acc1;
            border-radius: 10px;
            padding: 20px;
            text-align: center;
            transition: transform 0.3s;
        }

        .strategy-card:hover {
            transform: translateY(-5px);
        }

        .strategy-card h4 {
            color: #00acc1;
            margin-bottom: 10px;
        }

        /* Swapping Visualization */
        .swapping-visual {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 30px 0;
            flex-wrap: wrap;
        }

        .swap-state {
            text-align: center;
            margin: 10px;
        }

        .swap-memory {
            width: 150px;
            height: 200px;
            border: 2px solid #00acc1;
            border-radius: 8px;
            overflow: hidden;
        }

        .swap-disk {
            width: 150px;
            height: 150px;
            border: 2px solid #ff9800;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #fff8e1;
            margin-top: 20px;
        }

        /* Formula Box */
        .formula-box {
            background: #f5f5f5;
            border: 2px solid #00acc1;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
        }

        .formula {
            font-size: 1.2em;
            font-family: 'Courier New', monospace;
            color: #00695c;
            margin: 10px 0;
        }

        /* Example Box */
        .example-box {
            background: #e8f5e9;
            border: 2px solid #4caf50;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        /* Exam Section */
        .exam-section {
            background: #fff8dc;
            border: 2px solid #ffd700;
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .exam-question {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        /* Address Calculation */
        .address-calc {
            background: white;
            border: 2px solid #00acc1;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        .calc-step {
            margin: 10px 0;
            padding: 10px;
            background: #e0f7fa;
            border-left: 3px solid #00acc1;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        th {
            background: #00acc1;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px 15px;
            border: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f0f8ff;
        }

        /* Bits Visualization */
        .bit-visual {
            display: flex;
            margin: 20px 0;
            justify-content: center;
        }

        .bit-segment {
            border: 1px solid #00acc1;
            padding: 10px 20px;
            margin: 0;
            background: white;
        }

        .bit-label {
            text-align: center;
            font-size: 0.9em;
            color: #00695c;
            margin-top: 5px;
        }

        /* Protection Bits */
        .protection-bits {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }

        .bit-flag {
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .read-bit {
            background: #4caf50;
            color: white;
        }

        .write-bit {
            background: #ff9800;
            color: white;
        }

        .execute-bit {
            background: #2196f3;
            color: white;
        }

        /* Image Placeholder */
        .image-placeholder {
            background: #95a5a6;
            color: white;
            padding: 60px 20px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #7f8c8d;
        }

        .highlight {
            background: #ffeb3b;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        /* Responsive */
        @media (max-width: 768px) {
            .memory-visual,
            .page-table-container,
            .fragmentation-grid,
            .allocation-strategies {
                flex-direction: column;
            }
            
            .arrow {
                transform: rotate(90deg);
            }
        }

        footer {
            background: #00acc1;
            color: white;
            text-align: center;
            padding: 25px;
            margin-top: 40px;
            border-radius: 10px;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Chapter 8: Main Memory</h1>
            <p style="font-size: 1.2em;">CS330 - Operating Systems</p>
            <p>Memory Management, Address Binding, Swapping, Paging & Segmentation</p>
        </header>

        <!-- Section 1: Background -->
        <section>
            <h2>8.1 Background</h2>
            
            <div class="concept-box">
                <p>Memory management is crucial for multiprogramming. The OS must:</p>
                <ul style="margin-left: 40px;">
                    <li>Keep track of which parts of memory are currently being used and by whom</li>
                    <li>Decide which processes to load when memory space becomes available</li>
                    <li>Allocate and deallocate memory space as needed</li>
                </ul>
            </div>

            <h3>Basic Hardware</h3>
            <p>Main memory and registers are the only storage CPU can access directly.</p>
            
            <div class="info-box">
                <h4>Memory Access Times:</h4>
                <ul>
                    <li><strong>Register access:</strong> One CPU clock cycle or less</li>
                    <li><strong>Main memory:</strong> Many cycles (causes stalls)</li>
                    <li><strong>Cache:</strong> Sits between main memory and CPU registers</li>
                </ul>
            </div>

            <h3>Memory Protection</h3>
            <div class="address-translation">
                <h4>Base and Limit Registers</h4>
                <div class="address-flow">
                    <div class="address-box">
                        <strong>CPU</strong><br>
                        Generates<br>
                        Logical Address
                    </div>
                    <span class="arrow">‚Üí</span>
                    <div class="address-box">
                        <strong>Check</strong><br>
                        Address ‚â• Base<br>
                        Address < Base+Limit
                    </div>
                    <span class="arrow">‚Üí</span>
                    <div class="address-box">
                        <strong>Memory</strong><br>
                        Physical<br>
                        Address
                    </div>
                </div>
                <p style="text-align: center; margin-top: 20px;">If check fails ‚Üí Trap to OS (addressing error)</p>
            </div>
        </section>

        <!-- Section 2: Address Binding -->
        <section>
            <h2>8.2 Address Binding</h2>
            
            <p>Programs must be brought into memory and placed within a process for execution.</p>
            
            <h3>Binding of Instructions and Data to Memory</h3>
            <table>
                <tr>
                    <th>Binding Time</th>
                    <th>Description</th>
                    <th>Address Type</th>
                    <th>Flexibility</th>
                </tr>
                <tr>
                    <td><strong>Compile Time</strong></td>
                    <td>If memory location known a priori, absolute code can be generated</td>
                    <td>Absolute addresses</td>
                    <td>Must recompile if starting location changes</td>
                </tr>
                <tr>
                    <td><strong>Load Time</strong></td>
                    <td>Compiler generates relocatable code</td>
                    <td>Relocatable addresses</td>
                    <td>Final binding delayed until load time</td>
                </tr>
                <tr>
                    <td><strong>Execution Time</strong></td>
                    <td>Binding delayed until run time</td>
                    <td>Dynamic addresses</td>
                    <td>Process can move during execution</td>
                </tr>
            </table>

            <h3>Logical vs Physical Address Space</h3>
            <div class="concept-box">
                <p><strong>Logical Address:</strong> Generated by CPU; also called <span class="highlight">virtual address</span></p>
                <p><strong>Physical Address:</strong> Address seen by memory unit</p>
                <p>Logical and physical addresses are the same in compile-time and load-time schemes; different in execution-time scheme</p>
            </div>

            <h3>Memory-Management Unit (MMU)</h3>
            <div class="formula-box">
                <h4>Address Translation</h4>
                <p class="formula">Physical Address = Logical Address + Relocation Register</p>
                <p>The user program deals with logical addresses; it never sees real physical addresses</p>
            </div>
        </section>

        <!-- Section 3: Swapping -->
        <section>
            <h2>8.3 Swapping</h2>
            
            <p>A process can be swapped temporarily out of memory to backing store and then brought back for continued execution.</p>
            
            <div class="swapping-visual">
                <div class="swap-state">
                    <h4>Main Memory</h4>
                    <div class="swap-memory">
                        <div class="memory-header os-block">Operating System</div>
                        <div class="memory-content process-block">Process P1</div>
                        <div class="memory-content free-block">Free Space</div>
                    </div>
                </div>
                
                <div style="display: flex; flex-direction: column; align-items: center;">
                    <span class="arrow">‚áÑ</span>
                    <p><strong>Swap Out / Swap In</strong></p>
                </div>
                
                <div class="swap-state">
                    <h4>Backing Store</h4>
                    <div class="swap-disk">
                        <strong>Disk<br>Storage</strong>
                    </div>
                </div>
            </div>

            <div class="warning-box">
                <h4>Swapping Constraints:</h4>
                <ul>
                    <li>Process must be completely idle before swapping</li>
                    <li>Never swap a process with pending I/O</li>
                    <li>Transfer time is proportional to amount of memory swapped</li>
                </ul>
            </div>

            <div class="example-box">
                <h4>Swapping Time Calculation:</h4>
                <p>Process size: 100MB</p>
                <p>Backing store transfer rate: 50MB/sec</p>
                <p>Transfer time = 100MB / 50MB/sec = 2 seconds</p>
                <p>Total swap time (out + in) = 4 seconds</p>
            </div>
        </section>

        <!-- Section 4: Contiguous Memory Allocation -->
        <section>
            <h2>8.4 Contiguous Memory Allocation</h2>
            
            <h3>Memory Allocation</h3>
            <p>Main memory is divided into two partitions:</p>
            <ul style="margin-left: 40px;">
                <li><strong>Resident OS:</strong> Usually in low memory with interrupt vector</li>
                <li><strong>User processes:</strong> In high memory</li>
            </ul>

            <h3>Multiple-Partition Allocation</h3>
            <div class="memory-visual">
                <div class="memory-block">
                    <div class="memory-header os-block">OS</div>
                    <div class="memory-content">0-400K</div>
                </div>
                <div class="memory-block">
                    <div class="memory-header process-block">Process 1</div>
                    <div class="memory-content">400-600K</div>
                </div>
                <div class="memory-block">
                    <div class="memory-header free-block">Free</div>
                    <div class="memory-content">600-900K</div>
                </div>
                <div class="memory-block">
                    <div class="memory-header process-block">Process 2</div>
                    <div class="memory-content">900-1024K</div>
                </div>
            </div>

            <h3>Dynamic Storage-Allocation Strategies</h3>
            <div class="allocation-strategies">
                <div class="strategy-card">
                    <h4>First-Fit</h4>
                    <p>Allocate the <strong>first</strong> hole that is big enough</p>
                    <p>‚úì Fast</p>
                    <p>‚úó May create small fragments</p>
                </div>
                
                <div class="strategy-card">
                    <h4>Best-Fit</h4>
                    <p>Allocate the <strong>smallest</strong> hole that is big enough</p>
                    <p>‚úì Leaves larger holes</p>
                    <p>‚úó Slower, creates tiny fragments</p>
                </div>
                
                <div class="strategy-card">
                    <h4>Worst-Fit</h4>
                    <p>Allocate the <strong>largest</strong> hole</p>
                    <p>‚úì May reduce fragmentation</p>
                    <p>‚úó Poor utilization</p>
                </div>
            </div>

            <div class="info-box">
                <p><strong>Note:</strong> First-fit and best-fit are generally better than worst-fit in terms of speed and storage utilization</p>
            </div>
        </section>

        <!-- Section 5: Fragmentation -->
        <section>
            <h2>8.5 Fragmentation</h2>
            
            <div class="fragmentation-grid">
                <div class="fragmentation-card">
                    <h4>External Fragmentation</h4>
                    <p>Total memory space exists to satisfy request, but it is not contiguous</p>
                    <div class="frag-visual">
                        <div class="memory-segment allocated">Process A</div>
                        <div class="memory-segment external-frag">Free 50K</div>
                        <div class="memory-segment allocated">Process B</div>
                        <div class="memory-segment external-frag">Free 100K</div>
                        <div class="memory-segment allocated">Process C</div>
                    </div>
                    <p><strong>Problem:</strong> Can't allocate 150K even though total free = 150K</p>
                    <p><strong>Solution:</strong> Compaction or Paging</p>
                </div>
                
                <div class="fragmentation-card">
                    <h4>Internal Fragmentation</h4>
                    <p>Allocated memory may be larger than requested memory</p>
                    <div class="frag-visual">
                        <div class="memory-segment allocated">Process Needs 18K</div>
                        <div class="memory-segment internal-frag">Wasted 2K</div>
                    </div>
                    <p><strong>Example:</strong> Process needs 18K, gets 20K block</p>
                    <p><strong>Occurs in:</strong> Fixed partition schemes, Paging</p>
                </div>
            </div>

            <div class="concept-box">
                <h4>50-Percent Rule (Statistical Analysis):</h4>
                <p>Given N allocated blocks, another N/2 blocks will be lost to external fragmentation</p>
                <p>One-third of memory may be unusable!</p>
            </div>
        </section>

        <!-- Section 6: Paging -->
        <section>
            <h2>8.6 Paging</h2>
            
            <div class="concept-box">
                <p><strong>Paging</strong> allows physical address space of a process to be noncontiguous</p>
                <ul style="margin-left: 40px;">
                    <li>Divide physical memory into fixed-sized blocks called <span class="highlight">frames</span></li>
                    <li>Divide logical memory into blocks of same size called <span class="highlight">pages</span></li>
                    <li>Keep track of all free frames</li>
                    <li>Set up a page table to translate logical to physical addresses</li>
                </ul>
            </div>

            <h3>Address Translation</h3>
            <div class="address-translation">
                <h4>Logical Address Structure</h4>
                <div class="bit-visual">
                    <div class="bit-segment" style="background: #e3f2fd;">
                        Page Number (p)
                    </div>
                    <div class="bit-segment" style="background: #fff9c4;">
                        Page Offset (d)
                    </div>
                </div>
                <div style="text-align: center;">
                    <div class="bit-label">Used as index into page table</div>
                    <div class="bit-label">Combined with base address</div>
                </div>
            </div>

            <h3>Page Table Example</h3>
            <div class="page-table-container">
                <div>
                    <h4>Logical Memory</h4>
                    <div class="page-table">
                        <div class="page-table-header">Pages</div>
                        <div class="page-entry">
                            <div class="page-number">0</div>
                            <div class="frame-number">Page 0</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">1</div>
                            <div class="frame-number">Page 1</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">2</div>
                            <div class="frame-number">Page 2</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">3</div>
                            <div class="frame-number">Page 3</div>
                        </div>
                    </div>
                </div>

                <div>
                    <h4>Page Table</h4>
                    <div class="page-table">
                        <div class="page-table-header">Page ‚Üí Frame</div>
                        <div class="page-entry">
                            <div class="page-number">0</div>
                            <div class="frame-number">5</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">1</div>
                            <div class="frame-number">6</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">2</div>
                            <div class="frame-number">1</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">3</div>
                            <div class="frame-number">2</div>
                        </div>
                    </div>
                </div>

                <div>
                    <h4>Physical Memory</h4>
                    <div class="page-table">
                        <div class="page-table-header">Frames</div>
                        <div class="page-entry">
                            <div class="page-number">0</div>
                            <div class="frame-number">Free</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">1</div>
                            <div class="frame-number">Page 2</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">2</div>
                            <div class="frame-number">Page 3</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">3</div>
                            <div class="frame-number">Free</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">4</div>
                            <div class="frame-number">Free</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">5</div>
                            <div class="frame-number">Page 0</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">6</div>
                            <div class="frame-number">Page 1</div>
                        </div>
                        <div class="page-entry">
                            <div class="page-number">7</div>
                            <div class="frame-number">Free</div>
                        </div>
                    </div>
                </div>
            </div>

            <h3>Translation Look-aside Buffer (TLB)</h3>
            <div class="tlb-container">
                <h4>TLB - Hardware Cache for Page Table</h4>
                <p>Small, fast-lookup hardware cache containing page-table entries</p>
                
                <div class="tlb-visual">
                    <div class="tlb-entry">
                        <strong>TLB Hit</strong><br>
                        Page found in TLB<br>
                        ~1 memory access
                    </div>
                    <div class="tlb-entry">
                        <strong>TLB Miss</strong><br>
                        Access page table<br>
                        ~2 memory accesses
                    </div>
                    <div class="tlb-entry">
                        <strong>Hit Ratio</strong><br>
                        Typically 98-99%<br>
                        Critical for performance
                    </div>
                </div>
            </div>

            <h3>Effective Access Time Calculation</h3>
            <div class="formula-box">
                <h4>EAT with TLB</h4>
                <p class="formula">EAT = Œ± √ó (TLB_access + Memory_access) + (1-Œ±) √ó (TLB_access + 2√óMemory_access)</p>
                <p>Where Œ± = TLB hit ratio</p>
                
                <div class="example-box" style="background: white; margin-top: 20px;">
                    <p><strong>Example:</strong> Memory access = 100ns, TLB access = 20ns, Hit ratio = 80%</p>
                    <p>EAT = 0.80 √ó 120 + 0.20 √ó 220 = 96 + 44 = 140ns</p>
                </div>
            </div>

            <h3>Page Table Structure</h3>
            <table>
                <tr>
                    <th>Structure Type</th>
                    <th>Description</th>
                    <th>Advantage</th>
                </tr>
                <tr>
                    <td><strong>Hierarchical</strong></td>
                    <td>Two or more levels of page tables</td>
                    <td>Reduces memory overhead for sparse address spaces</td>
                </tr>
                <tr>
                    <td><strong>Hashed</strong></td>
                    <td>Hash table with linked list for collisions</td>
                    <td>Good for sparse address spaces > 32 bits</td>
                </tr>
                <tr>
                    <td><strong>Inverted</strong></td>
                    <td>One entry per physical frame</td>
                    <td>Decreases memory needed for page tables</td>
                </tr>
            </table>

            <h3>Page Protection</h3>
            <div class="concept-box">
                <h4>Protection Bits in Page Table Entry:</h4>
                <div class="protection-bits">
                    <span class="bit-flag read-bit">R - Read</span>
                    <span class="bit-flag write-bit">W - Write</span>
                    <span class="bit-flag execute-bit">X - Execute</span>
                </div>
                <p><strong>Valid/Invalid Bit:</strong> Indicates if page is in process's logical address space</p>
            </div>
        </section>

        <!-- Section 7: Segmentation -->
        <section>
            <h2>8.7 Segmentation</h2>
            
            <p>Memory-management scheme that supports user view of memory</p>
            
            <div class="concept-box">
                <p>A program is a collection of segments:</p>
                <ul style="margin-left: 40px;">
                    <li>Main program</li>
                    <li>Procedures/Functions</li>
                    <li>Local variables, global variables</li>
                    <li>Common block</li>
                    <li>Stack</li>
                    <li>Symbol table</li>
                </ul>
            </div>

            <h3>Logical Address in Segmentation</h3>
            <div class="bit-visual">
                <div class="bit-segment" style="background: #e8f5e9;">
                    Segment Number (s)
                </div>
                <div class="bit-segment" style="background: #fce4ec;">
                    Offset (d)
                </div>
            </div>

            <h3>Segment Table</h3>
            <table class="segment-table">
                <tr>
                    <th>Segment</th>
                    <th>Base</th>
                    <th>Limit</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>0</td>
                    <td>1400</td>
                    <td>1000</td>
                    <td>Main Program</td>
                </tr>
                <tr>
                    <td>1</td>
                    <td>6300</td>
                    <td>400</td>
                    <td>Subroutine</td>
                </tr>
                <tr>
                    <td>2</td>
                    <td>4300</td>
                    <td>400</td>
                    <td>Stack</td>
                </tr>
                <tr>
                    <td>3</td>
                    <td>3200</td>
                    <td>1100</td>
                    <td>Data Segment</td>
                </tr>
                <tr>
                    <td>4</td>
                    <td>4700</td>
                    <td>1000</td>
                    <td>Symbol Table</td>
                </tr>
            </table>

            <h3>Address Translation in Segmentation</h3>
            <div class="address-calc">
                <h4>Example: Logical Address (2, 53)</h4>
                <div class="calc-step">
                    Step 1: Look up segment 2 in segment table
                </div>
                <div class="calc-step">
                    Step 2: Base = 4300, Limit = 400
                </div>
                <div class="calc-step">
                    Step 3: Check if offset < limit: 53 < 400 ‚úì
                </div>
                <div class="calc-step">
                    Step 4: Physical address = Base + Offset = 4300 + 53 = 4353
                </div>
            </div>

            <h3>Segmentation vs Paging</h3>
            <table>
                <tr>
                    <th>Aspect</th>
                    <th>Paging</th>
                    <th>Segmentation</th>
                </tr>
                <tr>
                    <td>Division</td>
                    <td>Fixed-size pages</td>
                    <td>Variable-size segments</td>
                </tr>
                <tr>
                    <td>User View</td>
                    <td>Invisible to programmer</td>
                    <td>Visible to programmer</td>
                </tr>
                <tr>
                    <td>External Fragmentation</td>
                    <td>No</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>Internal Fragmentation</td>
                    <td>Yes (last page)</td>
                    <td>No</td>
                </tr>
                <tr>
                    <td>Sharing</td>
                    <td>Difficult</td>
                    <td>Easy (logical units)</td>
                </tr>
                <tr>
                    <td>Protection</td>
                    <td>Page level</td>
                    <td>Segment level</td>
                </tr>
            </table>
        </section>

        <!-- Section 8: Segmentation with Paging -->
        <section>
            <h2>8.8 Segmentation with Paging</h2>
            
            <div class="concept-box">
                <p>Combines advantages of both schemes:</p>
                <ul style="margin-left: 40px;">
                    <li>Segment the user view</li>
                    <li>Page the segments for memory management</li>
                    <li>Eliminates external fragmentation</li>
                    <li>Provides sharing and protection at segment level</li>
                </ul>
            </div>

            <h3>Address Translation Steps</h3>
            <div class="address-flow">
                <div class="address-box">
                    <strong>Logical Address</strong><br>
                    (s, p, d)<br>
                    segment, page, offset
                </div>
                <span class="arrow">‚Üí</span>
                <div class="address-box">
                    <strong>Segment Table</strong><br>
                    Get page table<br>
                    for segment s
                </div>
                <span class="arrow">‚Üí</span>
                <div class="address-box">
                    <strong>Page Table</strong><br>
                    Get frame<br>
                    for page p
                </div>
                <span class="arrow">‚Üí</span>
                <div class="address-box">
                    <strong>Physical Address</strong><br>
                    Frame + offset d
                </div>
            </div>

            <div class="warning-box">
                <h4>Intel x86 Architecture Example:</h4>
                <p>Supports both segmentation and paging</p>
                <p>Logical address ‚Üí Linear address (via segmentation) ‚Üí Physical address (via paging)</p>
            </div>
        </section>

        <!-- Section 9: Practice Problems -->
        <section>
            <h2>8.9 Practice Problems and Calculations</h2>
            
            <div class="example-box">
                <h4>Example 1: Page Number and Offset Calculation</h4>
                <p><strong>Given:</strong> Page size = 1KB (1024 bytes), Logical address = 3085</p>
                
                <div class="address-calc">
                    <div class="calc-step">
                        Page number = ‚åä3085 / 1024‚åã = 3
                    </div>
                    <div class="calc-step">
                        Offset = 3085 mod 1024 = 3085 - (3 √ó 1024) = 13
                    </div>
                    <div class="calc-step">
                        <strong>Answer:</strong> Page = 3, Offset = 13
                    </div>
                </div>
            </div>

            <div class="example-box">
                <h4>Example 2: Address Space Calculation</h4>
                <p><strong>Given:</strong> 256 pages with 4KB page size, mapped to 64 frames</p>
                
                <div class="address-calc">
                    <div class="calc-step">
                        Logical address space = 256 √ó 4KB = 1MB = 2¬≤‚Å∞ bytes
                    </div>
                    <div class="calc-step">
                        Logical address bits = log‚ÇÇ(2¬≤‚Å∞) = 20 bits
                    </div>
                    <div class="calc-step">
                        Physical memory = 64 √ó 4KB = 256KB = 2¬π‚Å∏ bytes
                    </div>
                    <div class="calc-step">
                        Physical address bits = log‚ÇÇ(2¬π‚Å∏) = 18 bits
                    </div>
                </div>
            </div>

            <div class="example-box">
                <h4>Example 3: Internal Fragmentation</h4>
                <p><strong>Given:</strong> Process size = 72,766 bytes, Page size = 2048 bytes</p>
                
                <div class="address-calc">
                    <div class="calc-step">
                        Number of pages = ‚åà72,766 / 2048‚åâ = ‚åà35.53‚åâ = 36 pages
                    </div>
                    <div class="calc-step">
                        Memory allocated = 36 √ó 2048 = 73,728 bytes
                    </div>
                    <div class="calc-step">
                        Internal fragmentation = 73,728 - 72,766 = 962 bytes
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 10: Exam Questions -->
        <section>
            <h2>8.10 CS330 Exam Practice</h2>
            
            <div class="exam-section">
                <h3>Multiple Choice Questions</h3>
                
                <div class="exam-question">
                    <p><strong>Q1.</strong> Which memory allocation strategy is generally fastest?</p>
                    <p><strong>Answer:</strong> First-fit (searches from beginning and allocates first suitable hole)</p>
                </div>

                <div class="exam-question">
                    <p><strong>Q2.</strong> External fragmentation occurs in:</p>
                    <p><strong>Answer:</strong> Variable-size contiguous allocation and pure segmentation</p>
                </div>

                <div class="exam-question">
                    <p><strong>Q3.</strong> Internal fragmentation occurs in:</p>
                    <p><strong>Answer:</strong> Fixed-size partitioning and pure paging</p>
                </div>

                <div class="exam-question">
                    <p><strong>Q4.</strong> TLB stands for:</p>
                    <p><strong>Answer:</strong> Translation Look-aside Buffer</p>
                </div>

                <h3>Short Answer Questions</h3>
                
                <div class="exam-question">
                    <p><strong>Q5.</strong> Compare paging and segmentation with respect to memory overhead.</p>
                    <div class="concept-box">
                        <p><strong>Answer:</strong></p>
                        <p><strong>Paging:</strong> Requires one entry per page. For large address spaces, page tables can be huge.</p>
                        <p><strong>Segmentation:</strong> Requires only two registers per segment (base and limit). Much less overhead.</p>
                    </div>
                </div>

                <div class="exam-question">
                    <p><strong>Q6.</strong> Why do mobile operating systems like iOS and Android not support swapping?</p>
                    <div class="concept-box">
                        <p><strong>Answer:</strong></p>
                        <ol>
                            <li>Flash memory has limited write cycles</li>
                            <li>Limited storage capacity</li>
                            <li>Poor memory throughput between flash and main memory</li>
                            <li>Power consumption concerns</li>
                        </ol>
                    </div>
                </div>

                <div class="exam-question">
                    <p><strong>Q7.</strong> Calculate physical address for logical address (1, 500) in paging system:</p>
                    <p>Page size = 1024 bytes, Page 1 mapped to Frame 6</p>
                    <div class="address-calc">
                        <div class="calc-step">
                            Physical address = Frame √ó Page_size + Offset
                        </div>
                        <div class="calc-step">
                            Physical address = 6 √ó 1024 + 500 = 6144 + 500 = 6644
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 11: Key Terms -->
        <section>
            <h2>8.11 Key Terms and Definitions</h2>
            
            <table>
                <tr>
                    <th>Term</th>
                    <th>Definition</th>
                </tr>
                <tr>
                    <td><strong>Logical Address</strong></td>
                    <td>Address generated by CPU; virtual address</td>
                </tr>
                <tr>
                    <td><strong>Physical Address</strong></td>
                    <td>Address seen by memory unit</td>
                </tr>
                <tr>
                    <td><strong>MMU</strong></td>
                    <td>Memory Management Unit - hardware for address translation</td>
                </tr>
                <tr>
                    <td><strong>Page</strong></td>
                    <td>Fixed-size block in logical memory</td>
                </tr>
                <tr>
                    <td><strong>Frame</strong></td>
                    <td>Fixed-size block in physical memory</td>
                </tr>
                <tr>
                    <td><strong>Page Table</strong></td>
                    <td>Data structure for page-to-frame mapping</td>
                </tr>
                <tr>
                    <td><strong>TLB</strong></td>
                    <td>Translation Look-aside Buffer - cache for page table</td>
                </tr>
                <tr>
                    <td><strong>Segment</strong></td>
                    <td>Logical unit in user's view (code, data, stack)</td>
                </tr>
                <tr>
                    <td><strong>External Fragmentation</strong></td>
                    <td>Free memory exists but not contiguous</td>
                </tr>
                <tr>
                    <td><strong>Internal Fragmentation</strong></td>
                    <td>Allocated memory larger than needed</td>
                </tr>
                <tr>
                    <td><strong>Compaction</strong></td>
                    <td>Shuffle memory to place free memory together</td>
                </tr>
                <tr>
                    <td><strong>Swapping</strong></td>
                    <td>Move process between main memory and disk</td>
                </tr>
                <tr>
                    <td><strong>Base Register</strong></td>
                    <td>Holds smallest legal physical address</td>
                </tr>
                <tr>
                    <td><strong>Limit Register</strong></td>
                    <td>Contains range of logical addresses</td>
                </tr>
            </table>
        </section>

        <!-- Image Placeholders -->
        <section>
            <h2>8.12 Diagrams from Slides</h2>
            
            <div class="image-placeholder">
                <h4>üìä Hardware Address Protection Diagram</h4>
                <p>[Insert base and limit register protection diagram]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Paging Hardware with TLB</h4>
                <p>[Insert TLB and page table interaction diagram]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Memory Allocation Examples</h4>
                <p>[Insert first-fit, best-fit, worst-fit visual comparison]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Segmentation Example</h4>
                <p>[Insert logical to physical address mapping in segmentation]</p>
            </div>

            <div class="warning-box">
                <p><strong>Note:</strong> Please provide the actual diagrams from your course materials to replace these placeholders.</p>
            </div>
        </section>

        <footer>
            <p>CS330 - Operating Systems</p>
            <p>Chapter 8: Main Memory Management</p>
            <p><strong>Created by: Shoug Alomran</strong></p>
        </footer>
    </div>
</body>
</html>