<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Software Design - Chapter 6</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 60px 40px;
            text-align: center;
        }

        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        nav {
            background: #34495e;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        nav ul {
            list-style: none;
            display: flex;
            justify-content: center;
            flex-wrap: wrap;
        }

        nav ul li {
            margin: 5px 15px;
        }

        nav ul li a {
            color: white;
            text-decoration: none;
            padding: 8px 16px;
            border-radius: 5px;
            transition: all 0.3s ease;
            display: block;
        }

        nav ul li a:hover {
            background: #667eea;
            transform: translateY(-2px);
        }

        .content {
            padding: 40px;
        }

        section {
            margin-bottom: 50px;
            animation: fadeIn 0.6s ease-in;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        h2 {
            color: #2c3e50;
            font-size: 2.2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #34495e;
            font-size: 1.6em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.3em;
            margin: 20px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
        }

        .quote {
            background: #f8f9fa;
            border-left: 5px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            font-style: italic;
            border-radius: 5px;
        }

        .highlight-box {
            background: linear-gradient(135deg, #667eea15 0%, #764ba215 100%);
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px solid #667eea30;
        }

        .principles-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 25px 0;
        }

        .principle-card {
            background: white;
            border: 2px solid #667eea;
            border-radius: 10px;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .principle-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 25px rgba(102, 126, 234, 0.3);
        }

        .principle-card h4 {
            color: #667eea;
            margin-top: 0;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin-bottom: 10px;
        }

        .architecture-pattern {
            background: #f8f9fa;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 5px solid #764ba2;
        }

        .architecture-pattern h4 {
            color: #764ba2;
            margin-top: 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .info-box {
            background: #e3f2fd;
            border-left: 5px solid #2196F3;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .warning-box {
            background: #fff3e0;
            border-left: 5px solid #ff9800;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .success-box {
            background: #e8f5e9;
            border-left: 5px solid #4caf50;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }

        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 30px;
            margin-top: 40px;
        }

        .back-to-top {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: #667eea;
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            text-decoration: none;
            font-size: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .back-to-top:hover {
            background: #764ba2;
            transform: translateY(-5px);
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }

            h2 {
                font-size: 1.8em;
            }

            nav ul {
                flex-direction: column;
                align-items: center;
            }

            nav ul li {
                margin: 5px 0;
            }
        }

        .diagram-placeholder {
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 40px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #667eea;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Software Design</h1>
            <p>Chapter 6 - Comprehensive Guide to Software Engineering Design Principles</p>
        </header>

        <nav>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#purpose">Purpose</a></li>
                <li><a href="#principles">Design Principles</a></li>
                <li><a href="#concepts">Fundamental Concepts</a></li>
                <li><a href="#architecture">Architecture</a></li>
                <li><a href="#patterns">Design Patterns</a></li>
                <li><a href="#interface">Interface Design</a></li>
            </ul>
        </nav>

        <div class="content">
            <section id="introduction">
                <h2>Introduction to Software Design</h2>
                
                <div class="quote">
                    <p><strong>Mitch Kapor, creator of Lotus 1-2-3, presented a "software design manifesto" stating that good software design should exhibit:</strong></p>
                    <ul>
                        <li><strong>Firmness:</strong> A program should not have any bugs that inhibit its function.</li>
                        <li><strong>Commodity:</strong> A program should be suitable for the purposes for which it was intended.</li>
                        <li><strong>Delight:</strong> The experience of using the program should be pleasurable.</li>
                    </ul>
                </div>

                <p>Software design encompasses the set of principles, concepts, and practices that lead to the development of a high-quality system or product. These practices change continuously as new methods, better analysis, and broader understanding evolve.</p>

                <div class="highlight-box">
                    <h3>What is Software Design?</h3>
                    <p>Software design is where customer requirements, business needs, and technical considerations all come together in the formulation of a product or system. The design model provides detail about software data structures, architecture, interfaces, and components.</p>
                </div>
            </section>

            <section id="purpose">
                <h2>Purpose of Design</h2>
                
                <p>The design model can be assessed for quality and improved before code is generated and tests are conducted. Key questions to consider:</p>

                <ul>
                    <li>Does the design contain errors, inconsistencies, or omissions?</li>
                    <li>Are there better design alternatives?</li>
                    <li>Can the design be implemented within the constraints, schedule, and cost that have been established?</li>
                </ul>

                <h3>From Analysis Model to Design Model</h3>

                <div class="principles-grid">
                    <div class="principle-card">
                        <h4>Data/Class Design</h4>
                        <p>Transforms analysis classes into design classes/implementation classes along with the data structures required to implement the software.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Architectural Design</h4>
                        <p>Defines the relationship between major structural elements of the software; architectural styles and design patterns help achieve the requirements.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Interface Design</h4>
                        <p>Defines how software elements, hardware elements, and end-users communicate.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Component-Level Design</h4>
                        <p>Transforms structural elements of the software architecture into a procedural description of software components.</p>
                    </div>
                </div>
            </section>

            <section id="quality">
                <h2>Design and Quality</h2>

                <div class="success-box">
                    <h3>Quality Characteristics</h3>
                    <p>A high-quality design should:</p>
                    <ul>
                        <li>Implement all explicit requirements contained in the analysis model and accommodate all implicit requirements desired by the customer</li>
                        <li>Be a readable, understandable guide for code generation and testing</li>
                        <li>Provide a complete picture of the software, addressing data, functional, and behavioral domains</li>
                    </ul>
                </div>

                <h3>Quality Guidelines</h3>

                <ol>
                    <li><strong>Architectural Excellence:</strong> Design should exhibit an architecture created using recognizable styles/patterns, composed of components with good design characteristics, implementable in an evolutionary fashion</li>
                    
                    <li><strong>Modularity:</strong> Software should be logically partitioned into elements or subsystems</li>
                    
                    <li><strong>Distinct Representations:</strong> Design should contain distinct representations of data, architecture, interfaces, and components</li>
                    
                    <li><strong>Appropriate Data Structures:</strong> Design should lead to data structures appropriate for classes to be implemented and drawn from recognizable data patterns</li>
                    
                    <li><strong>Independent Functional Characteristics:</strong> Design should lead to components that exhibit independent functional characteristics</li>
                    
                    <li><strong>Reduced Complexity:</strong> Design should lead to interfaces that reduce complexity of connections between components and with the external environment</li>
                    
                    <li><strong>Repeatable Method:</strong> Design should be derived using a repeatable method driven by information from requirements analysis</li>
                    
                    <li><strong>Effective Communication:</strong> Design should be represented using notation that effectively communicates its meaning</li>
                </ol>
            </section>

            <section id="principles">
                <h2>Design Principles</h2>

                <div class="highlight-box">
                    <h3>Core Design Principles</h3>
                    
                    <h4>1. Avoid Tunnel Vision</h4>
                    <p>The design should not suffer from narrow focus. Consider all aspects and implications of design decisions.</p>

                    <h4>2. Traceability</h4>
                    <p>The design should be traceable to the analysis model, ensuring all requirements are addressed.</p>

                    <h4>3. Reusability</h4>
                    <p>The design should not reinvent the wheel. Software components should be designed for effective reuse to increase productivity.</p>

                    <h4>4. Minimize Intellectual Distance</h4>
                    <p>The design should minimize the gap between the software and the real-world problem it solves.</p>

                    <h4>5. Uniformity and Integration</h4>
                    <p>The design should exhibit uniformity and integration across all components.</p>

                    <h4>6. Accommodate Change</h4>
                    <p>The design should be structured to accommodate change gracefully.</p>

                    <h4>7. Graceful Degradation</h4>
                    <p>The design should be structured to degrade gently when aberrant data events or operating conditions are encountered.</p>

                    <h4>8. Separation of Concerns</h4>
                    <p>Design is not coding, coding is not design. Each phase has its distinct purpose.</p>

                    <h4>9. Quality Assessment</h4>
                    <p>The design should be assessed for quality as it is being created, not after the fact.</p>

                    <h4>10. Address Semantic Before Syntactic</h4>
                    <p>The design should be reviewed to minimize conceptual errors (ambiguousness and inconsistency) before dealing with syntactical errors.</p>
                </div>

                <div class="info-box">
                    <h4>Prototyping</h4>
                    <p>Prototyping should be used when requirements are not completely defined at the beginning. The user interacts with the developer to expand and refine requirements as development proceeds. A quick 'mock-up' of the system can be developed to give users a feel of what the system will look like and demonstrate included functions. Prototyping also helps reduce risks of designing software not in accordance with customer requirements.</p>
                </div>

                <div class="warning-box">
                    <p><strong>Important:</strong> Testing should be involved from the initial stages of design.</p>
                </div>
            </section>

            <section id="concepts">
                <h2>Fundamental Concepts</h2>

                <h3>1. Abstraction</h3>
                <p>Abstraction means different levels of description of the design. It's a fundamental concept allowing designers to work at various levels of detail.</p>

                <h3>2. Architecture</h3>
                <p>The overall structure of the software and the ways in which that structure provides conceptual integrity for a system.</p>

                <h3>3. Patterns</h3>
                <p>Patterns convey the essence of proven design solutions. They represent what has already been proven to be the best design solution for a particular problem.</p>

                <h3>4. Refinement</h3>
                <p>Elaboration of detail for all abstractions. This involves breaking down high-level concepts into more detailed implementations.</p>

                <h3>5. Aspect-Oriented Programming (AOP)</h3>
                <div class="highlight-box">
                    <p>An aspect of a program is a feature linked to many other parts of the program but not related to its primary functions. An aspect crosscuts the program's core concerns.</p>
                    <p><strong>Example:</strong> Logging code can crosscut many modules, yet the aspect of logging should be separate from the functional concerns of the module it cross-cuts. Isolating aspects like logging and persistence from business logic is at the core of AOP.</p>
                </div>

                <h3>Best Practices</h3>

                <div class="principles-grid">
                    <div class="principle-card">
                        <h4>Separation of Concerns</h4>
                        <p>Any complex problem can be more easily handled if it is subdivided into pieces.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Modularity</h4>
                        <p>Group highly coupled data and functions into modules (packages or libraries).</p>
                    </div>

                    <div class="principle-card">
                        <h4>Functional Independence</h4>
                        <p>Single-minded function and low coupling between components.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Information Hiding</h4>
                        <p>Controlled interfaces. Don't leave anything open to the external user unnecessarily.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Refactoring</h4>
                        <p>A reorganization technique that simplifies the design without changing functionality.</p>
                    </div>

                    <div class="principle-card">
                        <h4>SOLID Principles</h4>
                        <p>Single responsibility, Open/Closed, Liskov substitution, Interface segregation, Dependency inversion.</p>
                    </div>
                </div>
            </section>

            <section id="architecture">
                <h2>Software Architecture</h2>

                <div class="quote">
                    <p>"The overall structure of the software and the ways in which that structure provides conceptual integrity for a system."</p>
                </div>

                <p>Software architecture refers to the structure of the system, composed of various program/system components, the attributes (properties) of those components, and the relationships amongst them. The software architecture enables software engineers to analyze the software design efficiently.</p>

                <h3>Key Architectural Aspects</h3>

                <h4>Structural Properties</h4>
                <p>This aspect defines the components of a system (e.g., modules, objects, filters) and the manner in which those components are packaged and interact with one another. For example, objects are packaged to encapsulate both data and the processing that manipulates the data and interact via the invocation of methods.</p>

                <h4>Extra-Functional (Non-Functional) Properties</h4>
                <p>The architectural design description should address how the architecture achieves requirements for:</p>
                <ul>
                    <li>Performance</li>
                    <li>Capacity</li>
                    <li>Reliability</li>
                    <li>Security</li>
                    <li>Adaptability</li>
                    <li>Other system characteristics</li>
                </ul>

                <h4>Families of Related Systems</h4>
                <p>The architectural design should draw upon repeatable patterns commonly encountered in the design of families of similar systems. The design should have the ability to reuse architectural building blocks.</p>

                <h3>Modularity</h3>

                <div class="highlight-box">
                    <p>Software should be divided into separately named and addressable components, called modules, that are integrated to satisfy problem requirements.</p>
                    
                    <p>In software engineering, modularity refers to the extent to which a software/web application is divided into small modules. <strong>Modularity is the most important attribute of software that allows a program to be intellectually manageable.</strong></p>
                </div>

                <div class="diagram-placeholder">
                    <h4>Module Structure</h4>
                    <p>Main Program → Modules → Functions → Module Data</p>
                    <p>Global Data ↔ Main Program</p>
                </div>

                <h3>Information Hiding</h3>

                <div class="success-box">
                    <h4>Why Information Hiding?</h4>
                    <ul>
                        <li>Reduces the likelihood of "side effects"</li>
                        <li>Limits the global impact of local design decisions</li>
                        <li>Emphasizes communication through controlled interfaces</li>
                        <li>Discourages the use of global data</li>
                        <li>Leads to encapsulation—an attribute of high quality design</li>
                        <li>Results in higher quality software</li>
                    </ul>
                </div>

                <p>Modules hide "secrets" including:</p>
                <ul>
                    <li>Algorithms</li>
                    <li>Data structures</li>
                    <li>Details of external interfaces</li>
                    <li>Resource allocation policies</li>
                </ul>

                <h3>Stepwise Refinement</h3>

                <p>Stepwise refinement is a top-down design strategy used for decomposing a system from a high level of abstraction into a more detailed level. A hierarchy is developed by decomposing a macroscopic statement of function step by step until programming language statements are reached.</p>

                <div class="info-box">
                    <p><strong>Process:</strong> You begin with a statement of function defined at a high level of abstraction. The statement describes function or information conceptually but provides no information about internal workings. Then, you provide more and more details as each successive refinement occurs.</p>
                    <p><strong>Note:</strong> Abstraction and refinement are complementary concepts. Refinement helps manage complexity by thinking about low-level details as design progresses.</p>
                </div>

                <h3>Functional Independence</h3>

                <p>Functional independence is achieved by developing modules with "single-minded" function with minimized interaction with other modules. It's a key to good design, and design is the key to software quality.</p>

                <h4>Component independence is assessed using two criteria:</h4>

                <div class="principles-grid">
                    <div class="principle-card">
                        <h4>Cohesion (Intra-Module)</h4>
                        <p>An indication of the relative functional strength of a module. A cohesive module performs a single task, requiring little interaction with other components. A cohesive module should ideally do just one thing.</p>
                        <p><strong>Goal: High Cohesion</strong></p>
                    </div>

                    <div class="principle-card">
                        <h4>Coupling (Inter-Module)</h4>
                        <p>An indication of the relative interdependence among modules. Coupling depends on interface complexity between modules, entry/reference points, and data passed across interfaces.</p>
                        <p><strong>Goal: Low Coupling</strong></p>
                    </div>
                </div>

                <div class="warning-box">
                    <p><strong>Design Goal:</strong> Achieve high cohesion (single-mindedness) with the lowest possible coupling (little interaction with other modules). Simple connectivity among modules results in software that is easier to understand and less prone to a "ripple effect" when errors occur at one location and propagate throughout a system.</p>
                </div>

                <h3>Architectural Abstraction Levels</h3>

                <table>
                    <tr>
                        <th>Level</th>
                        <th>Description</th>
                        <th>Focus</th>
                    </tr>
                    <tr>
                        <td><strong>Architecture in the Small</strong></td>
                        <td>Concerned with the architecture of individual programs</td>
                        <td>How individual programs are decomposed into components</td>
                    </tr>
                    <tr>
                        <td><strong>Architecture in the Large</strong></td>
                        <td>Concerned with complex enterprise systems</td>
                        <td>Systems including other systems, programs, and components distributed over different computers</td>
                    </tr>
                </table>

                <h3>Non-Functional Requirements Dictate Architectural Style</h3>

                <table>
                    <tr>
                        <th>Requirement</th>
                        <th>Architectural Approach</th>
                    </tr>
                    <tr>
                        <td>Performance</td>
                        <td>Localize critical operations and minimize communications. Use large rather than fine-grain components.</td>
                    </tr>
                    <tr>
                        <td>Security</td>
                        <td>Use a layered architecture with critical assets in the inner layers.</td>
                    </tr>
                    <tr>
                        <td>Safety</td>
                        <td>Localize safety-critical features in a small number of sub-systems.</td>
                    </tr>
                    <tr>
                        <td>Availability</td>
                        <td>Include redundant components and mechanisms for fault tolerance.</td>
                    </tr>
                    <tr>
                        <td>Maintainability</td>
                        <td>Use fine-grain, replaceable components.</td>
                    </tr>
                </table>
            </section>

            <section id="patterns">
                <h2>Architectural Patterns</h2>

                <p>Patterns are a means of representing, sharing, and reusing knowledge. An architectural pattern is a stylized description of good design practice that has been tried and tested in different environments.</p>

                <div class="info-box">
                    <p>Patterns should include information about when they are and when they are not useful. Patterns may be represented using tabular and graphical descriptions.</p>
                </div>

                <h3>Model-View-Controller (MVC) Pattern</h3>

                <div class="architecture-pattern">
                    <h4>Description</h4>
                    <p>Separates presentation and interaction from the system data. The system is structured into three logical components that interact with each other:</p>
                    
                    <ul>
                        <li><strong>Model:</strong> Manages the system data and associated operations on that data</li>
                        <li><strong>View:</strong> Defines and manages how the data is presented to the user</li>
                        <li><strong>Controller:</strong> Manages user interaction (e.g., key presses, mouse clicks) and passes these interactions to the View and the Model</li>
                    </ul>

                    <h4>When Used</h4>
                    <p>Used when there are multiple ways to view and interact with data. Also used when future requirements for interaction and presentation of data are unknown.</p>

                    <h4>Advantages</h4>
                    <ul>
                        <li>Allows the data to change independently of its representation and vice versa</li>
                        <li>Supports presentation of the same data in different ways</li>
                        <li>Changes made in one representation shown in all of them</li>
                    </ul>

                    <h4>Disadvantages</h4>
                    <p>Can involve additional code and code complexity when the data model and interactions are simple.</p>
                </div>

                <div class="diagram-placeholder">
                    <h4>MVC Architecture</h4>
                    <p>User → sees → View</p>
                    <p>User → uses → Controller</p>
                    <p>Controller → manipulates → Model</p>
                    <p>Model → updates → View</p>
                    <p>Database ↔ Model</p>
                </div>

                <div class="success-box">
                    <p><strong>Key Principle:</strong> MVC is an example of Separation of Concerns, which is fundamental to good software design.</p>
                </div>

                <h3>Layered Architecture</h3>

                <div class="architecture-pattern">
                    <h4>Description</h4>
                    <p>Used to model the interfacing of sub-systems. Organizes the system into a set of layers (or abstract machines), each of which provides a set of services.</p>

                    <h4>Advantages</h4>
                    <ul>
                        <li>Supports incremental development of sub-systems in different layers</li>
                        <li>When a layer interface changes, only the adjacent layer is affected</li>
                        <li>Provides clear separation of concerns</li>
                    </ul>

                    <h4>Typical Layers (Top to Bottom)</h4>
                    <ol>
                        <li><strong>User Interface</strong> - Presentation layer (HTML5, JavaScript, CSS)</li>
                        <li><strong>User Interface Management / Authentication and Authorization</strong></li>
                        <li><strong>Core Business Logic / Application Functionality / System Utilities</strong> - Application layer (Java, .NET, C#, Python, C++)</li>
                        <li><strong>System Support (OS, Database, etc.)</strong> - Data layer (MySQL, Oracle, PostgreSQL, SQL Server, MongoDB)</li>
                    </ol>
                </div>

                <h3>Client-Server Architecture</h3>

                <h4>Two-Tier Architecture</h4>

                <div class="principles-grid">
                    <div class="principle-card">
                        <h4>Thin Client</h4>
                        <p>Client has only the presentation layer (user interface programs), while Application (business logic) and Data layer reside in the server. Most data processing takes place in the server. Virtual Desktops are hosted in data centers.</p>
                    </div>

                    <div class="principle-card">
                        <h4>Fat Client</h4>
                        <p>Client has both the presentation layer and Application layer, while Data layer resides in the server. Most resources are locally installed.</p>
                    </div>
                </div>

                <h3>Data-Centered/Repository Architecture</h3>

                <div class="architecture-pattern">
                    <h4>Characteristics</h4>
                    <p>The data resides at a central place in the architecture and is accessed frequently by other components that update, add, delete, or modify the data within the store.</p>

                    <h4>Focus</h4>
                    <p>How to place data so everyone can access it frequently.</p>

                    <h4>Example</h4>
                    <p>An organization's data is placed on the server and all employees access it (cloud data).</p>

                    <h4>Usage</h4>
                    <ul>
                        <li>This type of design supports many web service architectures (Microsoft .NET, Java 2 Enterprise Edition)</li>
                        <li>Used by Siebel and Oracle</li>
                        <li>When a central issue is storage, representation, management, and retrieval of large amounts of related persistent data</li>
                    </ul>

                    <h4>Key Benefits</h4>
                    <ul>
                        <li>Goal of integrating data</li>
                        <li>Clients are relatively independent of each other (can be added, removed, or changed)</li>
                        <li>Data store is independent of clients</li>
                    </ul>
                </div>

                <div class="info-box">
                    <p><strong>Note:</strong> When large amounts of data are to be shared, the repository model is most commonly used as it is an efficient data sharing mechanism. Sub-systems must exchange data through either a shared central database or by maintaining separate databases and passing data explicitly.</p>
                </div>

                <h3>Data Flow/Pipe & Filter Architecture</h3>

                <div class="architecture-pattern">
                    <h4>Focus</h4>
                    <p>How data is flowing in the system. Applied when input data is converted through a series of manipulative components into output data.</p>

                    <h4>Components</h4>
                    <p>A pipe-and-filter pattern has a set of components, called <strong>filters</strong>, connected by <strong>pipes</strong> that transmit data from one component to the next.</p>

                    <h4>Filter Characteristics</h4>
                    <ul>
                        <li>Each filter works independently of components upstream and downstream</li>
                        <li>Designed to expect data input of a certain form</li>
                        <li>Produces data output of a specified form</li>
                        <li>Does not require knowledge of neighboring filters' workings</li>
                    </ul>

                    <h4>Batch Sequential</h4>
                    <p>If the data flow degenerates into a single line of transforms, it is termed batch sequential. This structure accepts a batch of data and applies a series of sequential components (filters) to transform it.</p>
                </div>

                <div class="diagram-placeholder">
                    <h4>Pipe and Filter Architecture</h4>
                    <p>Input → Filter → Pipe → Filter → Pipe → Filter → Output</p>
                    <p>(Multiple parallel paths possible with filters connected via pipes)</p>
                </div>
            </section>

            <section id="interface">
                <h2>Interface Design</h2>

                <div class="quote">
                    <p>A user interface should be: Easy to learn, Easy to use, Easy to understand, Responsive in short time, and Attractive.</p>
                </div>

                <h3>What is Interface Design?</h3>

                <p>User Interface is the front-end application with which users interact to use software functionalities. Users can manipulate and control software and hardware through the user interface. We find user interfaces in all digital technologies: computers, mobiles, cars, music players, etc.</p>

                <h4>Categories of UI</h4>
                <ul>
                    <li><strong>Command Line Interface (CLI)</strong></li>
                    <li><strong>Graphical User Interface (GUI)</strong></li>
                </ul>

                <h3>Design Issues</h3>

                <div class="principles-grid">
                    <div class="principle-card">
                        <h4>Response Time</h4>
                        <p>System should respond promptly to user actions</p>
                    </div>

                    <div class="principle-card">
                        <h4>Help Facilities</h4>
                        <p>Provide adequate help and documentation</p>
                    </div>

                    <div class="principle-card">
                        <h4>Error Handling</h4>
                        <p>Gracefully handle and communicate errors</p>
                    </div>

                    <div class="principle-card">
                        <h4>Menu and Command Labeling</h4>
                        <p>Use clear, consistent labeling</p>
                    </div>

                    <div class="principle-card">
                        <h4>Application Accessibility</h4>
                        <p>Ensure all users can access features</p>
                    </div>

                    <div class="principle-card">
                        <h4>Internationalization</h4>
                        <p>Support multiple languages and regions</p>
                    </div>
                </div>

                <h3>Golden Rules of Interface Design</h3>

                <div class="highlight-box">
                    <h4>1. Place the User in Control</h4>
                    <ul>
                        <li>Define interaction so users are not forced into performing unnecessary actions</li>
                        <li>Provide friendly user interaction</li>
                        <li>Hide technical internals from casual users</li>
                    </ul>

                    <h4>2. Reduce the User's Memory Load</h4>
                    <ul>
                        <li>Reduce demands on short-term memory</li>
                        <li>Establish meaningful defaults</li>
                        <li>Define shortcuts for experienced users</li>
                    </ul>

                    <h4>3. Make the Interface Consistent</h4>
                    <ul>
                        <li>Maintain consistency across a family of applications</li>
                        <li>If past interactive models have created user expectations, do not make changes unless there is a compelling reason</li>
                    </ul>
                </div>

                <h3>Typical Design Errors to Avoid</h3>

                <div class="warning-box">
                    <ul>
                        <li>Lack of consistency</li>
                        <li>Too much memorization required</li>
                        <li>No guidance or help</li>
                        <li>No context sensitivity</li>
                        <li>Poor response time</li>
                        <li>Unclear or unfriendly messages</li>
                    </ul>
                </div>

                <h3>Interface Analysis</h3>

                <p>A key principle of all software engineering process models is: <strong>understand the problem before you attempt to design a solution.</strong></p>

                <p>Interface analysis means understanding:</p>
                <ol>
                    <li>The people (end-users) who will interact with the system through the interface</li>
                    <li>The tasks that end-users must perform to do their work</li>
                    <li>The content that is presented as part of the interface</li>
                    <li>The environment in which these tasks will be conducted</li>
                </ol>

                <h3>WebApp Interface Design</h3>

                <p>A WebApp interface should answer three primary questions for the end user:</p>

                <div class="principles-grid">
                    <div class="principle-card">
                        <h4>Where am I?</h4>
                        <p>The interface should:</p>
                        <ul>
                            <li>Provide an indication of the WebApp accessed</li>
                            <li>Inform the user of location in the content hierarchy</li>
                        </ul>
                    </div>

                    <div class="principle-card">
                        <h4>What can I do now?</h4>
                        <p>The interface should help users understand:</p>
                        <ul>
                            <li>What functions are available? (e.g., sub menu)</li>
                            <li>What links are live? (enabled or disabled)</li>
                            <li>What content is relevant?</li>
                        </ul>
                    </div>

                    <div class="principle-card">
                        <h4>Where have I been, where am I going?</h4>
                        <p>The interface must facilitate navigation:</p>
                        <ul>
                            <li>Provide a "map" showing where the user has been</li>
                            <li>Show paths to move elsewhere within the WebApp</li>
                        </ul>
                    </div>
                </div>

                <h3>Characteristics of Effective WebApp Interfaces</h3>

                <div class="success-box">
                    <p><strong>Bruce Tognozzi suggests:</strong></p>
                    
                    <ul>
                        <li>Effective interfaces are visually apparent and forgiving, instilling in users a sense of control</li>
                        <li>Effective interfaces do not concern users with the inner workings of the system. Work is carefully and continuously saved, with full option for users to undo any activity at any time</li>
                        <li>Effective applications and services perform a maximum of work while requiring a minimum of information from users</li>
                    </ul>
                </div>
            </section>

            <section id="summary">
                <h2>Summary and Key Takeaways</h2>

                <div class="highlight-box">
                    <h3>Essential Design Principles</h3>
                    <ul>
                        <li>Good design requires understanding the problem before creating solutions</li>
                        <li>Design should be traceable to requirements and assessed for quality continuously</li>
                        <li>Modularity, abstraction, and information hiding are fundamental concepts</li>
                        <li>Aim for high cohesion and low coupling in component design</li>
                        <li>Use proven architectural patterns and styles appropriate to your requirements</li>
                        <li>Interface design should prioritize user control, reduce memory load, and maintain consistency</li>
                    </ul>
                </div>

                <div class="info-box">
                    <h3>Design Process Step-by-Step</h3>
                    <ol>
                        <li>Examine the information domain model and design appropriate data structures</li>
                        <li>Select an architectural style and design patterns that are appropriate</li>
                        <li>Partition the analysis model into design subsystems</li>
                        <li>Design the subsystem interfaces</li>
                        <li>Allocate analysis classes or functions to each subsystem</li>
                        <li>Create a set of design classes or components</li>
                        <li>Translate each analysis class into a design class</li>
                        <li>Check each design class against design criteria</li>
                        <li>Define methods associated with each design class</li>
                        <li>Evaluate and select design patterns</li>
                        <li>Design required interfaces with external systems</li>
                        <li>Design the user interface</li>
                        <li>Conduct component-level design</li>
                        <li>Specify algorithms and refine component interfaces</li>
                    </ol>
                </div>

                <div class="success-box">
                    <h3>Remember</h3>
                    <p>Software design is an iterative process. The design should be continuously reviewed and refined to ensure it meets quality standards and fulfills all requirements. Testing should be involved from the initial stages, and prototyping should be used when requirements are not completely defined.</p>
                </div>
            </section>
        </div>

        <footer>
            <p>Software Design - Chapter 6</p>
            <p>Comprehensive Guide to Software Engineering Design Principles</p>
            <p style="margin-top: 15px; font-size: 0.9em;">Based on Software Engineering: A Practitioner's Approach, 8/e (McGraw-Hill, 2014)</p>
        </footer>
    </div>

    <a href="#" class="back-to-top">↑</a>

    <script>
        // Smooth scrolling for navigation links
        document.querySelectorAll('nav a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                target.scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });

        // Back to top button
        document.querySelector('.back-to-top').addEventListener('click', function(e) {
            e.preventDefault();
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });

        // Show/hide back to top button based on scroll position
        window.addEventListener('scroll', function() {
            const backToTop = document.querySelector('.back-to-top');
            if (window.pageYOffset > 300) {
                backToTop.style.display = 'flex';
            } else {
                backToTop.style.display = 'none';
            }
        });
    </script>
</body>
</html>