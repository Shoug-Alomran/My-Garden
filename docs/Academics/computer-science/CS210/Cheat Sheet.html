<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>CS210 Final Exam Cheat Sheet ‚Äì Data Structures & Algorithms</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.1em;
        }

        .menu {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            padding: 20px;
            background: #f8f9fa;
            border-bottom: 3px solid #667eea;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .menu-item {
            background: white;
            padding: 10px 18px;
            border-radius: 25px;
            color: #667eea;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid #667eea;
            text-decoration: none;
            font-size: 0.95em;
            white-space: nowrap;
        }

        .menu-item:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102,126,234,0.4);
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
            border-left: 5px solid #667eea;
            scroll-margin-top: 110px;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 1.8em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .section h3 {
            color: #764ba2;
            margin-top: 20px;
            margin-bottom: 12px;
            font-size: 1.25em;
        }

        .section h4 {
            color: #495057;
            margin-top: 15px;
            margin-bottom: 8px;
            font-size: 1.05em;
        }

        .tip {
            background: #e7f3ff;
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .tip::before {
            content: "üí° TIP: ";
            font-weight: bold;
            color: #2196F3;
        }

        .hack {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .hack::before {
            content: "üöÄ HACK: ";
            font-weight: bold;
            color: #ff9800;
        }

        .example {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .example::before {
            content: "üìù EXAM EXAMPLE: ";
            font-weight: bold;
            color: #4caf50;
        }

        .critical {
            background: #ffebee;
            border: 2px solid #f44336;
            padding: 15px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .critical::before {
            content: "‚ö†Ô∏è CRITICAL FOR EXAM: ";
            font-weight: bold;
            color: #f44336;
        }

        .formula {
            background: #ffffff;
            border: 2px solid #667eea;
            padding: 12px;
            margin: 12px 0;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 0.95em;
        }

        .comparison {
            display: grid;
            grid-template-columns: repeat(auto-fit,minmax(260px,1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .comparison > div {
            padding: 15px;
            border-radius: 10px;
        }

        .comparison .left {
            background: #e3f2fd;
            border: 2px solid #2196F3;
        }

        .comparison .right {
            background: #fce4ec;
            border: 2px solid #e91e63;
        }

        .diagram {
            background: white;
            padding: 18px;
            margin: 18px 0;
            border: 2px dashed #667eea;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            white-space: pre;
            overflow-x: auto;
            font-size: 0.9em;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 14px 0;
            font-size: 0.95em;
        }

        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
            vertical-align: top;
        }

        th {
            background: #667eea;
            color: white;
        }

        tr:nth-child(even) {
            background: #f2f2f2;
        }

        ul, ol {
            margin-left: 25px;
            margin-top: 8px;
        }

        li {
            margin: 4px 0;
        }

        code {
            background: #f5f5f5;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
        }

        .badge {
            display: inline-block;
            background: #667eea;
            color: white;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 0.75em;
            margin-left: 6px;
        }

        .section-anchor {
            display: block;
            position: relative;
            top: -110px;
            visibility: hidden;
        }

        .mini-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit,minmax(220px,1fr));
            gap: 12px;
            margin: 10px 0 5px;
        }

        .mini-card {
            background: white;
            border-radius: 10px;
            border: 1px solid #dee2e6;
            padding: 10px 12px;
            font-size: 0.9em;
        }

        .mini-card h4 {
            margin-top: 0;
            margin-bottom: 6px;
            color: #667eea;
        }

        @media (max-width: 768px) {
            header h1 {
                font-size: 2em;
            }

            .content {
                padding: 20px;
            }

            .section {
                padding: 20px;
            }

            .menu {
                justify-content: flex-start;
                overflow-x: auto;
            }
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
<div class="container">
    <header>
        <h1>üìö CS210 Final Exam Cheat Sheet</h1>
        <p>Data Structures & Algorithms ‚Ä¢ Based on CS210 Merged Slides + Past Finals</p>
    </header>

    <div class="menu">
        <a href="#arrays" class="menu-item">üìè Arrays & Complexity</a>
        <a href="#linked-lists" class="menu-item">üîó Linked Lists</a>
        <a href="#stacks-queues" class="menu-item">üìö Stacks & Queues</a>
        <a href="#trees" class="menu-item">üå≥ Trees & BST</a>
        <a href="#heaps" class="menu-item">‚õ∞Ô∏è Heaps & Priority Queue</a>
        <a href="#hashing" class="menu-item">#Ô∏è‚É£ Hash Tables</a>
        <a href="#graphs" class="menu-item">üï∏Ô∏è Graphs, BFS & DFS</a>
        <a href="#sorting" class="menu-item">üîÉ Sorting & Searching</a>
        <a href="#recursion" class="menu-item">ü™ú Recursion & Tracing</a>
        <a href="#patterns" class="menu-item">üéØ Exam Patterns</a>
    </div>

    <div class="content">

        <!-- ARRAYS & COMPLEXITY -->
        <span id="arrays" class="section-anchor"></span>
        <div class="section">
            <h2>üìè Arrays & Time Complexity <span class="badge">Always in MCQs</span></h2>

            <div class="critical">
                Every final has at least a few questions asking for the time complexity of operations (insertion, deletion, search) on arrays, lists, stacks, queues, trees, sorting, etc.
            </div>

            <h3>Big-O Quick Reference Table</h3>
            <table>
                <tr>
                    <th>Operation / Algorithm</th>
                    <th>Best</th>
                    <th>Average</th>
                    <th>Worst</th>
                    <th>Notes / Triggers in Questions</th>
                </tr>
                <tr>
                    <td>Access in array (A[i])</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>Direct index access ‚Üí constant time</td>
                </tr>
                <tr>
                    <td>Search in unsorted array</td>
                    <td>O(1)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>"Linear search", "no sorting", "scan all elements"</td>
                </tr>
                <tr>
                    <td>Binary Search (sorted array)</td>
                    <td>O(1)</td>
                    <td>O(log n)</td>
                    <td>O(log n)</td>
                    <td>"Sorted", "middle", "half each step"</td>
                </tr>
                <tr>
                    <td>Insert at end (enough capacity)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>O(1)</td>
                    <td>Just place at A[size]</td>
                </tr>
                <tr>
                    <td>Insert at beginning / middle</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>Need to shift elements</td>
                </tr>
                <tr>
                    <td>Delete from beginning / middle</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>O(n)</td>
                    <td>Shift to fill gap</td>
                </tr>
            </table>

            <div class="example">
                In several past finals, they give you a code snippet looping over an array with:
                <br><br>
                <code>for (int i = 0; i &lt; n; i++) ...</code><br>
                ‚úÖ Complexity = <strong>O(n)</strong><br><br>
                If there are <code>for</code> loops nested:<br>
                <code>for i in 0..n<br>  for j in 0..n</code><br>
                ‚úÖ Complexity = <strong>O(n¬≤)</strong> (very common MCQ).
            </div>

            <h3>How to Answer Complexity Questions</h3>
            <ol>
                <li>Ignore constants: 2n + 5 ‚Üí O(n)</li>
                <li>Pick the fastest growing term: n¬≤ + 100n ‚Üí O(n¬≤)</li>
                <li>Loops that run <code>n</code> times ‚Üí O(n)</li>
                <li>Nested loops ‚Üí multiply: outer n, inner n ‚Üí O(n¬≤)</li>
                <li>Divide & conquer (binary search, quicksort best/avg) ‚Üí O(n log n) or O(log n)</li>
            </ol>

            <div class="hack">
                If you see "cut the problem in half every step" ‚Üí think <strong>log n</strong>.
                If you see "double nested loops over the same range" ‚Üí think <strong>n¬≤</strong>.
            </div>
        </div>

        <!-- LINKED LISTS -->
        <span id="linked-lists" class="section-anchor"></span>
        <div class="section">
            <h2>üîó Linked Lists</h2>

            <h3>Singly vs Doubly Linked List</h3>
            <div class="comparison">
                <div class="left">
                    <h4>Singly Linked List</h4>
                    <ul>
                        <li>Each node: <code>data</code>, <code>next</code></li>
                        <li>Can only move forward</li>
                        <li>Less memory</li>
                        <li>Insert/delete at head ‚Üí O(1)</li>
                    </ul>
                </div>
                <div class="right">
                    <h4>Doubly Linked List</h4>
                    <ul>
                        <li>Each node: <code>data</code>, <code>next</code>, <code>prev</code></li>
                        <li>Move forward and backward</li>
                        <li>More memory</li>
                        <li>Insert/delete at tail with tail pointer ‚Üí O(1)</li>
                    </ul>
                </div>
            </div>

            <h3>Common Exam Operations</h3>
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Singly LL</th>
                    <th>Doubly LL</th>
                    <th>Complexity</th>
                </tr>
                <tr>
                    <td>Insert at head</td>
                    <td>Change head pointer</td>
                    <td>Change head and prev</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Insert at tail (no tail pointer)</td>
                    <td>Traverse entire list</td>
                    <td>Traverse entire list</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Insert at tail (with tail pointer)</td>
                    <td>Not trivial</td>
                    <td>Easy using tail</td>
                    <td>O(1)</td>
                </tr>
                <tr>
                    <td>Search by value</td>
                    <td>Traverse one direction</td>
                    <td>Traverse either direction</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>Delete given key</td>
                    <td>Need prev pointer or handle head</td>
                    <td>Use <code>prev</code> and <code>next</code></td>
                    <td>O(n)</td>
                </tr>
            </table>

            <div class="example">
                A very common question from past finals:<br><br>
                <strong>Q:</strong> Which data structure is better for inserting/deleting in the middle of a large list when you already have a pointer to the node?<br><br>
                ‚úÖ Answer: <strong>Linked List</strong> (O(1) to adjust pointers) vs array (O(n) to shift elements).
            </div>

            <h3>Typical Pointer Question</h3>
            <div class="diagram">
Node *p = head;
while (p != nullptr) {
    p = p->next;
}
            </div>
            üß† This loop simply traverses the list and stops at <code>nullptr</code>. Complexity: <strong>O(n)</strong>.

            <div class="tip">
                Always draw 3 boxes: <code>prev</code>, <code>curr</code>, <code>next</code> when you‚Äôre unsure about pointer updates in delete/insert questions.
            </div>
        </div>

        <!-- STACKS & QUEUES -->
        <span id="stacks-queues" class="section-anchor"></span>
        <div class="section">
            <h2>üìö Stacks & Queues</h2>

            <h3>Concepts & Use Cases</h3>
            <div class="comparison">
                <div class="left">
                    <h4>Stack (LIFO)</h4>
                    <ul>
                        <li>Last In, First Out</li>
                        <li>Operations: <code>push</code>, <code>pop</code>, <code>top</code></li>
                        <li>Used for:
                            <ul>
                                <li>Function calls (call stack)</li>
                                <li>Expression evaluation (postfix)</li>
                                <li>Undo operations</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="right">
                    <h4>Queue (FIFO)</h4>
                    <ul>
                        <li>First In, First Out</li>
                        <li>Operations: <code>enqueue</code>, <code>dequeue</code>, <code>front</code></li>
                        <li>Used for:
                            <ul>
                                <li>Breadth-First Search</li>
                                <li>Task scheduling</li>
                                <li>Buffering (printers, network)</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <h3>Array vs Linked List Implementation</h3>
            <table>
                <tr>
                    <th>Data Structure</th>
                    <th>Array Implementation</th>
                    <th>Linked List Implementation</th>
                </tr>
                <tr>
                    <td>Stack</td>
                    <td>
                        Use top index<br>
                        <code>push: A[++top] = x;</code><br>
                        <code>pop: return A[top--];</code><br>
                        Overflow if top = size-1
                    </td>
                    <td>
                        Push/pop at head of list<br>
                        No fixed size limit<br>
                        A bit more memory (pointers)
                    </td>
                </tr>
                <tr>
                    <td>Queue</td>
                    <td>
                        Use <code>front</code>, <code>rear</code><br>
                        Circular queue to reuse space<br>
                        Common exam trick: "full" even if some cells empty
                    </td>
                    <td>
                        Enqueue at tail, dequeue at head<br>
                        Efficient if you keep both pointers
                    </td>
                </tr>
            </table>

            <div class="example">
                Final-style tracing question:<br><br>
                <strong>Given:</strong> Start with empty stack. Perform:<br>
                <code>push(1), push(2), push(3), pop(), push(4)</code><br><br>
                <strong>Stack state from top ‚Üí bottom:</strong><br>
                After push(1)   ‚Üí [1]<br>
                After push(2)   ‚Üí [2, 1]<br>
                After push(3)   ‚Üí [3, 2, 1]<br>
                After pop()     ‚Üí [2, 1]<br>
                After push(4)   ‚Üí <strong>[4, 2, 1]</strong>
            </div>

            <div class="tip">
                For postfix expression evaluation, always read from left to right and use a stack. When you see an operator, pop the last 2 operands, compute, then push the result.
            </div>
        </div>

        <!-- TREES & BST -->
        <span id="trees" class="section-anchor"></span>
        <div class="section">
            <h2>üå≥ Trees & Binary Search Trees (BST)</h2>

            <div class="critical">
                Every recent final includes: building a BST from a sequence, finding height, counting nodes, or giving traversal orders (pre/in/post, level-order).
            </div>

            <h3>Basic Definitions</h3>
            <ul>
                <li><strong>Height of tree:</strong> Number of edges on longest path from root to a leaf (sometimes defined as number of nodes ‚Äì check your slides; PSU usually uses edges).</li>
                <li><strong>Depth of node:</strong> Number of edges from root to that node.</li>
                <li><strong>Leaf:</strong> Node with no children.</li>
                <li><strong>Full Binary Tree:</strong> Every node has 0 or 2 children.</li>
                <li><strong>Complete Binary Tree:</strong> All levels full except possibly last; last filled from left to right.</li>
            </ul>

            <h3>BST Property</h3>
            <div class="formula">
                For every node X: all keys in left subtree &lt; X.key and all keys in right subtree &gt; X.key
            </div>

            <h3>Traversal Orders</h3>
            <table>
                <tr>
                    <th>Traversal</th>
                    <th>Order</th>
                    <th>Use</th>
                </tr>
                <tr>
                    <td>Pre-order</td>
                    <td>Root ‚Äì Left ‚Äì Right</td>
                    <td>Copying tree, prefix notation</td>
                </tr>
                <tr>
                    <td>In-order</td>
                    <td>Left ‚Äì Root ‚Äì Right</td>
                    <td><strong>Gives sorted order in BST</strong></td>
                </tr>
                <tr>
                    <td>Post-order</td>
                    <td>Left ‚Äì Right ‚Äì Root</td>
                    <td>Delete tree, postfix notation</td>
                </tr>
                <tr>
                    <td>Level-order</td>
                    <td>BFS by level using queue</td>
                    <td>Shortest path in unweighted tree</td>
                </tr>
            </table>

            <div class="example">
                <strong>Build a BST from:</strong> 50, 30, 70, 20, 40, 60, 80<br><br>
                Inserting in that order gives:

                <div class="diagram">
        50
       /  \
     30    70
    / \   /  \
   20 40 60  80
                </div>

                <strong>In-order:</strong> 20, 30, 40, 50, 60, 70, 80 (sorted)<br>
                <strong>Pre-order:</strong> 50, 30, 20, 40, 70, 60, 80<br>
                <strong>Post-order:</strong> 20, 40, 30, 60, 80, 70, 50
            </div>

            <h3>BST Operation Complexities</h3>
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Average Case</th>
                    <th>Worst Case (Skewed)</th>
                    <th>Note</th>
                </tr>
                <tr>
                    <td>Search</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                    <td>Go left / right depending on key</td>
                </tr>
                <tr>
                    <td>Insert</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                    <td>Same as search + attach new node</td>
                </tr>
                <tr>
                    <td>Delete</td>
                    <td>O(log n)</td>
                    <td>O(n)</td>
                    <td>Three cases: 0, 1, 2 children</td>
                </tr>
            </table>

            <div class="hack">
                In exam questions asking for complexity and they say "balanced BST" ‚Üí use O(log n). If they show a skewed chain (like a linked list), complexity becomes O(n).
            </div>
        </div>

        <!-- HEAPS -->
        <span id="heaps" class="section-anchor"></span>
        <div class="section">
            <h2>‚õ∞Ô∏è Heaps & Priority Queues</h2>

            <h3>Heap Basics</h3>
            <ul>
                <li><strong>Complete binary tree</strong> stored as array.</li>
                <li><strong>Max-heap:</strong> every node ‚â• its children.</li>
                <li><strong>Min-heap:</strong> every node ‚â§ its children.</li>
                <li><strong>Priority Queue:</strong> Abstract ADT often implemented by heap.</li>
            </ul>

            <h3>Array Representation</h3>
            <div class="formula">
                If root is at index 1:<br>
                left child of i ‚Üí 2i<br>
                right child of i ‚Üí 2i + 1<br>
                parent of i ‚Üí ‚åäi / 2‚åã
            </div>

            <h3>Complexities</h3>
            <table>
                <tr>
                    <th>Operation</th>
                    <th>Heap</th>
                    <th>Complexity</th>
                    <th>Why?</th>
                </tr>
                <tr>
                    <td>Insert (push)</td>
                    <td>Heap</td>
                    <td>O(log n)</td>
                    <td>Bubble up along height</td>
                </tr>
                <tr>
                    <td>Get max/min</td>
                    <td>Heap</td>
                    <td>O(1)</td>
                    <td>At root</td>
                </tr>
                <tr>
                    <td>Delete max/min (pop)</td>
                    <td>Heap</td>
                    <td>O(log n)</td>
                    <td>Swap with last, bubble down</td>
                </tr>
                <tr>
                    <td>Build heap from n elements</td>
                    <td>Heapify</td>
                    <td><strong>O(n)</strong></td>
                    <td>Trick question ‚Äì not O(n log n)</td>
                </tr>
            </table>

            <div class="example">
                Common MCQ: "What is the complexity of building a heap from an unsorted array of n elements?"<br>
                Many students pick O(n log n) but correct answer is <strong>O(n)</strong> using bottom-up heapify.
            </div>
        </div>

        <!-- HASH TABLES -->
        <span id="hashing" class="section-anchor"></span>
        <div class="section">
            <h2>#Ô∏è‚É£ Hash Tables</h2>

            <h3>Key Ideas</h3>
            <ul>
                <li>Use hash function <code>h(key)</code> to map keys ‚Üí index.</li>
                <li>Goal: average O(1) for search/insert/delete.</li>
                <li>Collisions must be handled:
                    <ul>
                        <li>Chaining (linked lists)</li>
                        <li>Open addressing (linear / quadratic probing, double hashing)</li>
                    </ul>
                </li>
            </ul>

            <h3>Load Factor (Œ±)</h3>
            <div class="formula">
                Œ± = number of elements / table size
            </div>
            Larger Œ± ‚áí more collisions ‚áí slower operations.

            <h3>Collision Resolution</h3>
            <table>
                <tr>
                    <th>Method</th>
                    <th>How it Works</th>
                    <th>Exam Clues</th>
                </tr>
                <tr>
                    <td>Chaining</td>
                    <td>Each table index stores a linked list of keys</td>
                    <td>O(1 + Œ±) average search</td>
                </tr>
                <tr>
                    <td>Linear Probing</td>
                    <td>Try index, then index+1, index+2,...</td>
                    <td>Primary clustering issue</td>
                </tr>
                <tr>
                    <td>Quadratic Probing</td>
                    <td>Try index + 1¬≤, index + 2¬≤...</td>
                    <td>Reduces clustering but harder to implement</td>
                </tr>
                <tr>
                    <td>Double Hashing</td>
                    <td>Use secondary hash to jump</td>
                    <td>Best distribution in open addressing</td>
                </tr>
            </table>

            <div class="example">
                Typical question: "For which data structure is search complexity approximately O(1) on average but O(n) in the worst case?"<br>
                ‚úÖ Correct answer: <strong>Hash table</strong>.
            </div>
        </div>

        <!-- GRAPHS -->
        <span id="graphs" class="section-anchor"></span>
        <div class="section">
            <h2>üï∏Ô∏è Graphs, BFS & DFS</h2>

            <div class="critical">
                Last CS210 finals heavily focused on BFS, DFS tree/gray/black nodes, connected components, and shortest path in unweighted graphs.
            </div>

            <h3>Graph Representations</h3>
            <table>
                <tr>
                    <th>Representation</th>
                    <th>Space</th>
                    <th>When Best</th>
                    <th>Notes</th>
                </tr>
                <tr>
                    <td>Adjacency Matrix</td>
                    <td>O(V¬≤)</td>
                    <td>Dense graph, V small</td>
                    <td>Fast check edge(u,v): O(1)</td>
                </tr>
                <tr>
                    <td>Adjacency List</td>
                    <td>O(V + E)</td>
                    <td>Sparse graphs</td>
                    <td>Better for BFS/DFS when E ‚â™ V¬≤</td>
                </tr>
            </table>

            <h3>BFS vs DFS</h3>
            <div class="comparison">
                <div class="left">
                    <h4>BFS (Breadth-First Search)</h4>
                    <ul>
                        <li>Uses <strong>queue</strong></li>
                        <li>Visits neighbors level by level</li>
                        <li>Finds shortest path in unweighted graphs</li>
                        <li>Good for:
                            <ul>
                                <li>Shortest path</li>
                                <li>Level-order traversal</li>
                            </ul>
                        </li>
                    </ul>
                </div>
                <div class="right">
                    <h4>DFS (Depth-First Search)</h4>
                    <ul>
                        <li>Uses <strong>stack</strong> or recursion</li>
                        <li>Goes deep before backtracking</li>
                        <li>Good for:
                            <ul>
                                <li>Detecting cycles</li>
                                <li>Topological sorting (DAG)</li>
                                <li>Connected components</li>
                            </ul>
                        </li>
                    </ul>
                </div>
            </div>

            <h3>BFS Pseudocode (Adjacency List)</h3>
            <div class="diagram">
BFS(G, s):
    for each vertex v in G:
        color[v] = WHITE
        dist[v]  = ‚àû
        parent[v] = NIL
    color[s] = GRAY
    dist[s] = 0
    Q = empty queue
    ENQUEUE(Q, s)

    while Q not empty:
        u = DEQUEUE(Q)
        for each v in Adj[u]:
            if color[v] == WHITE:
                color[v] = GRAY
                dist[v] = dist[u] + 1
                parent[v] = u
                ENQUEUE(Q, v)
        color[u] = BLACK
            </div>

            <div class="tip">
                In exam tracing, write a small table of <code>color</code>, <code>dist</code>, <code>parent</code> for each vertex and update step by step. They love asking "What is the BFS tree?" or "What is the distance from s to v?".
            </div>
        </div>

        <!-- SORTING & SEARCHING -->
        <span id="sorting" class="section-anchor"></span>
        <div class="section">
            <h2>üîÉ Sorting & Searching</h2>

            <h3>Sorting Algorithms Cheat Table</h3>
            <table>
                <tr>
                    <th>Algorithm</th>
                    <th>Best</th>
                    <th>Average</th>
                    <th>Worst</th>
                    <th>Stable?</th>
                    <th>Notes</th>
                </tr>
                <tr>
                    <td>Selection Sort</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>No</td>
                    <td>Find min, swap; few swaps</td>
                </tr>
                <tr>
                    <td>Bubble Sort</td>
                    <td>O(n)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>Yes</td>
                    <td>Swap adjacent; can stop early</td>
                </tr>
                <tr>
                    <td>Insertion Sort</td>
                    <td>O(n)</td>
                    <td>O(n¬≤)</td>
                    <td>O(n¬≤)</td>
                    <td>Yes</td>
                    <td>Good for almost-sorted arrays</td>
                </tr>
                <tr>
                    <td>Merge Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>Yes</td>
                    <td>Divide & conquer, extra O(n) space</td>
                </tr>
                <tr>
                    <td>Quick Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n¬≤)</td>
                    <td>No (basic)</td>
                    <td>In-place, pivot choice matters</td>
                </tr>
                <tr>
                    <td>Heap Sort</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>O(n log n)</td>
                    <td>No</td>
                    <td>Uses heap, in-place, not stable</td>
                </tr>
            </table>

            <div class="example">
                Common CS210 final question:<br><br>
                "Which sorting algorithm has the same O(n¬≤) complexity in best, average and worst cases?"<br>
                ‚úÖ Answer: <strong>Selection Sort</strong>.
            </div>

            <h3>Binary Search</h3>
            <ul>
                <li>Requires <strong>sorted</strong> array.</li>
                <li>Repeatedly compare with middle element.</li>
                <li>Complexity: O(log n).</li>
            </ul>

            <div class="diagram">
BinarySearch(A, key):
    low = 0
    high = n - 1
    while low <= high:
        mid = (low + high) / 2
        if A[mid] == key:
            return mid
        else if A[mid] < key:
            low = mid + 1
        else:
            high = mid - 1
    return -1
            </div>

            <div class="hack">
                If the question mentions "compare with the middle element" or "discard half of the search space each time" ‚Üí answer is almost always Binary Search with O(log n) time.
            </div>
        </div>

        <!-- RECURSION & TRACING -->
        <span id="recursion" class="section-anchor"></span>
        <div class="section">
            <h2>ü™ú Recursion & Tracing</h2>

            <h3>How to Trace Recursive Code (Exam Style)</h3>
            <ol>
                <li>Write a small table of calls: <code>f(4)</code>, <code>f(3)</code>, etc.</li>
                <li>Evaluate base case clearly.</li>
                <li>Unroll from base case back up using return values.</li>
            </ol>

            <div class="example">
                <strong>Example:</strong><br>
                <code>
int mystery(int n) {
    if (n == 0) return 1;
    return 2 * mystery(n - 1);
}
                </code><br><br>
                Trace for <code>mystery(3)</code>:<br>
                <ul>
                    <li>mystery(0) = 1 (base)</li>
                    <li>mystery(1) = 2 * mystery(0) = 2</li>
                    <li>mystery(2) = 2 * mystery(1) = 4</li>
                    <li>mystery(3) = 2 * mystery(2) = 8</li>
                </ul>
                ‚úÖ So <code>mystery(3)</code> returns 8 = 2¬≥+¬π? Actually here pattern is 2‚Åø ‚Üí 2¬≥ = 8.
            </div>

            <h3>Recurrence ‚Üí Complexity (Intuition)</h3>
            <table>
                <tr>
                    <th>Recurrence</th>
                    <th>Example</th>
                    <th>Complexity</th>
                </tr>
                <tr>
                    <td>T(n) = T(n-1) + O(1)</td>
                    <td>Linear recursion (countdown)</td>
                    <td>O(n)</td>
                </tr>
                <tr>
                    <td>T(n) = T(n/2) + O(1)</td>
                    <td>Binary search</td>
                    <td>O(log n)</td>
                </tr>
                <tr>
                    <td>T(n) = 2T(n/2) + O(n)</td>
                    <td>Merge sort</td>
                    <td>O(n log n)</td>
                </tr>
                <tr>
                    <td>T(n) = 2T(n-1) + O(1)</td>
                    <td>Very bad recursion</td>
                    <td>O(2‚Åø)</td>
                </tr>
            </table>
        </div>

        <!-- EXAM PATTERNS -->
        <span id="patterns" class="section-anchor"></span>
        <div class="section" style="background:#fff3cd;border-left-color:#ffc107;">
            <h2>üéØ CS210 Final Exam Patterns & Last-Minute Checklist</h2>

            <h3>What Repeats in Almost Every Final</h3>
            <ul>
                <li>‚úîÔ∏è Time complexity MCQs (arrays, lists, BST, sorting, hash tables).</li>
                <li>‚úîÔ∏è Trace a piece of code and give output / complexity.</li>
                <li>‚úîÔ∏è Build or traverse a BST (pre/in/post/level order).</li>
                <li>‚úîÔ∏è BFS or DFS tracing with queue/stack + color/distance tables.</li>
                <li>‚úîÔ∏è Sorting algorithm identification from description (selection vs insertion vs merge vs quick).</li>
                <li>‚úîÔ∏è Linked list insertion/deletion pointer tricky question.</li>
                <li>‚úîÔ∏è Heap or priority queue conceptual questions.</li>
            </ul>

            <h3>Common Traps</h3>
            <ul>
                <li>‚ùå Saying Binary Search works on unsorted array.</li>
                <li>‚ùå Forgetting worst case of Quick Sort is O(n¬≤).</li>
                <li>‚ùå Confusing BFS (queue) with DFS (stack).</li>
                <li>‚ùå Thinking building a heap is O(n log n) instead of O(n).</li>
                <li>‚ùå Forgetting that in-order traversal of BST gives sorted order.</li>
                <li>‚ùå Using O(log n) for unbalanced BST instead of O(n).</li>
            </ul>

            <h3>Last-Minute Mental Map</h3>
            <div class="mini-grid">
                <div class="mini-card">
                    <h4>Arrays</h4>
                    <ul>
                        <li>Access O(1)</li>
                        <li>Insert/delete in middle O(n)</li>
                    </ul>
                </div>
                <div class="mini-card">
                    <h4>Linked List</h4>
                    <ul>
                        <li>Insert/delete at head O(1)</li>
                        <li>Search O(n)</li>
                    </ul>
                </div>
                <div class="mini-card">
                    <h4>Stack & Queue</h4>
                    <ul>
                        <li>LIFO & FIFO</li>
                        <li>All operations O(1)</li>
                    </ul>
                </div>
                <div class="mini-card">
                    <h4>BST</h4>
                    <ul>
                        <li>Balanced: O(log n)</li>
                        <li>Skewed: O(n)</li>
                    </ul>
                </div>
                <div class="mini-card">
                    <h4>Hash Table</h4>
                    <ul>
                        <li>Avg O(1)</li>
                        <li>Worst O(n)</li>
                    </ul>
                </div>
                <div class="mini-card">
                    <h4>Sorting</h4>
                    <ul>
                        <li>n¬≤: selection, insertion, bubble</li>
                        <li>n log n: merge, quick (avg), heap</li>
                    </ul>
                </div>
            </div>

            <div class="hack">
                If you are stuck in an MCQ, first eliminate options that obviously break definitions: e.g., "BFS uses a stack" is immediately wrong; "in-order traversal gives random order in BST" is wrong; "hash table worst-case O(1)" is wrong.
            </div>
        </div>

    </div>
</div>
</body>
</html>
