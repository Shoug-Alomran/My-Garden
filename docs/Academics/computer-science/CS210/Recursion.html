<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Recursion - Comprehensive Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 3em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        nav {
            background: #2c3e50;
            padding: 15px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        nav a:hover {
            background: #34495e;
        }

        .content {
            padding: 40px;
        }

        section {
            margin-bottom: 50px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        h2 {
            color: #2c3e50;
            font-size: 2.2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #34495e;
            font-size: 1.6em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        .definition {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #2196F3;
            margin: 20px 0;
        }

        .important {
            background: #fff3cd;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
        }

        .example {
            background: #f1f8e9;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #4caf50;
            margin: 20px 0;
        }

        .code-block {
            background: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            margin: 15px 0;
        }

        .code-block .keyword {
            color: #c792ea;
        }

        .code-block .function {
            color: #82aaff;
        }

        .code-block .comment {
            color: #546e7a;
            font-style: italic;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .visual-diagram {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            border: 2px solid #667eea;
        }

        .complexity-box {
            display: inline-block;
            padding: 10px 20px;
            background: #ff5722;
            color: white;
            border-radius: 25px;
            font-weight: bold;
            margin: 10px 5px;
        }

        .key-points {
            background: #e8eaf6;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
        }

        .key-points ul {
            margin-left: 20px;
        }

        .key-points li {
            margin: 10px 0;
            padding-left: 10px;
        }

        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .comparison-card h4 {
            color: #667eea;
            margin-bottom: 15px;
        }

        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px;
        }

        @media (max-width: 768px) {
            .comparison-table {
                grid-template-columns: 1fr;
            }

            nav ul {
                flex-direction: column;
                align-items: center;
            }

            header h1 {
                font-size: 2em;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Recursion Study Guide</h1>
            <p>Data Structures and Algorithms in Java</p>
            <p style="font-size: 0.9em; margin-top: 10px;">Based on Goodrich, Tamassia, & Goldwasser</p>
        </header>

        <nav>
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#pattern">Recursion Pattern</a></li>
                <li><a href="#examples">Examples</a></li>
                <li><a href="#types">Types of Recursion</a></li>
                <li><a href="#complexity">Complexity Analysis</a></li>
                <li><a href="#summary">Summary</a></li>
            </ul>
        </nav>

        <div class="content">
            <!-- INTRODUCTION -->
            <section id="introduction">
                <h2>üéØ What is Recursion?</h2>
                
                <div class="definition">
                    <h3>Definition</h3>
                    <p><strong>Recursion</strong> occurs when a method calls itself. It's a powerful programming technique where a problem is solved by breaking it down into smaller instances of the same problem.</p>
                </div>

                <h3>Content of a Recursive Method</h3>
                
                <div class="key-points">
                    <h4>1. Base Case(s) üõë</h4>
                    <ul>
                        <li>Values of input variables for which we perform <strong>no recursive calls</strong></li>
                        <li>There should be <strong>at least one base case</strong></li>
                        <li>Every possible chain of recursive calls must eventually reach a base case</li>
                        <li><em>When we stop the loop - the method must stop calling itself</em></li>
                    </ul>
                </div>

                <div class="key-points">
                    <h4>2. Recursive Calls üîÑ</h4>
                    <ul>
                        <li>Calls to the current method</li>
                        <li>Each recursive call should be defined so that it <strong>makes progress towards a base case</strong></li>
                        <li>The method must update parameters to eventually reach the base case</li>
                    </ul>
                </div>

                <div class="important">
                    <h3>‚ö†Ô∏è Critical Requirements</h3>
                    <ul>
                        <li>Must have a base case (or the recursion never stops!)</li>
                        <li>Must make progress toward the base case</li>
                        <li>Must call itself (that's what makes it recursive)</li>
                    </ul>
                </div>
            </section>

            <!-- RECURSION PATTERN -->
            <section id="pattern">
                <h2>üî¢ The Recursion Pattern: Factorial</h2>

                <div class="example">
                    <h3>Classic Example: Factorial Function</h3>
                    <p><strong>Mathematical Definition:</strong> n! = 1 ¬∑ 2 ¬∑ 3 ¬∑ ... ¬∑ (n-1) ¬∑ n</p>
                    
                    <p style="margin-top: 15px;"><strong>Recursive Definition:</strong></p>
                    <p style="font-size: 1.2em; margin: 10px 0;">
                        f(n) = { 1 if n = 0<br>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n ¬∑ f(n-1) else
                    </p>
                </div>

                <h3>Java Implementation</h3>
                <div class="code-block">
<span class="keyword">public static int</span> <span class="function">factorial</span>(<span class="keyword">int</span> n) <span class="keyword">throws</span> IllegalArgumentException {
    <span class="keyword">if</span> (n < 0)
        <span class="keyword">throw new</span> IllegalArgumentException();  <span class="comment">// argument must be nonnegative</span>
    <span class="keyword">else if</span> (n == 0)
        <span class="keyword">return</span> 1;                              <span class="comment">// base case</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> n * <span class="function">factorial</span>(n-1);          <span class="comment">// recursive case (must update n)</span>
}
                </div>

                <h3>Execution Trace: factorial(4)</h3>
                <div class="visual-diagram">
                    <pre style="text-align: left; display: inline-block;">
factorial(4)
    ‚Üì call                    ‚Üí return 4*6 = 24 (final answer)
factorial(3)
    ‚Üì call                    ‚Üí return 3*2 = 6
factorial(2)
    ‚Üì call                    ‚Üí return 2*1 = 2
factorial(1)
    ‚Üì call                    ‚Üí return 1*1 = 1
factorial(0)
    ‚Üí return 1 (base case)
                    </pre>
                </div>

                <div class="important">
                    <h3>How it Works:</h3>
                    <ol>
                        <li><strong>Forward calls:</strong> Methods keep calling themselves with decreasing n</li>
                        <li><strong>Base case reached:</strong> When n = 0, return 1</li>
                        <li><strong>Backward returns:</strong> Each call returns its result to the caller</li>
                        <li><strong>Final result:</strong> 4! = 24</li>
                    </ol>
                    <p style="margin-top: 15px;"><strong>Runtime:</strong> <span class="complexity-box">O(n)</span> - Makes n+1 calls</p>
                </div>
            </section>

            <!-- EXAMPLES -->
            <section id="examples">
                <h2>üìù Common Recursion Examples</h2>

                <!-- BINARY SEARCH -->
                <h3>1. Binary Search</h3>
                <div class="example">
                    <p><strong>Problem:</strong> Search for an integer in an ordered array</p>
                    <p><strong>Strategy:</strong> Check middle element, then recur on appropriate half</p>
                </div>

                <div class="code-block">
<span class="keyword">public static boolean</span> <span class="function">binarySearch</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> target, <span class="keyword">int</span> low, <span class="keyword">int</span> high) {
    <span class="keyword">if</span> (low > high)
        <span class="keyword">return false</span>;                      <span class="comment">// interval empty; no match</span>
    <span class="keyword">else</span> {
        <span class="keyword">int</span> mid = (low + high) / 2;
        <span class="keyword">if</span> (target == data[mid])
            <span class="keyword">return true</span>;                   <span class="comment">// found a match</span>
        <span class="keyword">else if</span> (target < data[mid])
            <span class="keyword">return</span> <span class="function">binarySearch</span>(data, target, low, mid - 1);    <span class="comment">// recur left</span>
        <span class="keyword">else</span>
            <span class="keyword">return</span> <span class="function">binarySearch</span>(data, target, mid + 1, high);   <span class="comment">// recur right</span>
    }
}
                </div>

                <div class="important">
                    <p><strong>Runtime:</strong> <span class="complexity-box">O(log n)</span></p>
                    <p>Each recursive call divides the search region in half, so there can be at most log n levels.</p>
                </div>

                <!-- LINEAR SUM -->
                <h3>2. Linear Sum (Array Summation)</h3>
                <div class="example">
                    <p><strong>Problem:</strong> Add all numbers in an integer array</p>
                    <p><strong>Strategy:</strong> Sum first n-1 elements, then add the nth element</p>
                </div>

                <div class="code-block">
<span class="keyword">public static int</span> <span class="function">linearSum</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n == 0)
        <span class="keyword">return</span> 0;                          <span class="comment">// base case</span>
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="function">linearSum</span>(A, n - 1) + A[n - 1];  <span class="comment">// recursive case</span>
}
                </div>

                <div class="visual-diagram">
                    <h4>Trace: linearSum(data, 5) for data = [4, 3, 6, 2, 8]</h4>
                    <pre style="text-align: left; display: inline-block;">
linearSum(data, 5) ‚Üí return 15 + data[4] = 15 + 8 = 23
    ‚Üì
linearSum(data, 4) ‚Üí return 13 + data[3] = 13 + 2 = 15
    ‚Üì
linearSum(data, 3) ‚Üí return 7 + data[2] = 7 + 6 = 13
    ‚Üì
linearSum(data, 2) ‚Üí return 4 + data[1] = 4 + 3 = 7
    ‚Üì
linearSum(data, 1) ‚Üí return 0 + data[0] = 0 + 4 = 4
    ‚Üì
linearSum(data, 0) ‚Üí return 0 (base case)
                    </pre>
                </div>

                <!-- ARRAY REVERSAL -->
                <h3>3. Reversing an Array</h3>
                <div class="code-block">
<span class="keyword">public static void</span> <span class="function">reverseArray</span>(<span class="keyword">int</span>[] data, <span class="keyword">int</span> low, <span class="keyword">int</span> high) {
    <span class="keyword">if</span> (low < high) {                     <span class="comment">// if at least two elements in subarray</span>
        <span class="keyword">int</span> temp = data[low];             <span class="comment">// swap data[low] and data[high]</span>
        data[low] = data[high];
        data[high] = temp;
        <span class="function">reverseArray</span>(data, low + 1, high - 1);   <span class="comment">// recur on the rest</span>
    }
}
                </div>

                <div class="important">
                    <p><strong>Runtime:</strong> <span class="complexity-box">O(n)</span></p>
                    <p>Each recursive call swaps two elements and moves indices closer to the middle.</p>
                </div>

                <!-- POWER FUNCTION -->
                <h3>4. Computing Powers</h3>
                
                <div class="comparison-table">
                    <div class="comparison-card">
                        <h4>‚ùå Slow Approach: O(n)</h4>
                        <div class="code-block">
<span class="keyword">int</span> <span class="function">power</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n == 0)
        <span class="keyword">return</span> 1;
    <span class="keyword">else</span>
        <span class="keyword">return</span> x * <span class="function">power</span>(x, n-1);
}
                        </div>
                        <p>Makes n recursive calls</p>
                    </div>

                    <div class="comparison-card">
                        <h4>‚úÖ Fast Approach: O(log n)</h4>
                        <div class="code-block">
<span class="keyword">int</span> <span class="function">power</span>(<span class="keyword">int</span> x, <span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n == 0)
        <span class="keyword">return</span> 1;
    <span class="keyword">if</span> (n % 2 == 1) {
        <span class="keyword">int</span> y = <span class="function">power</span>(x, (n-1)/2);
        <span class="keyword">return</span> x * y * y;
    } <span class="keyword">else</span> {
        <span class="keyword">int</span> y = <span class="function">power</span>(x, n/2);
        <span class="keyword">return</span> y * y;
    }
}
                        </div>
                        <p>Uses repeated squaring!</p>
                    </div>
                </div>

                <div class="example">
                    <h4>How Recursive Squaring Works:</h4>
                    <ul>
                        <li>2‚Å¥ = (2¬≤)¬≤ = 4¬≤ = 16</li>
                        <li>2‚Åµ = 2 ¬∑ (2¬≤)¬≤ = 2 ¬∑ 16 = 32</li>
                        <li>2‚Å∏ = (2‚Å¥)¬≤ = 16¬≤ = 256</li>
                    </ul>
                    <p style="margin-top: 15px;"><strong>Key Insight:</strong> Halve the exponent each time ‚Üí logarithmic complexity!</p>
                </div>

                <!-- FIBONACCI -->
                <h3>5. Fibonacci Numbers</h3>
                
                <div class="definition">
                    <p><strong>Definition:</strong></p>
                    <ul>
                        <li>F‚ÇÄ = 0</li>
                        <li>F‚ÇÅ = 1</li>
                        <li>F·µ¢ = F·µ¢‚Çã‚ÇÅ + F·µ¢‚Çã‚ÇÇ for i > 1</li>
                    </ul>
                </div>

                <div class="comparison-table">
                    <div class="comparison-card">
                        <h4>‚ùå Binary Recursion (SLOW)</h4>
                        <div class="code-block">
<span class="keyword">int</span> <span class="function">binaryFib</span>(<span class="keyword">int</span> k) {
    <span class="keyword">if</span> (k <= 1)
        <span class="keyword">return</span> k;
    <span class="keyword">else</span>
        <span class="keyword">return</span> <span class="function">binaryFib</span>(k-1) 
             + <span class="function">binaryFib</span>(k-2);
}
                        </div>
                        <p><strong>Runtime:</strong> <span class="complexity-box">O(2‚Åø)</span> - EXPONENTIAL!</p>
                        <p>Makes redundant calculations</p>
                    </div>

                    <div class="comparison-card">
                        <h4>‚úÖ Linear Recursion (FAST)</h4>
                        <div class="code-block">
<span class="keyword">Pair</span> <span class="function">linearFib</span>(<span class="keyword">int</span> k) {
    <span class="keyword">if</span> (k == 1)
        <span class="keyword">return</span> (k, 0);
    <span class="keyword">else</span> {
        (i, j) = <span class="function">linearFib</span>(k-1);
        <span class="keyword">return</span> (i+j, i);
    }
}
                        </div>
                        <p><strong>Runtime:</strong> <span class="complexity-box">O(n)</span> - LINEAR!</p>
                        <p>Returns pair (F‚Çñ, F‚Çñ‚Çã‚ÇÅ)</p>
                    </div>
                </div>

                <!-- ENGLISH RULER -->
                <h3>6. English Ruler (Drawing Ticks)</h3>
                
                <div class="example">
                    <p><strong>Problem:</strong> Draw tick marks on a ruler with varying lengths</p>
                    <p><strong>Pattern:</strong> For a tick of length L, draw smaller ticks (L-1) on both sides</p>
                </div>

                <div class="code-block">
<span class="keyword">public static void</span> <span class="function">drawInterval</span>(<span class="keyword">int</span> centralLength) {
    <span class="keyword">if</span> (centralLength > 0) {
        <span class="function">drawInterval</span>(centralLength - 1);     <span class="comment">// draw top interval</span>
        <span class="function">drawLine</span>(centralLength);              <span class="comment">// draw center tick line</span>
        <span class="function">drawInterval</span>(centralLength - 1);     <span class="comment">// draw bottom interval</span>
    }
}
                </div>

                <div class="important">
                    <p><strong>Note:</strong> This is an example of <strong>binary recursion</strong> (two recursive calls per invocation)</p>
                </div>
            </section>

            <!-- TYPES OF RECURSION -->
            <section id="types">
                <h2>üé≠ Types of Recursion</h2>

                <!-- LINEAR RECURSION -->
                <h3>1. Linear Recursion</h3>
                <div class="definition">
                    <p><strong>Definition:</strong> Makes at most <strong>one recursive call</strong> per invocation</p>
                </div>

                <div class="key-points">
                    <h4>Characteristics:</h4>
                    <ul>
                        <li>Test for base cases first</li>
                        <li>Perform a single recursive call (may have conditionals to decide which call)</li>
                        <li>Each recursive call makes progress toward base case</li>
                    </ul>
                </div>

                <div class="example">
                    <h4>Examples:</h4>
                    <ul>
                        <li>Factorial</li>
                        <li>Linear sum</li>
                        <li>Binary search</li>
                        <li>Array reversal</li>
                    </ul>
                </div>

                <!-- TAIL RECURSION -->
                <h3>2. Tail Recursion</h3>
                <div class="definition">
                    <p><strong>Definition:</strong> A special case of linear recursion where the recursive call is the <strong>last step</strong> of the method</p>
                </div>

                <div class="important">
                    <h4>‚ö° Special Property:</h4>
                    <p>Tail recursive methods can be <strong>easily converted to iterative (loop-based)</strong> implementations, which are often more efficient.</p>
                </div>

                <div class="comparison-table">
                    <div class="comparison-card">
                        <h4>Tail Recursive Version</h4>
                        <div class="code-block">
<span class="keyword">void</span> <span class="function">reverseArray</span>(<span class="keyword">int</span>[] A, 
                  <span class="keyword">int</span> i, <span class="keyword">int</span> j) {
    <span class="keyword">if</span> (i < j) {
        swap(A[i], A[j]);
        <span class="function">reverseArray</span>(A, i+1, j-1);
    }
}
                        </div>
                    </div>

                    <div class="comparison-card">
                        <h4>Iterative Equivalent</h4>
                        <div class="code-block">
<span class="keyword">void</span> <span class="function">reverseArray</span>(<span class="keyword">int</span>[] A, 
                  <span class="keyword">int</span> i, <span class="keyword">int</span> j) {
    <span class="keyword">while</span> (i < j) {
        swap(A[i], A[j]);
        i = i + 1;
        j = j - 1;
    }
}
                        </div>
                    </div>
                </div>

                <!-- BINARY RECURSION -->
                <h3>3. Binary Recursion</h3>
                <div class="definition">
                    <p><strong>Definition:</strong> Makes <strong>two recursive calls</strong> for each non-base case</p>
                </div>

                <div class="example">
                    <h4>Examples:</h4>
                    <ul>
                        <li>Binary sum (divide array in half, sum each half)</li>
                        <li>English ruler drawing</li>
                        <li>Binary Fibonacci (inefficient)</li>
                    </ul>
                </div>

                <div class="code-block">
<span class="keyword">int</span> <span class="function">binarySum</span>(<span class="keyword">int</span>[] A, <span class="keyword">int</span> i, <span class="keyword">int</span> n) {
    <span class="keyword">if</span> (n == 1)
        <span class="keyword">return</span> A[i];
    <span class="keyword">return</span> <span class="function">binarySum</span>(A, i, n/2) + <span class="function">binarySum</span>(A, i + n/2, n/2);
}
                </div>

                <!-- MULTIPLE RECURSION -->
                <h3>4. Multiple Recursion</h3>
                <div class="definition">
                    <p><strong>Definition:</strong> Makes <strong>potentially many</strong> recursive calls (more than two)</p>
                </div>

                <div class="example">
                    <h4>Example: Puzzle Solving</h4>
                    <p>Generate all possible combinations/permutations</p>
                </div>

                <div class="code-block">
<span class="keyword">void</span> <span class="function">puzzleSolve</span>(<span class="keyword">int</span> k, List S, Set U) {
    <span class="keyword">for all</span> e <span class="keyword">in</span> U <span class="keyword">do</span>
        Remove e from U
        Add e to the end of S
        <span class="keyword">if</span> k == 1 <span class="keyword">then</span>
            Test whether S solves the puzzle
        <span class="keyword">else</span>
            <span class="function">puzzleSolve</span>(k-1, S, U)
        Add e back to U
        Remove e from the end of S
}
                </div>

                <div class="visual-diagram">
                    <h4>Recursion Tree for PuzzleSolve(3, [], {a,b,c})</h4>
                    <pre style="text-align: left; display: inline-block; font-size: 0.9em;">
                        []
          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
         [a]       [b]       [c]
       ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îê
      [ab][ac] [ba][bc] [ca][cb]
       ‚Üì   ‚Üì    ‚Üì   ‚Üì    ‚Üì   ‚Üì
      abc acb  bac bca  cab cba
                    </pre>
                </div>
            </section>

            <!-- COMPLEXITY ANALYSIS -->
            <section id="complexity">
                <h2>‚è±Ô∏è Complexity Analysis</h2>

                <h3>Time Complexity Comparison</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Type</th>
                            <th>Time Complexity</th>
                            <th>Explanation</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Factorial</td>
                            <td>Linear</td>
                            <td><span class="complexity-box">O(n)</span></td>
                            <td>Makes n recursive calls</td>
                        </tr>
                        <tr>
                            <td>Binary Search</td>
                            <td>Linear</td>
                            <td><span class="complexity-box">O(log n)</span></td>
                            <td>Halves search space each time</td>
                        </tr>
                        <tr>
                            <td>Linear Sum</td>
                            <td>Linear</td>
                            <td><span class="complexity-box">O(n)</span></td>
                            <td>Processes each element once</td>
                        </tr>
                        <tr>
                            <td>Array Reversal</td>
                            <td>Tail</td>
                            <td><span class="complexity-box">O(n)</span></td>
                            <td>Swaps n/2 pairs</td>
                        </tr>
                        <tr>
                            <td>Power (naive)</td>
                            <td>Linear</td>
                            <td><span class="complexity-box">O(n)</span></td>
                            <td>Multiplies n times</td>
                        </tr>
                        <tr>
                            <td>Power (squaring)</td>
                            <td>Linear</td>
                            <td><span class="complexity-box">O(log n)</span></td>
                            <td>Halves exponent each time</td>
                        </tr>
                        <tr>
                            <td>Binary Sum</td>
                            <td>Binary</td>
                            <td><span class="complexity-box">O(n)</span></td>
                            <td>Processes each element in tree</td>
                        </tr>
                        <tr>
                            <td>Binary Fibonacci</td>
                            <td>Binary</td>
                            <td><span class="complexity-box">O(2‚Åø)</span></td>
                            <td>Exponential - very inefficient!</td>
                        </tr>
                        <tr>
                            <td>Linear Fibonacci</td>
                            <td>Linear</td>
                            <td><span class="complexity-box">O(n)</span></td>
                            <td>Makes n-1 calls</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Understanding Call Counts</h3>
                
                <div class="example">
                    <h4>Binary Fibonacci Analysis</h4>
                    <p>Let n‚Çñ = number of recursive calls for BinaryFib(k):</p>
                    <ul>
                        <li>n‚ÇÄ = 1</li>
                        <li>n‚ÇÅ = 1</li>
                        <li>n‚ÇÇ = n‚ÇÅ + n‚ÇÄ + 1 = 3</li>
                        <li>n‚ÇÉ = n‚ÇÇ + n‚ÇÅ + 1 = 5</li>
                        <li>n‚ÇÑ = n‚ÇÉ + n‚ÇÇ + 1 = 9</li>
                        <li>n‚Çà = 67</li>
                    </ul>
                    <p style="margin-top: 15px;">Notice: n‚Çñ at least doubles every other time ‚Üí n‚Çñ > 2^(k/2)</p>
                    <p><strong>This is exponential growth - very bad!</strong></p>
                </div>

                <div class="important">
                    <h3>Key Insights for Efficiency</h3>
                    <ul>
                        <li><strong>Avoid redundant calculations:</strong> Binary Fibonacci recalculates same values multiple times</li>
                        <li><strong>Use clever math:</strong> Recursive squaring reduces O(n) to O(log n)</li>
                        <li><strong>Consider iterative alternatives:</strong> Tail recursive methods can often be converted to loops</li>
                        <li><strong>Store intermediate results:</strong> Dynamic programming (memoization) can help</li>
                    </ul>
                </div>
            </section>

            <!-- SUMMARY -->
            <section id="summary">
                <h2>üìã Summary & Study Tips</h2>

                <h3>Key Concepts to Remember</h3>
                
                <div class="key-points">
                    <h4>1. Three Requirements for Recursion:</h4>
                    <ul>
                        <li>‚úÖ Must have a <strong>base case</strong></li>
                        <li>‚úÖ Must make <strong>progress</strong> toward base case</li>
                        <li>‚úÖ Must <strong>call itself</strong></li>
                    </ul>
                </div>

                <div class="key-points">
                    <h4>2. Types of Recursion:</h4>
                    <ul>
                        <li><strong>Linear:</strong> One recursive call per invocation</li>
                        <li><strong>Tail:</strong> Recursive call is the last operation (easily converted to loops)</li>
                        <li><strong>Binary:</strong> Two recursive calls per invocation</li>
                        <li><strong>Multiple:</strong> Many recursive calls (used for enumeration/combinations)</li>
                    </ul>
                </div>

                <div class="key-points">
                    <h4>3. When to Use Recursion:</h4>
                    <ul>
                        <li>‚úÖ Problem can be broken into smaller subproblems of the same type</li>
                        <li>‚úÖ Natural recursive structure (trees, divide-and-conquer)</li>
                        <li>‚úÖ Code is clearer/simpler than iterative version</li>
                        <li>‚ùå Avoid when efficiency is critical and recursion adds overhead</li>
                        <li>‚ùå Avoid when iterative solution is equally clear</li>
                    </ul>
                </div>

                <h3>Common Pitfalls to Avoid</h3>
                
                <div class="important">
                    <ul>
                        <li>üö´ <strong>Missing base case:</strong> Results in infinite recursion (stack overflow)</li>
                        <li>üö´ <strong>Not making progress:</strong> Recursive call doesn't move toward base case</li>
                        <li>üö´ <strong>Redundant calculations:</strong> Like binary Fibonacci - use dynamic programming instead</li>
                        <li>üö´ <strong>Too many recursive calls:</strong> Can cause stack overflow for large inputs</li>
                        <li>üö´ <strong>Modifying wrong parameters:</strong> Ensure you update parameters correctly</li>
                    </ul>
                </div>

                <h3>Study Strategies</h3>
                
                <div class="example">
                    <h4>To Master Recursion:</h4>
                    <ol>
                        <li><strong>Draw recursion trees:</strong> Visualize how calls are made and returned</li>
                        <li><strong>Trace execution:</strong> Follow the values step by step</li>
                        <li><strong>Count recursive calls:</strong> Understand time complexity</li>
                        <li><strong>Identify base cases:</strong> Always start here when analyzing recursive code</li>
                        <li><strong>Practice converting:</strong> Try converting recursive to iterative and vice versa</li>
                        <li><strong>Solve problems:</strong> Write your own recursive solutions from scratch</li>
                    </ol>
                </div>

                <h3>Practice Problems</h3>
                
                <div class="key-points">
                    <h4>Try implementing these recursively:</h4>
                    <ul>
                        <li>Calculate the nth Fibonacci number (both ways)</li>
                        <li>Find the maximum element in an array</li>
                        <li>Check if a string is a palindrome</li>
                        <li>Calculate the Greatest Common Divisor (GCD)</li>
                        <li>Generate all permutations of a string</li>
                        <li>Implement merge sort</li>
                        <li>Traverse a binary tree</li>
                        <li>Solve the Tower of Hanoi puzzle</li>
                    </ul>
                </div>

                <h3>Quick Reference Card</h3>
                
                <table>
                    <thead>
                        <tr>
                            <th>Concept</th>
                            <th>Key Points</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Base Case</strong></td>
                            <td>Simplest case that can be solved directly without recursion</td>
                        </tr>
                        <tr>
                            <td><strong>Recursive Case</strong></td>
                            <td>Breaks problem into smaller subproblems and calls itself</td>
                        </tr>
                        <tr>
                            <td><strong>Progress</strong></td>
                            <td>Each recursive call must move closer to the base case</td>
                        </tr>
                        <tr>
                            <td><strong>Stack Space</strong></td>
                            <td>Each recursive call uses stack memory; deep recursion can overflow</td>
                        </tr>
                        <tr>
                            <td><strong>Tail Recursion</strong></td>
                            <td>Last operation is the recursive call; can be optimized to iteration</td>
                        </tr>
                        <tr>
                            <td><strong>Time Complexity</strong></td>
                            <td>Count how many times the function is called and work per call</td>
                        </tr>
                    </tbody>
                </table>

                <div class="important" style="margin-top: 30px; text-align: center;">
                    <h3>üéì Final Tip</h3>
                    <p style="font-size: 1.2em;">
                        "To understand recursion, you must first understand recursion." üòä
                    </p>
                    <p style="margin-top: 15px;">
                        Practice is key! Start with simple examples and gradually work your way up to more complex problems. Draw diagrams, trace executions, and don't be afraid to experiment!
                    </p>
                </div>
            </section>
        </div>

        <footer>
            <p>üìö Based on "Data Structures and Algorithms in Java" by Goodrich, Tamassia, & Goldwasser (6th Edition)</p>
            <p style="margin-top: 10px;">CS210 Week 5 - Recursion Study Guide</p>
        </footer>
    </div>
</body>
</html>