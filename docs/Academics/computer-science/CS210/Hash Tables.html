<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hash Tables - Comprehensive Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 10px;
            font-size: 2.5em;
            border-bottom: 4px solid #3498db;
            padding-bottom: 15px;
        }
        
        .subtitle {
            text-align: center;
            color: #7f8c8d;
            margin-bottom: 40px;
            font-style: italic;
        }
        
        h2 {
            color: #2980b9;
            margin-top: 40px;
            margin-bottom: 20px;
            font-size: 2em;
            border-left: 5px solid #3498db;
            padding-left: 15px;
        }
        
        h3 {
            color: #16a085;
            margin-top: 25px;
            margin-bottom: 15px;
            font-size: 1.5em;
        }
        
        h4 {
            color: #27ae60;
            margin-top: 20px;
            margin-bottom: 10px;
            font-size: 1.2em;
        }
        
        p {
            margin-bottom: 15px;
            text-align: justify;
        }
        
        .highlight {
            background-color: #fff3cd;
            padding: 15px;
            border-left: 4px solid #ffc107;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .important {
            background-color: #f8d7da;
            padding: 15px;
            border-left: 4px solid #dc3545;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .success {
            background-color: #d4edda;
            padding: 15px;
            border-left: 4px solid #28a745;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        .info {
            background-color: #d1ecf1;
            padding: 15px;
            border-left: 4px solid #17a2b8;
            margin: 20px 0;
            border-radius: 5px;
        }
        
        code {
            background-color: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            color: #e83e8c;
        }
        
        pre {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        th {
            background-color: #3498db;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }
        
        td {
            padding: 12px;
            border-bottom: 1px solid #ddd;
        }
        
        tr:hover {
            background-color: #f5f5f5;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 20px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        .formula {
            background-color: #e8f4f8;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
            text-align: center;
            font-family: 'Times New Roman', serif;
            font-size: 1.2em;
        }
        
        .example {
            background-color: #f9f9f9;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
            margin: 20px 0;
        }
        
        .example h4 {
            margin-top: 0;
            color: #8e44ad;
        }
        
        .visual {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background-color: #f8f9fa;
            border-radius: 5px;
        }
        
        .comparison {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-item {
            padding: 15px;
            border-radius: 5px;
        }
        
        .comparison-item.good {
            background-color: #d4edda;
            border: 2px solid #28a745;
        }
        
        .comparison-item.bad {
            background-color: #f8d7da;
            border: 2px solid #dc3545;
        }
        
        .toc {
            background-color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 40px;
        }
        
        .toc h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        
        .toc ul {
            list-style-type: none;
            margin-left: 0;
        }
        
        .toc a {
            color: #3498db;
            text-decoration: none;
            transition: color 0.3s;
        }
        
        .toc a:hover {
            color: #2980b9;
            text-decoration: underline;
        }
        
        .key-point {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .key-point h4 {
            color: white;
            margin-top: 0;
        }
        
        @media print {
            body {
                background: white;
            }
            .container {
                box-shadow: none;
            }
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
    <div class="container">
        <h1>üìö Hash Tables Study Guide</h1>
        <p class="subtitle">CS210 - Week 13 - Comprehensive Reference</p>
        
        <div class="toc">
            <h3>üìñ Table of Contents</h3>
            <ul>
                <li><a href="#introduction">1. Introduction to Hash Tables</a></li>
                <li><a href="#basic-plan">2. Hashing: Basic Plan</a></li>
                <li><a href="#hash-functions">3. Hash Functions</a></li>
                <li><a href="#separate-chaining">4. Separate Chaining</a></li>
                <li><a href="#linear-probing">5. Linear Probing</a></li>
                <li><a href="#comparison">6. Performance Comparison</a></li>
                <li><a href="#advanced">7. Advanced Topics</a></li>
                <li><a href="#summary">8. Summary & Best Practices</a></li>
            </ul>
        </div>

        <!-- SECTION 1: INTRODUCTION -->
        <h2 id="introduction">1. Introduction to Hash Tables</h2>
        
        <div class="key-point">
            <h4>üéØ Main Concept</h4>
            <p>Hash tables provide <strong>constant-time</strong> average case performance for search, insert, and delete operations by using a hash function to compute an array index directly from the key.</p>
        </div>
        
        <h3>What is a Map?</h3>
        <p>A <strong>map</strong> is a data structure that models a searchable collection of key-value pairs, where:</p>
        <ul>
            <li>Keys are <strong>unique</strong> - no duplicate keys allowed</li>
            <li>Each key maps to exactly <strong>one value</strong></li>
            <li>Main operations: <code>get(key)</code>, <code>put(key, value)</code>, <code>remove(key)</code></li>
        </ul>
        
        <div class="example">
            <h4>Real-World Examples</h4>
            <ul>
                <li><strong>Address Book:</strong> Name (key) ‚Üí Phone Number (value)</li>
                <li><strong>Student Records:</strong> Student ID (key) ‚Üí Student Data (value)</li>
                <li><strong>Dictionary:</strong> Word (key) ‚Üí Definition (value)</li>
            </ul>
        </div>

        <!-- SECTION 2: BASIC PLAN -->
        <h2 id="basic-plan">2. Hashing: Basic Plan</h2>
        
        <h3>Core Idea</h3>
        <p>Save items in a <strong>key-indexed table</strong> where the index is computed as a function of the key.</p>
        
        <div class="info">
            <h4>üîë Key Components</h4>
            <ol>
                <li><strong>Hash Function:</strong> Method for computing array index from key</li>
                <li><strong>Equality Test:</strong> Method for checking if two keys are equal</li>
                <li><strong>Collision Resolution:</strong> Strategy for handling keys that hash to the same index</li>
            </ol>
        </div>
        
        <h3>The Space-Time Tradeoff</h3>
        <table>
            <tr>
                <th>Scenario</th>
                <th>Strategy</th>
                <th>Issue</th>
            </tr>
            <tr>
                <td>No space limitation</td>
                <td>Trivial hash function with key as index</td>
                <td>Wastes enormous amounts of memory</td>
            </tr>
            <tr>
                <td>No time limitation</td>
                <td>Sequential search through all items</td>
                <td>Very slow for large datasets</td>
            </tr>
            <tr>
                <td><strong>Real world</strong></td>
                <td><strong>Hashing with collision resolution</strong></td>
                <td><strong>Balance space and time efficiently</strong></td>
            </tr>
        </table>

        <!-- SECTION 3: HASH FUNCTIONS -->
        <h2 id="hash-functions">3. Hash Functions</h2>
        
        <div class="highlight">
            <h4>‚ö° Idealistic Goal</h4>
            <p>Scramble the keys <strong>uniformly</strong> to produce a table index that is:</p>
            <ul>
                <li><strong>Efficiently computable</strong></li>
                <li>Makes each table index <strong>equally likely</strong> for each key</li>
            </ul>
        </div>
        
        <h3>Computing Hash Codes</h3>
        
        <h4>For Integers</h4>
        <pre>public int hashCode() { 
    return value; 
}</pre>
        <p>Simply return the integer value itself.</p>
        
        <h4>For Booleans</h4>
        <pre>public int hashCode() {
    if (value) return 1231;
    else return 1237;
}</pre>
        <p>Use two different prime numbers for true and false.</p>
        
        <h4>For Doubles</h4>
        <pre>public int hashCode() {
    long bits = doubleToLongBits(value);
    return (int) (bits ^ (bits >>> 32));
}</pre>
        <p>Convert to 64-bit representation and XOR the two halves.</p>
        
        <h4>For Strings (Horner's Method)</h4>
        <pre>public int hashCode() {
    int hash = 0;
    for (int i = 0; i < length(); i++)
        hash = s[i] + (31 * hash);
    return hash;
}</pre>
        
        <div class="formula">
            h = s[0]¬∑31<sup>L-1</sup> + s[1]¬∑31<sup>L-2</sup> + ... + s[L-2]¬∑31 + s[L-1]
        </div>
        
        <div class="example">
            <h4>String Hash Example: "call"</h4>
            <pre>hash = 99¬∑31¬≥ + 97¬∑31¬≤ + 108¬∑31 + 108
     = 108 + 31¬∑(108 + 31¬∑(97 + 31¬∑99))
     = 3,045,982</pre>
        </div>
        
        <h3>Modular Hashing</h3>
        <p>Convert hash code (any 32-bit integer) to table index (0 to M-1):</p>
        
        <div class="comparison">
            <div class="comparison-item bad">
                <h4>‚ùå Bug Version</h4>
                <pre>private int hash(Key key) {
    return key.hashCode() % M;
}</pre>
                <p>Can return negative values!</p>
            </div>
            <div class="comparison-item good">
                <h4>‚úÖ Correct Version</h4>
                <pre>private int hash(Key key) {
    return (key.hashCode() & 0x7fffffff) % M;
}</pre>
                <p>Masks sign bit to ensure positive result</p>
            </div>
        </div>
        
        <h3>Uniform Hashing Assumption</h3>
        <div class="important">
            <p><strong>Key Assumption:</strong> Each key is equally likely to hash to an integer between 0 and M-1.</p>
            <p>This assumption is crucial for performance analysis but is difficult to achieve in practice.</p>
        </div>
        
        <h4>Birthday Problem & Load Balancing</h4>
        <ul>
            <li><strong>Birthday Problem:</strong> Expect two balls in same bin after ~‚àö(œÄM/2) tosses</li>
            <li><strong>Coupon Collector:</strong> Expect every bin has ‚â•1 ball after ~M ln M tosses</li>
            <li><strong>Load Balancing:</strong> After M tosses, most loaded bin has Œò(log M / log log M) balls</li>
        </ul>

        <!-- SECTION 4: SEPARATE CHAINING -->
        <h2 id="separate-chaining">4. Separate Chaining</h2>
        
        <div class="key-point">
            <h4>üí° Core Idea</h4>
            <p>Use an array of M &lt; N linked lists. Each array position points to a chain of items that hash to that index.</p>
        </div>
        
        <h3>How It Works</h3>
        <ol>
            <li><strong>Hash:</strong> Map key to integer i between 0 and M-1</li>
            <li><strong>Insert:</strong> Put at front of i<sup>th</sup> chain (if not already there)</li>
            <li><strong>Search:</strong> Search only the i<sup>th</sup> chain</li>
        </ol>
        
        <div class="visual">
            <h4>Visual Representation</h4>
            <pre>
Array Index          Linked List Chain
    0         ‚Üí     [A] ‚Üí [B] ‚Üí [E] ‚Üí null
    1         ‚Üí     null
    2         ‚Üí     [X] ‚Üí [S] ‚Üí null
    3         ‚Üí     null
    4         ‚Üí     [L] ‚Üí [P] ‚Üí null
    5         ‚Üí     [M] ‚Üí [H] ‚Üí [C] ‚Üí [R] ‚Üí null
            </pre>
        </div>
        
        <h3>Java Implementation</h3>
        <pre>public class SeparateChainingHashST&lt;Key, Value&gt; {
    private int M = 97;  // number of chains
    private Node[] st = new Node[M];  // array of chains
    
    private static class Node {
        private Object key;
        private Object val;
        private Node next;
    }
    
    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }
    
    public Value get(Key key) {
        int i = hash(key);
        for (Node x = st[i]; x != null; x = x.next)
            if (key.equals(x.key))
                return (Value) x.val;
        return null;
    }
    
    public void put(Key key, Value val) {
        int i = hash(key);
        for (Node x = st[i]; x != null; x = x.next)
            if (keys[i].equals(key)) { 
                x.val = val; 
                return; 
            }
        st[i] = new Node(key, val, st[i]);
    }
}</pre>
        
        <h3>Performance Analysis</h3>
        <div class="success">
            <h4>‚úÖ Proposition</h4>
            <p>Under uniform hashing assumption, the probability that the number of keys in a list is within a constant factor of N/M is extremely close to 1.</p>
        </div>
        
        <div class="formula">
            Average # of probes = N/M
        </div>
        
        <table>
            <tr>
                <th>Operation</th>
                <th>Average Case</th>
                <th>Worst Case</th>
            </tr>
            <tr>
                <td>Search Hit</td>
                <td>~3-5 probes</td>
                <td>N probes</td>
            </tr>
            <tr>
                <td>Search Miss</td>
                <td>~3-5 probes</td>
                <td>N probes</td>
            </tr>
            <tr>
                <td>Insert</td>
                <td>~3-5 probes</td>
                <td>N probes</td>
            </tr>
        </table>
        
        <h3>Resizing Strategy</h3>
        <div class="highlight">
            <p><strong>Goal:</strong> Keep average chain length N/M ‚âà constant</p>
            <ul>
                <li><strong>Double</strong> array size M when N/M ‚â• 8</li>
                <li><strong>Halve</strong> array size M when N/M ‚â§ 2</li>
                <li>Must <strong>rehash</strong> all keys when resizing (hash value changes!)</li>
            </ul>
        </div>

        <!-- SECTION 5: LINEAR PROBING -->
        <h2 id="linear-probing">5. Linear Probing</h2>
        
        <div class="key-point">
            <h4>üí° Core Idea (Open Addressing)</h4>
            <p>When a collision occurs, probe the next array position (i+1, i+2, ...) until an empty slot is found.</p>
        </div>
        
        <h3>How It Works</h3>
        <ol>
            <li><strong>Hash:</strong> Map key to integer i between 0 and M-1</li>
            <li><strong>Insert:</strong> Put at table index i if free; if not, try i+1, i+2, etc.</li>
            <li><strong>Search:</strong> Search table index i; if occupied but no match, try i+1, i+2, etc.</li>
        </ol>
        
        <div class="important">
            <p><strong>Critical:</strong> Array size M must be <em>greater than</em> number of key-value pairs N.</p>
        </div>
        
        <div class="visual">
            <h4>Visual Example</h4>
            <pre>
Index:  0   1   2   3   4   5   6   7   8   9   10  11  12  13  14  15
       [P] [M] [ ] [ ] [A] [C] [S] [H] [L] [ ] [E] [ ] [ ] [ ] [R] [X]

Insert K: hash(K) = 5
          Position 5 occupied ‚Üí try 6 ‚Üí occupied ‚Üí try 7 ‚Üí occupied
          ‚Üí try 8 ‚Üí occupied ‚Üí try 9 ‚Üí EMPTY! Insert at 9
            </pre>
        </div>
        
        <h3>Java Implementation</h3>
        <pre>public class LinearProbingHashST&lt;Key, Value&gt; {
    private int M = 30001;
    private Value[] vals = (Value[]) new Object[M];
    private Key[] keys = (Key[]) new Object[M];
    
    private int hash(Key key) {
        return (key.hashCode() & 0x7fffffff) % M;
    }
    
    public Value get(Key key) {
        for (int i = hash(key); keys[i] != null; i = (i+1) % M)
            if (key.equals(keys[i]))
                return vals[i];
        return null;
    }
    
    public void put(Key key, Value val) {
        int i;
        for (i = hash(key); keys[i] != null; i = (i+1) % M)
            if (keys[i].equals(key))
                break;
        keys[i] = key;
        vals[i] = val;
    }
}</pre>
        
        <h3>Knuth's Parking Problem</h3>
        <div class="info">
            <p><strong>Analogy:</strong> Cars arrive at one-way street with M parking spaces. Each wants random space i; if taken, try i+1, i+2, etc.</p>
            <ul>
                <li><strong>Half-full (M/2 cars):</strong> Mean displacement ‚âà 3/2</li>
                <li><strong>Full (M cars):</strong> Mean displacement ‚âà ‚àö(œÄM/8)</li>
            </ul>
        </div>
        
        <h3>Performance Analysis</h3>
        <div class="formula">
            <p><strong>Search Hit:</strong> ~¬Ω(1 + 1/(1-Œ±))</p>
            <p><strong>Search Miss/Insert:</strong> ~¬Ω(1 + 1/(1-Œ±)¬≤)</p>
            <p>where Œ± = N/M (load factor)</p>
        </div>
        
        <table>
            <tr>
                <th>Load Factor Œ±</th>
                <th>Search Hit</th>
                <th>Search Miss</th>
            </tr>
            <tr>
                <td>¬Ω</td>
                <td>~1.5</td>
                <td>~2.5</td>
            </tr>
            <tr>
                <td>‚Öî</td>
                <td>~2.0</td>
                <td>~5.0</td>
            </tr>
            <tr>
                <td>¬æ</td>
                <td>~3.0</td>
                <td>~8.5</td>
            </tr>
        </table>
        
        <div class="highlight">
            <h4>‚öôÔ∏è Typical Choice</h4>
            <p>Keep Œ± = N/M ‚âà ¬Ω for constant-time operations</p>
            <ul>
                <li><strong>Double</strong> size when N/M ‚â• ¬Ω</li>
                <li><strong>Halve</strong> size when N/M ‚â§ ‚Öõ</li>
            </ul>
        </div>
        
        <h3>Deletion in Linear Probing</h3>
        <div class="important">
            <h4>‚ö†Ô∏è Critical Issue</h4>
            <p>Cannot simply delete an entry and set it to null! This would break search for items that had collided with the deleted item.</p>
        </div>
        
        <p><strong>Solution:</strong> After deletion, must rehash all keys in the same cluster that comes after the deleted key.</p>

        <!-- SECTION 6: COMPARISON -->
        <h2 id="comparison">6. Performance Comparison</h2>
        
        <h3>Separate Chaining vs Linear Probing</h3>
        
        <div class="comparison">
            <div class="comparison-item good">
                <h4>‚úÖ Separate Chaining</h4>
                <ul>
                    <li>Performance degrades gracefully</li>
                    <li>Less sensitive to poorly-designed hash functions</li>
                    <li>Easy deletion</li>
                    <li>Can exceed load factor of 1</li>
                </ul>
            </div>
            <div class="comparison-item good">
                <h4>‚úÖ Linear Probing</h4>
                <ul>
                    <li>Less wasted space (no pointers)</li>
                    <li>Better cache performance</li>
                    <li>Simpler implementation</li>
                    <li>Faster when load factor is low</li>
                </ul>
            </div>
        </div>
        
        <h3>Complete Symbol Table Implementations Comparison</h3>
        <table>
            <tr>
                <th>Implementation</th>
                <th>Search</th>
                <th>Insert</th>
                <th>Delete</th>
                <th>Ordered?</th>
                <th>Key Interface</th>
            </tr>
            <tr>
                <td>Sequential Search</td>
                <td>N</td>
                <td>N</td>
                <td>N</td>
                <td>No</td>
                <td>equals()</td>
            </tr>
            <tr>
                <td>Binary Search</td>
                <td>lg N</td>
                <td>N</td>
                <td>N</td>
                <td>Yes</td>
                <td>compareTo()</td>
            </tr>
            <tr>
                <td>BST</td>
                <td>1.39 lg N</td>
                <td>1.39 lg N</td>
                <td>‚àöN</td>
                <td>Yes</td>
                <td>compareTo()</td>
            </tr>
            <tr>
                <td>Red-Black BST</td>
                <td>1.0 lg N</td>
                <td>1.0 lg N</td>
                <td>1.0 lg N</td>
                <td>Yes</td>
                <td>compareTo()</td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td><strong>Separate Chaining</strong></td>
                <td><strong>3-5*</strong></td>
                <td><strong>3-5*</strong></td>
                <td><strong>3-5*</strong></td>
                <td><strong>No</strong></td>
                <td><strong>equals(), hashCode()</strong></td>
            </tr>
            <tr style="background-color: #d4edda;">
                <td><strong>Linear Probing</strong></td>
                <td><strong>3-5*</strong></td>
                <td><strong>3-5*</strong></td>
                <td><strong>3-5*</strong></td>
                <td><strong>No</strong></td>
                <td><strong>equals(), hashCode()</strong></td>
            </tr>
        </table>
        <p style="font-size: 0.9em; color: #666;">* Under uniform hashing assumption</p>

        <!-- SECTION 7: ADVANCED TOPICS -->
        <h2 id="advanced">7. Advanced Topics</h2>
        
        <h3>Hash Function Variants</h3>
        
        <h4>Two-Probe Hashing</h4>
        <div class="info">
            <p>Hash to two positions and insert in the shorter chain.</p>
            <p><strong>Result:</strong> Reduces expected length of longest chain to log log N</p>
        </div>
        
        <h4>Double Hashing</h4>
        <div class="info">
            <p>Use linear probing but skip a variable amount (not just 1) each time.</p>
            <pre>h(x) = h1(x) + j¬∑h2(x)  where j = 0, 1, 2, ...</pre>
            <p><strong>Advantages:</strong> Effectively eliminates clustering, table can be nearly full</p>
        </div>
        
        <h4>Cuckoo Hashing</h4>
        <div class="info">
            <p>Hash key to two positions. If both occupied, displace one key and reinsert it.</p>
            <p><strong>Result:</strong> Constant worst-case time for search!</p>
        </div>
        
        <h3>Algorithmic Complexity Attacks</h3>
        <div class="important">
            <h4>üö® Security Concern</h4>
            <p>A malicious adversary who knows your hash function can craft inputs that all hash to the same bucket, causing performance to degrade to O(N).</p>
            <p><strong>Examples:</strong></p>
            <ul>
                <li>Denial-of-service attacks on web servers</li>
                <li>Bro server exploits</li>
                <li>Perl 5.8.0 associative array attacks</li>
            </ul>
        </div>
        
        <div class="example">
            <h4>Java String Hash Collision</h4>
            <p>Due to Java's base-31 hash function, it's possible to generate 2<sup>N</sup> strings of length 2N that all hash to the same value!</p>
            <pre>
"Aa" and "BB" both hash to 2112
"AaAa", "AaBB", "BBAa", "BBBB" all hash to -540425984
            </pre>
        </div>
        
        <h3>One-Way Hash Functions</h3>
        <div class="info">
            <h4>Cryptographic Hash Functions</h4>
            <p>Special hash functions where it's computationally infeasible to:</p>
            <ul>
                <li>Find a key that hashes to a specific value</li>
                <li>Find two keys that hash to the same value</li>
            </ul>
            <p><strong>Examples:</strong> SHA-256, SHA-3, BLAKE3</p>
            <p><strong>Uses:</strong> Password storage, digital signatures, blockchain</p>
            <p><strong>Note:</strong> Too expensive for general symbol table use</p>
        </div>

        <!-- SECTION 8: SUMMARY -->
        <h2 id="summary">8. Summary & Best Practices</h2>
        
        <div class="key-point">
            <h4>üéØ Key Takeaways</h4>
            <ul>
                <li>Hash tables provide <strong>constant-time</strong> average performance for search/insert/delete</li>
                <li>Require a good <strong>hash function</strong> and <strong>collision resolution</strong> strategy</li>
                <li>Two main approaches: <strong>Separate Chaining</strong> and <strong>Linear Probing</strong></li>
                <li>Performance depends on <strong>load factor Œ± = N/M</strong></li>
                <li>Uniform hashing assumption is critical but hard to achieve</li>
            </ul>
        </div>
        
        <h3>Best Practices</h3>
        
        <h4>‚úÖ DO:</h4>
        <ul>
            <li>Use prime numbers or powers of 2 for table size M</li>
            <li>Keep load factor Œ± between 0.5 and 0.75 for linear probing</li>
            <li>Keep load factor Œ± around 1-4 for separate chaining</li>
            <li>Implement proper <code>hashCode()</code> that uses all significant fields</li>
            <li>Ensure <code>equals()</code> and <code>hashCode()</code> are consistent</li>
            <li>Resize dynamically to maintain good performance</li>
        </ul>
        
        <h4>‚ùå DON'T:</h4>
        <ul>
            <li>Use predictable hash functions in security-critical applications</li>
            <li>Forget to handle the sign bit when converting hash codes to indices</li>
            <li>Directly delete entries in linear probing (must rehash cluster)</li>
            <li>Use hash tables if you need ordered operations (use BST instead)</li>
            <li>Assume uniform hashing without testing your hash function</li>
        </ul>
        
        <h3>When to Use What</h3>
        <table>
            <tr>
                <th>Use Case</th>
                <th>Best Choice</th>
                <th>Reason</th>
            </tr>
            <tr>
                <td>Need ordered operations</td>
                <td>Red-Black BST</td>
                <td>Hash tables don't maintain order</td>
            </tr>
            <tr>
                <td>Simple, fast lookups</td>
                <td>Hash Table (either variant)</td>
                <td>Constant-time average case</td>
            </tr>
            <tr>
                <td>Unpredictable load</td>
                <td>Separate Chaining</td>
                <td>Degrades gracefully</td>
            </tr>
            <tr>
                <td>Memory constrained</td>
                <td>Linear Probing</td>
                <td>No pointer overhead</td>
            </tr>
            <tr>
                <td>Cache-sensitive code</td>
                <td>Linear Probing</td>
                <td>Better locality of reference</td>
            </tr>
        </table>
        
        <h3>Common Pitfalls</h3>
        <div class="important">
            <ol>
                <li><strong>Hash Code Overflow:</strong> Forgetting to mask sign bit can cause negative indices</li>
                <li><strong>Poor Hash Functions:</strong> Using only part of the key leads to clustering</li>
                <li><strong>Inconsistent equals/hashCode:</strong> If a.equals(b) but a.hashCode() ‚â† b.hashCode(), table breaks</li>
                <li><strong>Ignoring Load Factor:</strong> Letting table get too full degrades performance</li>
                <li><strong>Security:</strong> Using predictable hash functions in adversarial environments</li>
            </ol>
        </div>
        
        <h3>Quick Reference: Hash Code Implementation</h3>
        <pre>// Template for user-defined types
public int hashCode() {
    int hash = 17;  // nonzero constant
    hash = 31 * hash + field1.hashCode();  // reference type
    hash = 31 * hash + ((Integer) field2).hashCode();  // primitive
    hash = 31 * hash + field3.hashCode();  // reference type
    return hash;
}</pre>
        
        <div class="success" style="margin-top: 40px; text-align: center;">
            <h3>üéì You're Ready!</h3>
            <p>You now have a comprehensive understanding of hash tables. Practice implementing both separate chaining and linear probing to solidify these concepts.</p>
        </div>
        
        <div style="margin-top: 40px; padding: 20px; background-color: #f8f9fa; border-radius: 5px; text-align: center; color: #666;">
            <p><em>Study Guide Created from CS210 Week 13 Materials</em></p>
            <p><em>Algorithms by Robert Sedgewick & Kevin Wayne</em></p>
        </div>
    </div>
</body>
</html>