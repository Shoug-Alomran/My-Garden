<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Study Guide: Trees Data Structure</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        h2 {
            color: #2c3e50;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #34495e;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #546e7a;
            font-size: 1.2em;
            margin: 15px 0 10px 0;
        }

        .definition {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #2196f3;
        }

        .key-point {
            background: #fff3e0;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ff9800;
        }

        .code-block {
            background: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
        }

        .algorithm {
            background: #f3e5f5;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #9c27b0;
        }

        ul, ol {
            margin-left: 30px;
            margin-top: 10px;
            margin-bottom: 10px;
        }

        li {
            margin: 8px 0;
        }

        .table-container {
            overflow-x: auto;
            margin: 20px 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        .example {
            background: #e8f5e9;
            padding: 20px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #4caf50;
        }

        .note {
            background: #ffebee;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
        }

        .formula {
            background: #fff9c4;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-family: 'Courier New', monospace;
            font-size: 1.1em;
            border: 2px solid #fbc02d;
        }

        .highlight {
            background: #ffeb3b;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        strong {
            color: #2c3e50;
        }

        .toc {
            background: #eceff1;
            padding: 25px;
            border-radius: 8px;
            margin-bottom: 30px;
        }

        .toc h2 {
            border-bottom: none;
            margin-bottom: 15px;
        }

        .toc ul {
            list-style: none;
            margin-left: 0;
        }

        .toc li {
            padding: 8px 0;
        }

        .toc a {
            color: #667eea;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }

        .toc a:hover {
            color: #764ba2;
        }

        @media print {
            body {
                background: white;
            }
            .container {
                box-shadow: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Complete Study Guide: Trees</h1>
            <p>Data Structures and Algorithms - CS210</p>
        </header>

        <div class="content">
            <div class="toc">
                <h2>üìã Table of Contents</h2>
                <ul>
                    <li><a href="#intro">1. Introduction to Trees</a></li>
                    <li><a href="#terminology">2. Tree Terminology</a></li>
                    <li><a href="#adt">3. Tree ADT</a></li>
                    <li><a href="#traversals">4. Tree Traversals</a></li>
                    <li><a href="#binary">5. Binary Trees</a></li>
                    <li><a href="#binary-traversals">6. Binary Tree Traversals</a></li>
                    <li><a href="#applications">7. Applications</a></li>
                    <li><a href="#implementation">8. Implementation</a></li>
                    <li><a href="#complexity">9. Complexity Analysis</a></li>
                </ul>
            </div>

            <!-- Section 1: Introduction -->
            <div class="section" id="intro">
                <h2>1. What is a Tree? üå≥</h2>
                
                <div class="definition">
                    <strong>Definition:</strong> In computer science, a tree is an abstract model of a hierarchical structure consisting of nodes with a parent-child relationship.
                </div>

                <h3>Key Characteristics</h3>
                <ul>
                    <li>Non-linear data structure (unlike arrays and linked lists)</li>
                    <li>Hierarchical organization of data</li>
                    <li>Each node can have multiple children</li>
                    <li>One root node at the top</li>
                    <li>No cycles (unlike graphs)</li>
                </ul>

                <h3>Real-World Applications</h3>
                <div class="example">
                    <strong>Common Uses:</strong>
                    <ul>
                        <li><strong>Organization Charts:</strong> Company hierarchy</li>
                        <li><strong>File Systems:</strong> Folders and files</li>
                        <li><strong>Programming Environments:</strong> Abstract syntax trees</li>
                        <li><strong>Database Indexing:</strong> B-trees and B+ trees</li>
                        <li><strong>Decision Making:</strong> Decision trees in AI</li>
                    </ul>
                </div>
            </div>

            <!-- Section 2: Terminology -->
            <div class="section" id="terminology">
                <h2>2. Tree Terminology üìñ</h2>

                <div class="key-point">
                    <h4>Essential Terms to Master:</h4>
                    
                    <p><strong class="highlight">Root:</strong> The topmost node without a parent (e.g., node A)</p>
                    
                    <p><strong class="highlight">Internal Node:</strong> A node with at least one child (nodes A, B, C, F)</p>
                    
                    <p><strong class="highlight">External Node (Leaf):</strong> A node without children (nodes E, I, J, K, G, H, D)</p>
                    
                    <p><strong class="highlight">Parent:</strong> A node that has one or more children</p>
                    
                    <p><strong class="highlight">Child:</strong> A node that has a parent</p>
                    
                    <p><strong class="highlight">Siblings:</strong> Nodes that share the same parent</p>
                    
                    <p><strong class="highlight">Ancestors:</strong> Parent, grandparent, great-grandparent, etc.</p>
                    
                    <p><strong class="highlight">Descendants:</strong> Child, grandchild, great-grandchild, etc.</p>
                    
                    <p><strong class="highlight">Depth of a Node:</strong> Number of ancestors (distance from root)</p>
                    
                    <p><strong class="highlight">Height of a Tree:</strong> Maximum depth of any node</p>
                    
                    <p><strong class="highlight">Subtree:</strong> A tree consisting of a node and all its descendants</p>
                </div>

                <div class="example">
                    <h4>Example Tree Structure:</h4>
                    <pre>
        A (depth 0, root)
       / \
      B   C (depth 1)
     / \   \
    E   F   G (depth 2)
       / \   \
      I   J   K (depth 3)
                    </pre>
                    <ul>
                        <li>Height of tree = 3</li>
                        <li>Internal nodes: A, B, C, F</li>
                        <li>Leaf nodes: E, I, J, G, K</li>
                        <li>Siblings: B and C; I and J</li>
                    </ul>
                </div>
            </div>

            <!-- Section 3: Tree ADT -->
            <div class="section" id="adt">
                <h2>3. Tree ADT (Abstract Data Type) üîß</h2>

                <div class="definition">
                    Trees use <strong>positions</strong> to abstract nodes. A position is a way to refer to a node without exposing its internal structure.
                </div>

                <h3>Generic Methods</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Description</th>
                                <th>Return Type</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>size()</td>
                                <td>Returns the number of nodes in the tree</td>
                                <td>integer</td>
                            </tr>
                            <tr>
                                <td>isEmpty()</td>
                                <td>Checks if tree is empty</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>iterator()</td>
                                <td>Returns an iterator over tree elements</td>
                                <td>Iterator</td>
                            </tr>
                            <tr>
                                <td>positions()</td>
                                <td>Returns an iterable collection of all positions</td>
                                <td>Iterable</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Accessor Methods</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Description</th>
                                <th>Return Type</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>root()</td>
                                <td>Returns the root position</td>
                                <td>Position</td>
                            </tr>
                            <tr>
                                <td>parent(p)</td>
                                <td>Returns the parent of position p</td>
                                <td>Position</td>
                            </tr>
                            <tr>
                                <td>children(p)</td>
                                <td>Returns an iterable of children of p</td>
                                <td>Iterable</td>
                            </tr>
                            <tr>
                                <td>numChildren(p)</td>
                                <td>Returns the number of children of p</td>
                                <td>Integer</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Query Methods</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Method</th>
                                <th>Description</th>
                                <th>Return Type</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>isInternal(p)</td>
                                <td>Checks if p has at least one child</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>isExternal(p)</td>
                                <td>Checks if p has no children (is a leaf)</td>
                                <td>boolean</td>
                            </tr>
                            <tr>
                                <td>isRoot(p)</td>
                                <td>Checks if p is the root</td>
                                <td>boolean</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Section 4: Tree Traversals -->
            <div class="section" id="traversals">
                <h2>4. Tree Traversals üö∂</h2>

                <div class="definition">
                    A <strong>traversal</strong> is a systematic way of visiting all nodes in a tree exactly once.
                </div>

                <h3>Preorder Traversal (NLR - Node, Left, Right)</h3>
                <div class="algorithm">
                    <h4>Algorithm:</h4>
                    <div class="code-block">
Algorithm preOrder(v)
    visit(v)                    // Visit node first
    for each child w of v
        preOrder(w)             // Then visit children
                    </div>
                    <p><strong>Visit Order:</strong> Root ‚Üí Left subtree ‚Üí Right subtree</p>
                    <p><strong>Application:</strong> Printing structured documents, creating a copy of the tree</p>
                </div>

                <h3>Postorder Traversal (LRN - Left, Right, Node)</h3>
                <div class="algorithm">
                    <h4>Algorithm:</h4>
                    <div class="code-block">
Algorithm postOrder(v)
    for each child w of v
        postOrder(w)            // Visit children first
    visit(v)                    // Then visit node
                    </div>
                    <p><strong>Visit Order:</strong> Left subtree ‚Üí Right subtree ‚Üí Root</p>
                    <p><strong>Application:</strong> Computing disk space, deleting a tree, evaluating expressions</p>
                </div>

                <div class="example">
                    <h4>Example:</h4>
                    <p>For the tree structure:</p>
                    <pre>
        A
       /|\
      B C D
                    </pre>
                    <ul>
                        <li><strong>Preorder:</strong> A, B, C, D</li>
                        <li><strong>Postorder:</strong> B, C, D, A</li>
                    </ul>
                </div>
            </div>

            <!-- Section 5: Binary Trees -->
            <div class="section" id="binary">
                <h2>5. Binary Trees üå≤</h2>

                <div class="definition">
                    A <strong>binary tree</strong> is a tree where each internal node has at most two children (exactly two for proper binary trees). The children are an ordered pair: left child and right child.
                </div>

                <h3>Properties of Binary Trees</h3>
                <ul>
                    <li>Each node has at most 2 children</li>
                    <li>Children are ordered (left vs right matters)</li>
                    <li>Can be empty</li>
                    <li>Recursive definition: A binary tree is either:
                        <ul>
                            <li>A tree with a single node, OR</li>
                            <li>A tree whose root has an ordered pair of children, each of which is a binary tree</li>
                        </ul>
                    </li>
                </ul>

                <h3>Properties of Proper Binary Trees</h3>
                <div class="key-point">
                    <h4>Important Formulas:</h4>
                    <p>Let: n = number of nodes, e = external nodes, i = internal nodes, h = height</p>
                    
                    <div class="formula">e = i + 1</div>
                    <p>Number of external nodes = internal nodes + 1</p>
                    
                    <div class="formula">n = 2e - 1</div>
                    <p>Total nodes = 2 √ó external nodes - 1</p>
                    
                    <div class="formula">h ‚â§ i</div>
                    <p>Height ‚â§ internal nodes</p>
                    
                    <div class="formula">h ‚â§ (n - 1)/2</div>
                    <p>Height ‚â§ (total nodes - 1)/2</p>
                    
                    <div class="formula">e ‚â§ 2<sup>h</sup></div>
                    <p>External nodes ‚â§ 2 to the power of height</p>
                    
                    <div class="formula">h ‚â• log‚ÇÇ(e)</div>
                    <p>Height ‚â• log base 2 of external nodes</p>
                </div>

                <h3>Binary Tree ADT</h3>
                <div class="key-point">
                    <p>The BinaryTree ADT extends the Tree ADT with additional methods:</p>
                    <ul>
                        <li><strong>left(p):</strong> Returns the left child of position p</li>
                        <li><strong>right(p):</strong> Returns the right child of position p</li>
                        <li><strong>sibling(p):</strong> Returns the sibling of position p</li>
                    </ul>
                    <p class="note">These methods return null when there is no left, right, or sibling.</p>
                </div>
            </div>

            <!-- Section 6: Binary Tree Traversals -->
            <div class="section" id="binary-traversals">
                <h2>6. Binary Tree Traversals üîÑ</h2>

                <h3>Inorder Traversal (LNR - Left, Node, Right)</h3>
                <div class="algorithm">
                    <h4>Algorithm:</h4>
                    <div class="code-block">
Algorithm inOrder(v)
    if left(v) ‚â† null
        inOrder(left(v))        // Visit left subtree
    visit(v)                    // Visit node
    if right(v) ‚â† null
        inOrder(right(v))       // Visit right subtree
                    </div>
                    <p><strong>Visit Order:</strong> Left subtree ‚Üí Node ‚Üí Right subtree</p>
                    <p><strong>Application:</strong> Drawing a binary tree, producing sorted output from BST</p>
                </div>

                <h3>Traversal Summary for Binary Trees</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Traversal Type</th>
                                <th>Order</th>
                                <th>Mnemonic</th>
                                <th>When to Use</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Preorder</strong></td>
                                <td>Node ‚Üí Left ‚Üí Right</td>
                                <td>NLR</td>
                                <td>Copy tree, prefix expressions</td>
                            </tr>
                            <tr>
                                <td><strong>Inorder</strong></td>
                                <td>Left ‚Üí Node ‚Üí Right</td>
                                <td>LNR</td>
                                <td>BST sorted output, infix expressions</td>
                            </tr>
                            <tr>
                                <td><strong>Postorder</strong></td>
                                <td>Left ‚Üí Right ‚Üí Node</td>
                                <td>LRN</td>
                                <td>Delete tree, postfix expressions</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <div class="example">
                    <h4>Complete Example:</h4>
                    <pre>
        A
       / \
      B   C
                    </pre>
                    <ul>
                        <li><strong>Inorder:</strong> B, A, C</li>
                        <li><strong>Preorder:</strong> A, B, C</li>
                        <li><strong>Postorder:</strong> B, C, A</li>
                    </ul>
                </div>

                <h3>Euler Tour Traversal</h3>
                <div class="definition">
                    A generic traversal that visits each node three times:
                    <ul>
                        <li><strong>On the left (L):</strong> Before processing left subtree (preorder)</li>
                        <li><strong>From below (B):</strong> Between left and right subtrees (inorder)</li>
                        <li><strong>On the right (R):</strong> After processing right subtree (postorder)</li>
                    </ul>
                    <p>Euler tour includes preorder, inorder, and postorder as special cases.</p>
                </div>
            </div>

            <!-- Section 7: Applications -->
            <div class="section" id="applications">
                <h2>7. Applications of Binary Trees üí°</h2>

                <h3>1. Arithmetic Expression Trees</h3>
                <div class="example">
                    <p><strong>Structure:</strong></p>
                    <ul>
                        <li>Internal nodes: operators (+, -, √ó, √∑)</li>
                        <li>External nodes: operands (numbers, variables)</li>
                    </ul>
                    
                    <p><strong>Example:</strong> (2 √ó (a - 1)) + (3 √ó b)</p>
                    <pre>
         +
        / \
       √ó   √ó
      / \ / \
     2  - 3  b
       / \
      a   1
                    </pre>
                    
                    <h4>Printing Expressions (Inorder):</h4>
                    <div class="code-block">
Algorithm printExpression(v)
    if left(v) ‚â† null
        print("(")
        inOrder(left(v))
    print(v.element())
    if right(v) ‚â† null
        inOrder(right(v))
        print(")")
                    </div>
                    <p>Output: ((2 √ó (a - 1)) + (3 √ó b))</p>

                    <h4>Evaluating Expressions (Postorder):</h4>
                    <div class="code-block">
Algorithm evalExpr(v)
    if isExternal(v)
        return v.element()
    else
        x ‚Üê evalExpr(left(v))
        y ‚Üê evalExpr(right(v))
        ‚óä ‚Üê operator stored at v
        return x ‚óä y
                    </div>
                </div>

                <h3>2. Decision Trees</h3>
                <div class="example">
                    <p><strong>Structure:</strong></p>
                    <ul>
                        <li>Internal nodes: questions with yes/no answers</li>
                        <li>External nodes: decisions/outcomes</li>
                    </ul>
                    <p><strong>Applications:</strong> Machine learning, game AI, diagnostic systems</p>
                </div>
            </div>

            <!-- Section 8: Implementation -->
            <div class="section" id="implementation">
                <h2>8. Tree Implementation Strategies üî®</h2>

                <h3>Linked Structure for Trees</h3>
                <div class="key-point">
                    <p><strong>Node Structure:</strong></p>
                    <ul>
                        <li>Element (data)</li>
                        <li>Reference to parent node</li>
                        <li>Sequence/list of children nodes</li>
                    </ul>
                    <p>This is the most flexible implementation for general trees.</p>
                </div>

                <h3>Linked Structure for Binary Trees</h3>
                <div class="key-point">
                    <p><strong>Node Structure (simpler than general trees):</strong></p>
                    <ul>
                        <li>Element (data)</li>
                        <li>Reference to parent node</li>
                        <li>Reference to left child</li>
                        <li>Reference to right child</li>
                    </ul>
                </div>

                <h3>Array-Based Representation</h3>
                <div class="algorithm">
                    <p><strong>Formula for node placement:</strong></p>
                    <ul>
                        <li>rank(root) = 0</li>
                        <li>If node is left child: rank(node) = 2 √ó rank(parent) + 1</li>
                        <li>If node is right child: rank(node) = 2 √ó rank(parent) + 2</li>
                    </ul>
                    
                    <div class="example">
                        <h4>Example Mapping:</h4>
                        <pre>
      A (0)
     / \
    B   D
   (1) (2)
   / \   \
  E   F   J
 (3) (4) (6)
                        </pre>
                        <p>Array: [A, B, D, E, F, _, J, ...]</p>
                        <p>Index: 0, 1, 2, 3, 4, 5, 6</p>
                    </div>

                    <div class="note">
                        <strong>Disadvantage:</strong> Can waste space for non-complete trees (many null entries).
                        <br>
                        <strong>Advantage:</strong> Fast access to parent and children using arithmetic.
                    </div>
                </div>
            </div>

            <!-- Section 9: Complexity -->
            <div class="section" id="complexity">
                <h2>9. Complexity Analysis ‚è±Ô∏è</h2>

                <h3>Linked Structure Implementation</h3>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Time Complexity</th>
                                <th>Explanation</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>size(), isEmpty()</td>
                                <td>O(1)</td>
                                <td>Stored as instance variable</td>
                            </tr>
                            <tr>
                                <td>root(), parent(), left(), right()</td>
                                <td>O(1)</td>
                                <td>Direct reference access</td>
                            </tr>
                            <tr>
                                <td>isInternal(), isExternal(), isRoot()</td>
                                <td>O(1)</td>
                                <td>Simple checks</td>
                            </tr>
                            <tr>
                                <td>iterator(), positions()</td>
                                <td>O(n)</td>
                                <td>Must visit all n nodes</td>
                            </tr>
                            <tr>
                                <td>replace()</td>
                                <td>O(1)</td>
                                <td>Direct update of element</td>
                            </tr>
                            <tr>
                                <td>children(p)</td>
                                <td>O(1)</td>
                                <td>Return reference to list</td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Traversal Complexity</h3>
                <div class="key-point">
                    <p><strong>All traversals (preorder, inorder, postorder):</strong> O(n)</p>
                    <ul>
                        <li>Each node is visited exactly once</li>
                        <li>Work done at each node is O(1)</li>
                        <li>Total time = n √ó O(1) = O(n)</li>
                    </ul>
                </div>

                <h3>Space Complexity</h3>
                <div class="key-point">
                    <ul>
                        <li><strong>Linked Structure:</strong> O(n) - one node object per element</li>
                        <li><strong>Array-Based:</strong> O(2<sup>h</sup>) - where h is height (can waste space)</li>
                        <li><strong>Recursive Traversal:</strong> O(h) - call stack depth equals height</li>
                    </ul>
                </div>
            </div>

            <!-- Summary Section -->
            <div class="section">
                <h2>üìå Key Takeaways</h2>
                
                <div class="key-point">
                    <h3>Essential Concepts:</h3>
                    <ol>
                        <li><strong>Trees are hierarchical:</strong> Root at top, leaves at bottom, parent-child relationships</li>
                        <li><strong>Three main traversals:</strong> Preorder (NLR), Inorder (LNR), Postorder (LRN)</li>
                        <li><strong>Binary trees are special:</strong> At most 2 children, ordered left and right</li>
                        <li><strong>Height matters:</strong> Determines efficiency of many operations</li>
                        <li><strong>Proper binary trees:</strong> e = i + 1 (external = internal + 1)</li>
                        <li><strong>Implementation choices:</strong> Linked (flexible) vs Array (compact for complete trees)</li>
                    </ol>
                </div>

                <div class="note">
                    <h3>Study Tips:</h3>
                    <ul>
                        <li>Practice drawing trees and performing traversals by hand</li>
                        <li>Memorize the formulas for proper binary trees</li>
                        <li>Understand when to use each traversal type</li>
                        <li>Know the time complexity of basic operations</li>
                        <li>Practice implementing tree operations recursively</li>
                    </ul>
                </div>
            </div>

        </div>
    </div>
</body>
</html>