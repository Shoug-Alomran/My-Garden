<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapter 6: Process Synchronization - CS330</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            background: #f4f4f4;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: white;
        }

        header {
            background: linear-gradient(135deg, #00c9ff 0%, #92fe9d 100%);
            color: white;
            padding: 40px;
            margin-bottom: 30px;
            text-align: center;
            border-radius: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }

        h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        h2 {
            color: #00c9ff;
            font-size: 1.8em;
            margin: 35px 0 20px 0;
            padding-bottom: 10px;
            border-bottom: 3px solid #92fe9d;
        }

        h3 {
            color: #00a8cc;
            font-size: 1.4em;
            margin: 25px 0 15px 0;
        }

        /* Critical Section Visualization */
        .critical-section-diagram {
            background: #f0f8ff;
            border: 2px solid #00c9ff;
            border-radius: 10px;
            padding: 30px;
            margin: 30px 0;
            text-align: center;
        }

        .process-structure {
            background: white;
            border: 2px solid #333;
            border-radius: 8px;
            padding: 20px;
            margin: 20px auto;
            max-width: 500px;
        }

        .section-block {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
            color: white;
        }

        .entry-section { background: #3498db; }
        .critical-section { background: #e74c3c; }
        .exit-section { background: #f39c12; }
        .remainder-section { background: #95a5a6; }

        /* Race Condition Example */
        .race-condition-box {
            background: #ffe5e5;
            border: 2px solid #ff6b6b;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        /* Synchronization Solutions Grid */
        .solutions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .solution-card {
            background: white;
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: transform 0.3s;
        }

        .solution-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }

        .solution-card h4 {
            color: #00c9ff;
            margin-bottom: 10px;
        }

        /* Code Blocks */
        .code-block {
            background: #2c3e50;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }

        .code-comment {
            color: #95a5a6;
        }

        .code-keyword {
            color: #3498db;
        }

        .code-function {
            color: #2ecc71;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        th {
            background: #00c9ff;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px 15px;
            border: 1px solid #ddd;
        }

        tr:nth-child(even) {
            background: #f8f9ff;
        }

        /* Concept Box */
        .concept-box {
            background: #e8fff8;
            border-left: 4px solid #00c9ff;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .highlight {
            background: #ffd700;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
        }

        /* Example Box */
        .example-box {
            background: #e8f8f5;
            border: 2px solid #27ae60;
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
        }

        /* Warning Box */
        .warning-box {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 20px 0;
        }

        /* Classical Problems */
        .problem-container {
            border: 2px solid #ddd;
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
            background: #f8f9ff;
        }

        .problem-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            margin: -20px -20px 20px -20px;
            border-radius: 8px 8px 0 0;
            text-align: center;
        }

        /* Dining Philosophers Visualization */
        .philosophers-table {
            width: 400px;
            height: 400px;
            margin: 30px auto;
            position: relative;
            background: #f0f8ff;
            border-radius: 50%;
            border: 3px solid #333;
        }

        .philosopher {
            position: absolute;
            width: 60px;
            height: 60px;
            background: #3498db;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
        }

        .chopstick {
            position: absolute;
            width: 4px;
            height: 80px;
            background: #8b4513;
            transform-origin: center bottom;
        }

        /* Bounded Buffer Visualization */
        .buffer-visualization {
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 30px 0;
        }

        .buffer-slot {
            width: 60px;
            height: 60px;
            border: 2px solid #333;
            margin: 0 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: white;
            font-weight: bold;
        }

        .buffer-slot.full {
            background: #3498db;
            color: white;
        }

        .buffer-slot.empty {
            background: #ecf0f1;
        }

        /* Semaphore Operations */
        .semaphore-box {
            background: #f0f8ff;
            border: 2px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        .operation-flow {
            display: flex;
            justify-content: space-around;
            align-items: center;
            margin: 20px 0;
        }

        .operation-step {
            background: white;
            border: 2px solid #ddd;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }

        .arrow {
            font-size: 30px;
            color: #333;
        }

        /* Monitor Visualization */
        .monitor-diagram {
            background: #fff8dc;
            border: 3px solid #ffd700;
            padding: 30px;
            margin: 30px 0;
            border-radius: 15px;
            text-align: center;
        }

        .monitor-box {
            background: white;
            border: 2px solid #333;
            padding: 20px;
            margin: 20px auto;
            max-width: 600px;
            border-radius: 10px;
        }

        /* Exam Section */
        .exam-section {
            background: #fff8dc;
            border: 2px solid #ffd700;
            padding: 25px;
            margin: 30px 0;
            border-radius: 10px;
        }

        .exam-question {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .mcq-options {
            list-style: none;
            margin-top: 15px;
        }

        .mcq-options li {
            background: #f8f9ff;
            padding: 10px;
            margin: 8px 0;
            border-radius: 5px;
            border-left: 3px solid transparent;
        }

        .correct-answer {
            background: #d4edda !important;
            border-left: 3px solid #28a745 !important;
        }

        /* Peterson's Solution */
        .peterson-box {
            background: #f5f3ff;
            border: 2px solid #9b59b6;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        /* Image Placeholder */
        .image-placeholder {
            background: #95a5a6;
            color: white;
            padding: 60px 20px;
            text-align: center;
            border-radius: 10px;
            margin: 20px 0;
            border: 2px dashed #7f8c8d;
        }

        /* Requirements List */
        .requirements-list {
            background: white;
            border: 2px solid #00c9ff;
            border-radius: 10px;
            padding: 0;
            margin: 20px 0;
            overflow: hidden;
        }

        .requirements-list li {
            padding: 15px;
            border-bottom: 1px solid #ddd;
            list-style: none;
        }

        .requirements-list li:last-child {
            border-bottom: none;
        }

        .requirements-list li:before {
            content: "‚úì";
            color: #27ae60;
            font-weight: bold;
            margin-right: 10px;
        }

        footer {
            background: #00c9ff;
            color: white;
            text-align: center;
            padding: 25px;
            margin-top: 40px;
            border-radius: 10px;
        }

        .subsection {
            margin-left: 20px;
            padding-left: 20px;
            border-left: 2px solid #ecf0f1;
        }

        /* Deadlock Visualization */
        .deadlock-diagram {
            background: #ffe5e5;
            border: 2px solid #e74c3c;
            padding: 20px;
            margin: 20px 0;
            border-radius: 10px;
        }

        /* Responsive Design */
        @media (max-width: 768px) {
            .solutions-grid {
                grid-template-columns: 1fr;
            }
            
            .operation-flow {
                flex-direction: column;
            }
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Chapter 6: Process Synchronization</h1>
            <p style="font-size: 1.2em;">CS330 - Operating Systems</p>
            <p>Critical Section, Semaphores, Classical Problems</p>
        </header>

        <!-- Section 1: Background -->
        <section>
            <h2>6.1 Background</h2>
            
            <div class="concept-box">
                <p>Concurrent access to shared data may result in data inconsistency. Maintaining data consistency requires mechanisms to ensure the orderly execution of cooperating processes.</p>
            </div>

            <h3>Cooperating Processes</h3>
            <div class="subsection">
                <p>Processes can execute concurrently and may be interrupted at any time, partially completing execution. Concurrent access to shared data may result in <span class="highlight">race conditions</span>.</p>
            </div>

            <h3>Race Condition</h3>
            <div class="race-condition-box">
                <h4>‚ö†Ô∏è Race Condition Definition:</h4>
                <p>A situation where several processes access and manipulate the same data concurrently, and the outcome depends on the particular order in which access takes place.</p>
                
                <div class="example-box">
                    <h4>Example: Counter Problem</h4>
                    <p>Suppose counter = 5</p>
                    <p>Producer executes: <code>counter++</code></p>
                    <p>Consumer executes: <code>counter--</code></p>
                    <p>Result could be: 4, 5, or 6!</p>
                </div>
            </div>

            <div class="code-block">
<span class="code-comment">// Race Condition Example</span>
<span class="code-comment">// Producer Process</span>
counter++; <span class="code-comment">// This is actually three machine instructions:</span>
           <span class="code-comment">// 1. register1 = counter</span>
           <span class="code-comment">// 2. register1 = register1 + 1</span>
           <span class="code-comment">// 3. counter = register1</span>

<span class="code-comment">// Consumer Process</span>
counter--; <span class="code-comment">// This is also three machine instructions:</span>
           <span class="code-comment">// 1. register2 = counter</span>
           <span class="code-comment">// 2. register2 = register2 - 1</span>
           <span class="code-comment">// 3. counter = register2</span>
            </div>
        </section>

        <!-- Section 2: Critical Section Problem -->
        <section>
            <h2>6.2 The Critical-Section Problem</h2>
            
            <div class="concept-box">
                <p>The <span class="highlight">Critical Section (CS)</span> is the part of process code that manipulates shared data or resources. Execution of the CS should be mutually exclusive.</p>
            </div>

            <div class="process-structure">
                <div class="section-block entry-section">Entry Section</div>
                <div class="section-block critical-section">CRITICAL SECTION</div>
                <div class="section-block exit-section">Exit Section</div>
                <div class="section-block remainder-section">Remainder Section</div>
            </div>

            <h3>Requirements for Solution</h3>
            <ul class="requirements-list">
                <li><strong>Mutual Exclusion:</strong> If process Pi is executing in its critical section, then no other processes can be executing in their critical sections.</li>
                <li><strong>Progress:</strong> If no process is executing in its critical section and some processes wish to enter, then only those not in their remainder section can participate in deciding who enters next, and this selection cannot be postponed indefinitely.</li>
                <li><strong>Bounded Waiting:</strong> A bound must exist on the number of times other processes are allowed to enter their critical sections after a process has made a request and before that request is granted. This prevents starvation.</li>
            </ul>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Important:</h4>
                <p>All three requirements must be satisfied for a correct solution to the critical section problem!</p>
            </div>
        </section>

        <!-- Section 3: Peterson's Solution -->
        <section>
            <h2>6.3 Peterson's Solution</h2>
            
            <div class="peterson-box">
                <h3>Two-Process Solution</h3>
                <p>Assumes that load and store instructions are atomic. Uses two shared variables:</p>
                <ul>
                    <li><code>int turn;</code> - Indicates whose turn it is to enter critical section</li>
                    <li><code>boolean flag[2];</code> - Indicates if a process is ready to enter critical section</li>
                </ul>
            </div>

            <div class="code-block">
<span class="code-comment">// Peterson's Solution for Process Pi</span>
<span class="code-keyword">do</span> {
    flag[i] = <span class="code-keyword">true</span>;
    turn = j;
    <span class="code-keyword">while</span> (flag[j] && turn == j)
        ; <span class="code-comment">// busy wait</span>
    
    <span class="code-comment">// CRITICAL SECTION</span>
    
    flag[i] = <span class="code-keyword">false</span>;
    
    <span class="code-comment">// REMAINDER SECTION</span>
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);
            </div>

            <div class="example-box">
                <h4>‚úÖ Proof that Peterson's Solution Works:</h4>
                <ul>
                    <li><strong>Mutual Exclusion:</strong> Both processes cannot be in CS simultaneously</li>
                    <li><strong>Progress:</strong> A process outside CS doesn't block others</li>
                    <li><strong>Bounded Waiting:</strong> Process waits at most one turn</li>
                </ul>
            </div>
        </section>

        <!-- Section 4: Hardware Solutions -->
        <section>
            <h2>6.4 Synchronization Hardware</h2>
            
            <div class="concept-box">
                <p>Many systems provide hardware support for critical section code. Modern machines provide special <span class="highlight">atomic hardware instructions</span>.</p>
            </div>

            <h3>Test and Set Instruction</h3>
            <div class="code-block">
<span class="code-keyword">boolean</span> <span class="code-function">test_and_set</span>(<span class="code-keyword">boolean</span> *target) {
    <span class="code-keyword">boolean</span> rv = *target;
    *target = <span class="code-keyword">true</span>;
    <span class="code-keyword">return</span> rv;
}

<span class="code-comment">// Solution using test_and_set()</span>
<span class="code-keyword">do</span> {
    <span class="code-keyword">while</span> (<span class="code-function">test_and_set</span>(&lock))
        ; <span class="code-comment">// busy wait</span>
    
    <span class="code-comment">// CRITICAL SECTION</span>
    
    lock = <span class="code-keyword">false</span>;
    
    <span class="code-comment">// REMAINDER SECTION</span>
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);
            </div>

            <h3>Compare and Swap Instruction</h3>
            <div class="code-block">
<span class="code-keyword">int</span> <span class="code-function">compare_and_swap</span>(<span class="code-keyword">int</span> *value, <span class="code-keyword">int</span> expected, <span class="code-keyword">int</span> new_value) {
    <span class="code-keyword">int</span> temp = *value;
    <span class="code-keyword">if</span> (*value == expected)
        *value = new_value;
    <span class="code-keyword">return</span> temp;
}
            </div>
        </section>

        <!-- Section 5: Mutex Locks -->
        <section>
            <h2>6.5 Mutex Locks</h2>
            
            <div class="concept-box">
                <p>Previous solutions are complicated for application programmers. OS designers build software tools to solve critical section problem. Simplest is <span class="highlight">mutex lock</span>.</p>
            </div>

            <div class="code-block">
<span class="code-comment">// Mutex Lock Usage</span>
<span class="code-function">acquire</span>() {
    <span class="code-keyword">while</span> (!available)
        ; <span class="code-comment">// busy wait</span>
    available = <span class="code-keyword">false</span>;
}

<span class="code-function">release</span>() {
    available = <span class="code-keyword">true</span>;
}

<span class="code-comment">// Process code</span>
<span class="code-keyword">do</span> {
    <span class="code-function">acquire</span>(lock);
    
    <span class="code-comment">// CRITICAL SECTION</span>
    
    <span class="code-function">release</span>(lock);
    
    <span class="code-comment">// REMAINDER SECTION</span>
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Spinlock Problem:</h4>
                <p>This implementation requires busy waiting. While a process is in its critical section, any other process trying to enter must loop continuously (spin). This wastes CPU cycles.</p>
            </div>
        </section>

        <!-- Section 6: Semaphores -->
        <section>
            <h2>6.6 Semaphores</h2>
            
            <div class="semaphore-box">
                <h3>Semaphore Definition</h3>
                <p>A synchronization tool that provides more sophisticated ways for processes to synchronize their activities.</p>
                <p>Semaphore S is an integer variable accessed only through two atomic operations:</p>
            </div>

            <div class="operation-flow">
                <div class="operation-step">
                    <h4>wait(S)</h4>
                    <code>S--;<br>if (S < 0)<br>&nbsp;&nbsp;block();</code>
                </div>
                <span class="arrow">‚Üî</span>
                <div class="operation-step">
                    <h4>signal(S)</h4>
                    <code>S++;<br>if (S <= 0)<br>&nbsp;&nbsp;wakeup();</code>
                </div>
            </div>

            <h3>Types of Semaphores</h3>
            <table>
                <tr>
                    <th>Type</th>
                    <th>Range</th>
                    <th>Usage</th>
                </tr>
                <tr>
                    <td><strong>Binary Semaphore</strong></td>
                    <td>0 or 1</td>
                    <td>Mutual exclusion (mutex)</td>
                </tr>
                <tr>
                    <td><strong>Counting Semaphore</strong></td>
                    <td>Unrestricted domain</td>
                    <td>Resource allocation with multiple instances</td>
                </tr>
            </table>

            <h3>Semaphore Implementation Without Busy Waiting</h3>
            <div class="code-block">
<span class="code-keyword">typedef struct</span> {
    <span class="code-keyword">int</span> value;
    <span class="code-keyword">struct</span> process *list;
} semaphore;

<span class="code-function">wait</span>(semaphore *S) {
    S->value--;
    <span class="code-keyword">if</span> (S->value < 0) {
        <span class="code-comment">// add this process to S->list</span>
        <span class="code-function">block</span>();
    }
}

<span class="code-function">signal</span>(semaphore *S) {
    S->value++;
    <span class="code-keyword">if</span> (S->value <= 0) {
        <span class="code-comment">// remove a process P from S->list</span>
        <span class="code-function">wakeup</span>(P);
    }
}
            </div>
        </section>

        <!-- Section 7: Classical Problems -->
        <section>
            <h2>6.7 Classic Problems of Synchronization</h2>
            
            <!-- Bounded Buffer Problem -->
            <div class="problem-container">
                <div class="problem-header">
                    <h3>1. Bounded-Buffer Problem</h3>
                </div>
                
                <div class="buffer-visualization">
                    <div class="buffer-slot full">Item</div>
                    <div class="buffer-slot full">Item</div>
                    <div class="buffer-slot empty">Empty</div>
                    <div class="buffer-slot empty">Empty</div>
                    <div class="buffer-slot empty">Empty</div>
                </div>

                <p><strong>Semaphores Used:</strong></p>
                <ul>
                    <li><code>mutex</code> - initialized to 1 (mutual exclusion)</li>
                    <li><code>full</code> - initialized to 0 (number of full buffers)</li>
                    <li><code>empty</code> - initialized to n (number of empty buffers)</li>
                </ul>

                <div class="code-block">
<span class="code-comment">// Producer Process</span>
<span class="code-keyword">do</span> {
    <span class="code-comment">// produce an item in next_produced</span>
    
    <span class="code-function">wait</span>(empty);
    <span class="code-function">wait</span>(mutex);
    
    <span class="code-comment">// add next_produced to buffer</span>
    
    <span class="code-function">signal</span>(mutex);
    <span class="code-function">signal</span>(full);
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);

<span class="code-comment">// Consumer Process</span>
<span class="code-keyword">do</span> {
    <span class="code-function">wait</span>(full);
    <span class="code-function">wait</span>(mutex);
    
    <span class="code-comment">// remove item from buffer to next_consumed</span>
    
    <span class="code-function">signal</span>(mutex);
    <span class="code-function">signal</span>(empty);
    
    <span class="code-comment">// consume item in next_consumed</span>
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);
                </div>
            </div>

            <!-- Readers-Writers Problem -->
            <div class="problem-container">
                <div class="problem-header">
                    <h3>2. Readers-Writers Problem</h3>
                </div>
                
                <p>A data set is shared among concurrent processes:</p>
                <ul>
                    <li><strong>Readers:</strong> Only read the data set; no updates</li>
                    <li><strong>Writers:</strong> Can both read and write</li>
                </ul>
                
                <p><strong>Problem:</strong> Allow multiple readers to read simultaneously. Only one writer can access shared data at a time.</p>
                
                <p><strong>Shared Data:</strong></p>
                <ul>
                    <li><code>rw_mutex</code> - initialized to 1 (common to readers/writers)</li>
                    <li><code>mutex</code> - initialized to 1 (protects read_count)</li>
                    <li><code>read_count</code> - initialized to 0 (number of readers)</li>
                </ul>

                <div class="code-block">
<span class="code-comment">// Writer Process</span>
<span class="code-keyword">do</span> {
    <span class="code-function">wait</span>(rw_mutex);
    
    <span class="code-comment">// WRITING is performed</span>
    
    <span class="code-function">signal</span>(rw_mutex);
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);

<span class="code-comment">// Reader Process</span>
<span class="code-keyword">do</span> {
    <span class="code-function">wait</span>(mutex);
    read_count++;
    <span class="code-keyword">if</span> (read_count == 1)
        <span class="code-function">wait</span>(rw_mutex);
    <span class="code-function">signal</span>(mutex);
    
    <span class="code-comment">// READING is performed</span>
    
    <span class="code-function">wait</span>(mutex);
    read_count--;
    <span class="code-keyword">if</span> (read_count == 0)
        <span class="code-function">signal</span>(rw_mutex);
    <span class="code-function">signal</span>(mutex);
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);
                </div>
            </div>

            <!-- Dining Philosophers Problem -->
            <div class="problem-container">
                <div class="problem-header">
                    <h3>3. Dining-Philosophers Problem</h3>
                </div>
                
                <div class="image-placeholder">
                    <h4>üçù Dining Philosophers Table</h4>
                    <p>[Insert diagram: 5 philosophers around table with rice bowl and chopsticks]</p>
                </div>
                
                <p><strong>Problem Description:</strong></p>
                <ul>
                    <li>5 philosophers who only eat and think</li>
                    <li>Each needs 2 chopsticks for eating</li>
                    <li>Only 5 chopsticks available</li>
                    <li>Illustrates difficulty of allocating resources without deadlock and starvation</li>
                </ul>

                <div class="code-block">
<span class="code-comment">// Simple Solution (may cause deadlock!)</span>
chopstick[5]; <span class="code-comment">// semaphores initialized to 1</span>

<span class="code-keyword">do</span> {
    <span class="code-function">wait</span>(chopstick[i]);
    <span class="code-function">wait</span>(chopstick[(i+1) % 5]);
    
    <span class="code-comment">// EAT</span>
    
    <span class="code-function">signal</span>(chopstick[i]);
    <span class="code-function">signal</span>(chopstick[(i+1) % 5]);
    
    <span class="code-comment">// THINK</span>
} <span class="code-keyword">while</span> (<span class="code-keyword">true</span>);

<span class="code-comment">// Problem: Deadlock if all pick up left chopstick!</span>
                </div>

                <div class="example-box">
                    <h4>Solutions to Prevent Deadlock:</h4>
                    <ul>
                        <li>Allow at most 4 philosophers at the table</li>
                        <li>Allow pickup only if both chopsticks available</li>
                        <li>Odd philosophers pick up left first, even pick up right first</li>
                    </ul>
                </div>
            </div>
        </section>

        <!-- Section 8: Monitors -->
        <section>
            <h2>6.8 Monitors</h2>
            
            <div class="monitor-diagram">
                <h3>Monitor Structure</h3>
                <div class="monitor-box">
                    <p><strong>Shared Data</strong></p>
                    <p>‚Üì</p>
                    <p><strong>Operations/Procedures</strong></p>
                    <p>‚Üì</p>
                    <p><strong>Initialization Code</strong></p>
                    <p>‚Üì</p>
                    <p><strong>Entry Queue</strong></p>
                </div>
            </div>

            <div class="concept-box">
                <p>A high-level abstraction that provides a convenient and effective mechanism for process synchronization. Only one process may be active within the monitor at a time.</p>
            </div>

            <h3>Monitor Solution for Dining Philosophers</h3>
            <div class="code-block">
<span class="code-keyword">monitor</span> DiningPhilosophers {
    <span class="code-keyword">enum</span> {THINKING, HUNGRY, EATING} state[5];
    condition self[5];
    
    <span class="code-keyword">void</span> <span class="code-function">pickup</span>(<span class="code-keyword">int</span> i) {
        state[i] = HUNGRY;
        <span class="code-function">test</span>(i);
        <span class="code-keyword">if</span> (state[i] != EATING)
            self[i].<span class="code-function">wait</span>();
    }
    
    <span class="code-keyword">void</span> <span class="code-function">putdown</span>(<span class="code-keyword">int</span> i) {
        state[i] = THINKING;
        <span class="code-function">test</span>((i + 4) % 5);
        <span class="code-function">test</span>((i + 1) % 5);
    }
    
    <span class="code-keyword">void</span> <span class="code-function">test</span>(<span class="code-keyword">int</span> i) {
        <span class="code-keyword">if</span> ((state[(i+4)%5] != EATING) &&
            (state[i] == HUNGRY) &&
            (state[(i+1)%5] != EATING)) {
            state[i] = EATING;
            self[i].<span class="code-function">signal</span>();
        }
    }
}
            </div>
        </section>

        <!-- Section 9: Deadlock and Starvation -->
        <section>
            <h2>6.9 Deadlock and Starvation</h2>
            
            <div class="deadlock-diagram">
                <h3>‚ö†Ô∏è Deadlock Example</h3>
                <p>Two or more processes waiting indefinitely for an event that can be caused only by one of the waiting processes.</p>
                
                <div class="code-block">
<span class="code-comment">// Deadlock Example with Two Semaphores</span>
Semaphore S = 1, Q = 1;

<span class="code-comment">// Process P0</span>        <span class="code-comment">// Process P1</span>
<span class="code-function">wait</span>(S);           <span class="code-function">wait</span>(Q);
<span class="code-function">wait</span>(Q);           <span class="code-function">wait</span>(S);
   ...                ...
<span class="code-function">signal</span>(S);         <span class="code-function">signal</span>(Q);
<span class="code-function">signal</span>(Q);         <span class="code-function">signal</span>(S);
                </div>
                <p>P0 waits for Q (held by P1), P1 waits for S (held by P0) ‚Üí <strong>DEADLOCK!</strong></p>
            </div>

            <div class="warning-box">
                <h4>‚ö†Ô∏è Starvation</h4>
                <p>Indefinite blocking. A process may never be removed from the semaphore queue in which it is suspended.</p>
            </div>

            <h3>Priority Inversion</h3>
            <div class="concept-box">
                <p>A high-priority process is indirectly preempted by a lower-priority process that holds a lock needed by the high-priority process.</p>
                <p><strong>Solution:</strong> Priority-inheritance protocol</p>
            </div>
        </section>

        <!-- Section 10: Practice Problems -->
        <section>
            <h2>6.10 Practice Problems and Exam Questions</h2>
            
            <div class="exam-section">
                <h3>Multiple Choice Questions</h3>
                
                <div class="exam-question">
                    <p><strong>Q1.</strong> A situation where several processes access the same data concurrently and the outcome depends on the order of access is called:</p>
                    <ul class="mcq-options">
                        <li>a) Dynamic condition</li>
                        <li class="correct-answer">b) Race condition</li>
                        <li>c) Essential condition</li>
                        <li>d) Critical condition</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q2.</strong> What is the correct order of operations for protecting a critical section using a binary semaphore?</p>
                    <ul class="mcq-options">
                        <li>a) release() followed by acquire()</li>
                        <li>b) acquire() followed by release()</li>
                        <li class="correct-answer">c) wait() followed by signal()</li>
                        <li>d) signal() followed by wait()</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q3.</strong> Mutual exclusion can be provided by:</p>
                    <ul class="mcq-options">
                        <li>a) Spinlocks</li>
                        <li>b) Mutex locks</li>
                        <li>c) Both (a) and (b)</li>
                        <li class="correct-answer">d) Both (a) and (b)</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q4.</strong> Which of these does NOT satisfy the critical section requirements?</p>
                    <ul class="mcq-options">
                        <li>a) Mutual Exclusion</li>
                        <li>b) Progress</li>
                        <li>c) Bounded Wait</li>
                        <li class="correct-answer">d) All satisfy the requirements</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q5.</strong> The bounded buffer problem is also known as:</p>
                    <ul class="mcq-options">
                        <li>a) Readers-Writers problem</li>
                        <li>b) Dining Philosophers problem</li>
                        <li class="correct-answer">c) Producer-Consumer problem</li>
                        <li>d) None of the mentioned</li>
                    </ul>
                </div>

                <div class="exam-question">
                    <p><strong>Q6.</strong> In the dining philosophers problem, deadlock occurs when:</p>
                    <ul class="mcq-options">
                        <li class="correct-answer">a) All 5 philosophers pick up their left chopstick</li>
                        <li>b) 4 philosophers pick up chopsticks</li>
                        <li>c) 3 philosophers pick up chopsticks</li>
                        <li>d) 6 philosophers pick up chopsticks</li>
                    </ul>
                </div>

                <h3>Short Answer Questions</h3>
                
                <div class="exam-question">
                    <p><strong>Q7.</strong> Given two concurrent programs that use semaphores S1 (init=1) and S2 (init=0):</p>
                    <div class="code-block">
Process P1:            Process P2:
Sem S1=1;             Sem S1=1;
Sem S2=0;             Sem S2=0;
                      
while(True) {         while(True) {
  wait(S2);             wait(S1);
  print("A");           print("B");
  signal(S1);           signal(S2);
}                     }
                    </div>
                    <p><strong>What will be the output pattern?</strong></p>
                    <div class="example-box">
                        <h4>Answer:</h4>
                        <p>P1 will be blocked initially on wait(S2). P2 executes wait(S1), prints "B", then signals S2. P1 can now proceed, prints "A", signals S1. Pattern: <strong>BABA...</strong></p>
                    </div>
                </div>

                <div class="exam-question">
                    <p><strong>Q8.</strong> A shared variable mutex is initialized to 1. Each process executes wait(mutex) before entering CS and signal(mutex) after. What happens if a process replaces signal(mutex) with wait(mutex)?</p>
                    <div class="example-box">
                        <h4>Answer:</h4>
                        <p><strong>Deadlock will occur.</strong> After the first process enters and exits its CS, it will execute wait(mutex) again, making mutex = -1. No process can enter CS again.</p>
                    </div>
                </div>

                <div class="exam-question">
                    <p><strong>Q9.</strong> What are the three requirements for a solution to the critical section problem?</p>
                    <div class="example-box">
                        <h4>Answer:</h4>
                        <ol>
                            <li><strong>Mutual Exclusion:</strong> Only one process in CS at a time</li>
                            <li><strong>Progress:</strong> Selection of next process cannot be postponed indefinitely</li>
                            <li><strong>Bounded Waiting:</strong> Limit on times others enter CS after request</li>
                        </ol>
                    </div>
                </div>
            </div>
        </section>

        <!-- Section 11: Key Terms -->
        <section>
            <h2>6.11 Key Terms and Definitions</h2>
            
            <table>
                <tr>
                    <th>Term</th>
                    <th>Definition</th>
                </tr>
                <tr>
                    <td><strong>Race Condition</strong></td>
                    <td>Outcome depends on order of process execution</td>
                </tr>
                <tr>
                    <td><strong>Critical Section</strong></td>
                    <td>Code segment that accesses shared data</td>
                </tr>
                <tr>
                    <td><strong>Mutual Exclusion</strong></td>
                    <td>Only one process in CS at a time</td>
                </tr>
                <tr>
                    <td><strong>Semaphore</strong></td>
                    <td>Integer variable with atomic wait/signal operations</td>
                </tr>
                <tr>
                    <td><strong>Mutex</strong></td>
                    <td>Binary semaphore for mutual exclusion</td>
                </tr>
                <tr>
                    <td><strong>Spinlock</strong></td>
                    <td>Lock that uses busy waiting</td>
                </tr>
                <tr>
                    <td><strong>Deadlock</strong></td>
                    <td>Processes waiting indefinitely for each other</td>
                </tr>
                <tr>
                    <td><strong>Starvation</strong></td>
                    <td>Process never gets resources</td>
                </tr>
                <tr>
                    <td><strong>Monitor</strong></td>
                    <td>High-level synchronization construct</td>
                </tr>
                <tr>
                    <td><strong>Atomic Operation</strong></td>
                    <td>Operation that completes without interruption</td>
                </tr>
                <tr>
                    <td><strong>Busy Waiting</strong></td>
                    <td>Continuously testing a condition</td>
                </tr>
                <tr>
                    <td><strong>Priority Inversion</strong></td>
                    <td>Low priority process blocks high priority</td>
                </tr>
            </table>
        </section>

        <!-- Image Placeholders -->
        <section>
            <h2>6.12 Diagrams from Slides</h2>
            
            <div class="image-placeholder">
                <h4>üìä Race Condition Illustration</h4>
                <p>[Insert diagram showing concurrent access to shared counter]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Dining Philosophers Table</h4>
                <p>[Insert diagram from Chapter_6.pdf showing 5 philosophers with chopsticks]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Monitor Structure</h4>
                <p>[Insert monitor schematic diagram]</p>
            </div>

            <div class="image-placeholder">
                <h4>üìä Producer-Consumer Buffer</h4>
                <p>[Insert bounded buffer visualization]</p>
            </div>

            <div class="warning-box">
                <p><strong>Note:</strong> Please provide the actual diagrams from your Chapter_6.pdf slides to replace these placeholders.</p>
            </div>
        </section>

        <footer>
            <p>CS330 - Operating Systems</p>
            <p>Chapter 6: Process Synchronization</p>
            <p><strong>Created by: Shoug Alomran</strong></p>
        </footer>
    </div>
</body>
</html>