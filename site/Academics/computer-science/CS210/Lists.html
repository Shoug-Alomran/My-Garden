<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS210 - Lists, Arrays & Iterators Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }
        
        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }
        
        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        
        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .nav {
            background: #f8f9fa;
            padding: 20px;
            border-bottom: 3px solid #667eea;
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 15px;
        }
        
        .nav a {
            color: #667eea;
            text-decoration: none;
            padding: 10px 20px;
            border-radius: 25px;
            background: white;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .nav a:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }
        
        .content {
            padding: 40px;
        }
        
        section {
            margin-bottom: 50px;
            scroll-margin-top: 80px;
        }
        
        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }
        
        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }
        
        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }
        
        .card {
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .definition {
            background: linear-gradient(to right, #e3f2fd, #f3e5f5);
            border-left: 4px solid #2196F3;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .important {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .example {
            background: #d4edda;
            border-left: 4px solid #28a745;
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 5px;
            margin: 15px 0;
            overflow-x: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }
        
        .keyword {
            color: #ff79c6;
            font-weight: bold;
        }
        
        .type {
            color: #8be9fd;
        }
        
        .string {
            color: #f1fa8c;
        }
        
        .comment {
            color: #6272a4;
            font-style: italic;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
        }
        
        td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }
        
        tr:nth-child(even) {
            background: #f8f9fa;
        }
        
        tr:hover {
            background: #e3f2fd;
        }
        
        .complexity {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 15px;
            font-weight: bold;
            font-size: 0.9em;
        }
        
        .o-1 {
            background: #d4edda;
            color: #155724;
        }
        
        .o-n {
            background: #fff3cd;
            color: #856404;
        }
        
        .o-n2 {
            background: #f8d7da;
            color: #721c24;
        }
        
        ul, ol {
            margin-left: 30px;
            margin-bottom: 15px;
        }
        
        li {
            margin: 8px 0;
        }
        
        .visual {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .visual-title {
            font-weight: bold;
            margin-bottom: 15px;
            color: #667eea;
        }
        
        .array-visual {
            display: flex;
            justify-content: center;
            gap: 2px;
            margin: 20px 0;
        }
        
        .array-cell {
            width: 60px;
            height: 60px;
            border: 2px solid #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: white;
        }
        
        .array-index {
            font-size: 0.8em;
            color: #666;
            margin-top: 5px;
        }
        
        .comparison-table {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        
        .comparison-card {
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .array-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .list-card {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        
        footer {
            background: #2d2d2d;
            color: white;
            text-align: center;
            padding: 20px;
        }
        
        @media (max-width: 768px) {
            .comparison-table {
                grid-template-columns: 1fr;
            }
            
            .nav ul {
                flex-direction: column;
            }
            
            header h1 {
                font-size: 1.8em;
            }
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö CS210 - Data Structures</h1>
            <p>Comprehensive Study Guide: Lists, Arrays & Iterators</p>
        </header>
        
        <nav class="nav">
            <ul>
                <li><a href="#arrays">Arrays</a></li>
                <li><a href="#singly-linked">Singly Linked Lists</a></li>
                <li><a href="#doubly-linked">Doubly Linked Lists</a></li>
                <li><a href="#array-lists">Array Lists</a></li>
                <li><a href="#positional">Positional Lists</a></li>
                <li><a href="#iterators">Iterators</a></li>
            </ul>
        </nav>
        
        <div class="content">
            <!-- ARRAYS SECTION -->
            <section id="arrays">
                <h2>üìä Arrays</h2>
                
                <div class="definition">
                    <h3>Definition</h3>
                    <p><strong>An array</strong> is a sequenced collection of variables all of the same type. Each variable, or <strong>cell</strong>, in an array has an <strong>index</strong>, which uniquely refers to the value stored in that cell.</p>
                    <p>The cells of an array A are numbered 0, 1, 2, and so on.</p>
                </div>
                
                <div class="visual">
                    <div class="visual-title">Array Structure</div>
                    <div class="array-visual">
                        <div>
                            <div class="array-cell">A</div>
                            <div class="array-index">0</div>
                        </div>
                        <div>
                            <div class="array-cell">B</div>
                            <div class="array-index">1</div>
                        </div>
                        <div>
                            <div class="array-cell">C</div>
                            <div class="array-index">2</div>
                        </div>
                        <div>
                            <div class="array-cell">...</div>
                            <div class="array-index">i</div>
                        </div>
                        <div>
                            <div class="array-cell">Z</div>
                            <div class="array-index">n</div>
                        </div>
                    </div>
                </div>
                
                <h3>Key Concepts</h3>
                <div class="card">
                    <h4>üîë Array Length and Capacity</h4>
                    <ul>
                        <li><strong>Length/Capacity:</strong> The maximum number of elements that can be stored in the array</li>
                        <li>In Java: accessed using <code>a.length</code></li>
                        <li>Cells are numbered from <code>0</code> to <code>a.length - 1</code></li>
                        <li>Access cell with index k: <code>a[k]</code></li>
                    </ul>
                </div>
                
                <h3>Declaring Arrays</h3>
                
                <h4>Method 1: Literal Form</h4>
                <div class="code-block">
<span class="type">elementType</span>[] <span class="type">arrayName</span> = {<span class="type">initialValue‚ÇÄ</span>, <span class="type">initialValue‚ÇÅ</span>, ..., <span class="type">initialValue‚Çô‚Çã‚ÇÅ</span>};

<span class="comment">// Example:</span>
<span class="keyword">int</span>[] a = {<span class="string">5</span>, <span class="string">7</span>, <span class="string">9</span>, <span class="string">10</span>};
                </div>
                
                <h4>Method 2: Using 'new' Operator</h4>
                <div class="code-block">
<span class="keyword">new</span> <span class="type">elementType</span>[<span class="type">length</span>]

<span class="comment">// Example:</span>
<span class="keyword">int</span>[] numbers = <span class="keyword">new int</span>[<span class="string">10</span>];
<span class="type">String</span>[] names = <span class="keyword">new</span> <span class="type">String</span>[<span class="string">3</span>];
                </div>
                
                <h3>Array Operations</h3>
                
                <div class="card">
                    <h4>‚úèÔ∏è Adding an Entry at Index i</h4>
                    <p><strong>Process:</strong> To add entry e at index i, shift forward the n - i entries from board[i] to board[n-1]</p>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-n">O(n)</span> in worst case (when i = 0)</p>
                    
                    <div class="code-block">
<span class="comment">// Pseudocode for adding at index i</span>
<span class="keyword">for</span> (j = n-<span class="string">1</span>; j >= i; j--)
    board[j+<span class="string">1</span>] = board[j];
board[i] = e;
size++;
                    </div>
                </div>
                
                <div class="card">
                    <h4>üóëÔ∏è Removing an Entry at Index i</h4>
                    <p><strong>Process:</strong> To remove entry at index i, shift backward the n - i - 1 entries from board[i+1] to board[n-1]</p>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-n">O(n)</span> in worst case (when i = 0)</p>
                    
                    <div class="code-block">
<span class="comment">// Pseudocode for removing at index i</span>
<span class="keyword">for</span> (j = i; j < size-<span class="string">1</span>; j++)
    board[j] = board[j+<span class="string">1</span>];
board[size-<span class="string">1</span>] = <span class="keyword">null</span>;
size--;
                    </div>
                </div>
                
                <h3>Performance Summary</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Time Complexity</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Access element at index i</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>Direct access via a[i]</td>
                        </tr>
                        <tr>
                            <td>Insert at index i</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td>Need to shift elements</td>
                        </tr>
                        <tr>
                            <td>Remove at index i</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td>Need to shift elements</td>
                        </tr>
                        <tr>
                            <td>Search for element</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td>Must check each element</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <!-- SINGLY LINKED LISTS SECTION -->
            <section id="singly-linked">
                <h2>üîó Singly Linked Lists</h2>
                
                <div class="definition">
                    <h3>Definition</h3>
                    <p><strong>A singly linked list</strong> is a concrete data structure consisting of a sequence of nodes, starting from a head pointer. Each node stores:</p>
                    <ul>
                        <li>An <strong>element</strong> (the data)</li>
                        <li>A <strong>link to the next node</strong></li>
                    </ul>
                    <p>The last node's link points to null.</p>
                </div>
                
                <div class="important">
                    <h4>‚ö†Ô∏è Key Characteristics</h4>
                    <ul>
                        <li>Can only move <strong>forward</strong> through the list</li>
                        <li>Each node has a reference to the <strong>next</strong> node only</li>
                        <li>The last node points to <strong>null</strong></li>
                        <li>Requires a <strong>head</strong> pointer to access the list</li>
                        <li>Often includes a <strong>tail</strong> pointer for efficient insertion at end</li>
                    </ul>
                </div>
                
                <h3>Node Class Implementation</h3>
                <div class="code-block">
<span class="keyword">private static class</span> <span class="type">Node</span>&lt;E&gt; {
    <span class="keyword">private</span> E element;           <span class="comment">// reference to element</span>
    <span class="keyword">private</span> <span class="type">Node</span>&lt;E&gt; next;       <span class="comment">// reference to next node</span>
    
    <span class="keyword">public</span> <span class="type">Node</span>(E e, <span class="type">Node</span>&lt;E&gt; n) {
        element = e;
        next = n;
    }
    
    <span class="keyword">public</span> E getElement() { <span class="keyword">return</span> element; }
    <span class="keyword">public</span> <span class="type">Node</span>&lt;E&gt; getNext() { <span class="keyword">return</span> next; }
    <span class="keyword">public void</span> setNext(<span class="type">Node</span>&lt;E&gt; n) { next = n; }
}
                </div>
                
                <h3>Basic Operations</h3>
                
                <div class="card">
                    <h4>‚ûï Inserting at the Head</h4>
                    <p><strong>Steps:</strong></p>
                    <ol>
                        <li>Allocate a new node</li>
                        <li>Insert new element</li>
                        <li>Have new node point to old head</li>
                        <li>Update head to point to new node</li>
                    </ol>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-1">O(1)</span></p>
                    
                    <div class="code-block">
<span class="keyword">public void</span> addFirst(E element) {
    head = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(element, head);
    size++;
    <span class="keyword">if</span> (size == <span class="string">1</span>)
        tail = head;  <span class="comment">// special case: new node becomes tail</span>
}
                    </div>
                </div>
                
                <div class="card">
                    <h4>‚ûï Inserting at the Tail</h4>
                    <p><strong>Steps:</strong></p>
                    <ol>
                        <li>Allocate a new node</li>
                        <li>Insert new element</li>
                        <li>Have new node point to null</li>
                        <li>Have old last node point to new node</li>
                        <li>Update tail to point to new node</li>
                    </ol>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-1">O(1)</span></p>
                    
                    <div class="code-block">
<span class="keyword">public void</span> addLast(E element) {
    <span class="type">Node</span>&lt;E&gt; newest = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(element, <span class="keyword">null</span>);
    <span class="keyword">if</span> (isEmpty())
        head = newest;
    <span class="keyword">else</span>
        tail.setNext(newest);
    tail = newest;
    size++;
}
                    </div>
                </div>
                
                <div class="card">
                    <h4>‚ûñ Removing at the Head</h4>
                    <p><strong>Steps:</strong></p>
                    <ol>
                        <li>Update head to point to next node</li>
                        <li>Allow garbage collector to reclaim the former first node</li>
                    </ol>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-1">O(1)</span></p>
                    
                    <div class="code-block">
<span class="keyword">public</span> E removeFirst() {
    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return null</span>;
    E answer = head.getElement();
    head = head.getNext();
    size--;
    <span class="keyword">if</span> (size == <span class="string">0</span>)
        tail = <span class="keyword">null</span>;  <span class="comment">// list is now empty</span>
    <span class="keyword">return</span> answer;
}
                    </div>
                </div>
                
                <div class="important">
                    <h4>‚ö†Ô∏è Removing at the Tail - NOT EFFICIENT!</h4>
                    <p>Removing at the tail of a singly linked list is <strong>not efficient</strong> because:</p>
                    <ul>
                        <li>There is no constant-time way to update the tail to point to the previous node</li>
                        <li>We would need to traverse the entire list to find the second-to-last node</li>
                        <li><strong>Time Complexity:</strong> <span class="complexity o-n">O(n)</span></li>
                    </ul>
                </div>
                
                <h3>Performance Summary</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Time Complexity</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Insert at head</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>Just update head pointer</td>
                        </tr>
                        <tr>
                            <td>Insert at tail</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>With tail pointer</td>
                        </tr>
                        <tr>
                            <td>Remove at head</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>Just update head pointer</td>
                        </tr>
                        <tr>
                            <td>Remove at tail</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td>Must traverse to find previous node</td>
                        </tr>
                        <tr>
                            <td>Access element at index i</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td>Must traverse from head</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <!-- DOUBLY LINKED LISTS SECTION -->
            <section id="doubly-linked">
                <h2>üîóüîó Doubly Linked Lists</h2>
                
                <div class="definition">
                    <h3>Definition</h3>
                    <p><strong>A doubly linked list</strong> provides a more versatile data structure that can be traversed forward and backward. Each node stores:</p>
                    <ul>
                        <li>An <strong>element</strong> (the data)</li>
                        <li>A <strong>link to the previous node</strong></li>
                        <li>A <strong>link to the next node</strong></li>
                    </ul>
                    <p>Uses special <strong>header</strong> and <strong>trailer</strong> sentinel nodes (with no data).</p>
                </div>
                
                <div class="important">
                    <h4>‚ö†Ô∏è Key Advantages over Singly Linked Lists</h4>
                    <ul>
                        <li>Can traverse <strong>both forward and backward</strong></li>
                        <li>Can efficiently <strong>remove at the tail</strong> - <span class="complexity o-1">O(1)</span></li>
                        <li>Can efficiently <strong>insert before a given node</strong></li>
                        <li>Easier to implement certain operations</li>
                    </ul>
                </div>
                
                <h3>Node Class Implementation</h3>
                <div class="code-block">
<span class="keyword">private static class</span> <span class="type">Node</span>&lt;E&gt; {
    <span class="keyword">private</span> E element;           <span class="comment">// reference to element</span>
    <span class="keyword">private</span> <span class="type">Node</span>&lt;E&gt; prev;       <span class="comment">// reference to previous node</span>
    <span class="keyword">private</span> <span class="type">Node</span>&lt;E&gt; next;       <span class="comment">// reference to next node</span>
    
    <span class="keyword">public</span> <span class="type">Node</span>(E e, <span class="type">Node</span>&lt;E&gt; p, <span class="type">Node</span>&lt;E&gt; n) {
        element = e;
        prev = p;
        next = n;
    }
    
    <span class="keyword">public</span> E getElement() { <span class="keyword">return</span> element; }
    <span class="keyword">public</span> <span class="type">Node</span>&lt;E&gt; getPrev() { <span class="keyword">return</span> prev; }
    <span class="keyword">public</span> <span class="type">Node</span>&lt;E&gt; getNext() { <span class="keyword">return</span> next; }
    <span class="keyword">public void</span> setPrev(<span class="type">Node</span>&lt;E&gt; p) { prev = p; }
    <span class="keyword">public void</span> setNext(<span class="type">Node</span>&lt;E&gt; n) { next = n; }
}
                </div>
                
                <h3>Sentinel Nodes</h3>
                <div class="card">
                    <h4>üèÅ Header and Trailer Nodes</h4>
                    <ul>
                        <li><strong>Header:</strong> Dummy node at the beginning (stores no data)</li>
                        <li><strong>Trailer:</strong> Dummy node at the end (stores no data)</li>
                        <li><strong>Purpose:</strong> Simplify implementation by eliminating special cases for empty lists</li>
                        <li>An empty list has header.next = trailer and trailer.prev = header</li>
                    </ul>
                    
                    <div class="code-block">
<span class="comment">// Constructor for empty list</span>
<span class="keyword">public</span> DoublyLinkedList() {
    header = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);
    trailer = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(<span class="keyword">null</span>, header, <span class="keyword">null</span>);
    header.setNext(trailer);
}
                    </div>
                </div>
                
                <h3>Basic Operations</h3>
                
                <div class="card">
                    <h4>‚ûï Inserting Between Two Nodes</h4>
                    <p><strong>Steps:</strong></p>
                    <ol>
                        <li>Create new node</li>
                        <li>Link new node to predecessor and successor</li>
                        <li>Link predecessor to new node</li>
                        <li>Link successor to new node</li>
                    </ol>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-1">O(1)</span></p>
                    
                    <div class="code-block">
<span class="keyword">private void</span> addBetween(E element, <span class="type">Node</span>&lt;E&gt; predecessor, <span class="type">Node</span>&lt;E&gt; successor) {
    <span class="type">Node</span>&lt;E&gt; newest = <span class="keyword">new</span> <span class="type">Node</span>&lt;&gt;(element, predecessor, successor);
    predecessor.setNext(newest);
    successor.setPrev(newest);
    size++;
}

<span class="comment">// Insert at front (after header)</span>
<span class="keyword">public void</span> addFirst(E element) {
    addBetween(element, header, header.getNext());
}

<span class="comment">// Insert at end (before trailer)</span>
<span class="keyword">public void</span> addLast(E element) {
    addBetween(element, trailer.getPrev(), trailer);
}
                    </div>
                </div>
                
                <div class="card">
                    <h4>‚ûñ Removing a Node</h4>
                    <p><strong>Steps:</strong></p>
                    <ol>
                        <li>Get predecessor and successor of node to remove</li>
                        <li>Link predecessor to successor</li>
                        <li>Link successor to predecessor</li>
                        <li>Allow garbage collection of removed node</li>
                    </ol>
                    <p><strong>Time Complexity:</strong> <span class="complexity o-1">O(1)</span></p>
                    
                    <div class="code-block">
<span class="keyword">private</span> E remove(<span class="type">Node</span>&lt;E&gt; node) {
    <span class="type">Node</span>&lt;E&gt; predecessor = node.getPrev();
    <span class="type">Node</span>&lt;E&gt; successor = node.getNext();
    predecessor.setNext(successor);
    successor.setPrev(predecessor);
    size--;
    <span class="keyword">return</span> node.getElement();
}

<span class="comment">// Remove first element</span>
<span class="keyword">public</span> E removeFirst() {
    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return null</span>;
    <span class="keyword">return</span> remove(header.getNext());
}

<span class="comment">// Remove last element - NOW EFFICIENT!</span>
<span class="keyword">public</span> E removeLast() {
    <span class="keyword">if</span> (isEmpty()) <span class="keyword">return null</span>;
    <span class="keyword">return</span> remove(trailer.getPrev());
}
                    </div>
                </div>
                
                <h3>Performance Summary</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Time Complexity</th>
                            <th>Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Insert at head</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>After header node</td>
                        </tr>
                        <tr>
                            <td>Insert at tail</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>Before trailer node</td>
                        </tr>
                        <tr>
                            <td>Remove at head</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>After header node</td>
                        </tr>
                        <tr>
                            <td>Remove at tail</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>‚úÖ NOW EFFICIENT! Can access previous node</td>
                        </tr>
                        <tr>
                            <td>Insert/Remove at given node</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td>If we have reference to the node</td>
                        </tr>
                    </tbody>
                </table>
            </section>
            
            <!-- COMPARISON SECTION -->
            <section id="comparison">
                <h2>‚öñÔ∏è Arrays vs. Linked Lists Comparison</h2>
                
                <div class="comparison-table">
                    <div class="comparison-card array-card">
                        <h3>üìä Arrays</h3>
                        <h4>Advantages:</h4>
                        <ul>
                            <li>‚úÖ <strong>Fast random access</strong> - O(1)</li>
                            <li>‚úÖ Memory efficient (no extra pointers)</li>
                            <li>‚úÖ Better cache locality</li>
                            <li>‚úÖ Simple implementation</li>
                        </ul>
                        <h4>Disadvantages:</h4>
                        <ul>
                            <li>‚ùå <strong>Slow insertion/deletion</strong> - O(n)</li>
                            <li>‚ùå Fixed size (or expensive resizing)</li>
                            <li>‚ùå Wasted space if not full</li>
                        </ul>
                    </div>
                    
                    <div class="comparison-card list-card">
                        <h3>üîó Linked Lists</h3>
                        <h4>Advantages:</h4>
                        <ul>
                            <li>‚úÖ <strong>Fast insertion/deletion</strong> at known positions - O(1)</li>
                            <li>‚úÖ Dynamic size</li>
                            <li>‚úÖ No wasted space</li>
                            <li>‚úÖ Easy to split/merge lists</li>
                        </ul>
                        <h4>Disadvantages:</h4>
                        <ul>
                            <li>‚ùå <strong>Slow random access</strong> - O(n)</li>
                            <li>‚ùå Extra memory for pointers</li>
                            <li>‚ùå Poor cache locality</li>
                        </ul>
                    </div>
                </div>
                
                <h3>When to Use Each</h3>
                <div class="card">
                    <h4>Use Arrays when:</h4>
                    <ul>
                        <li>You need <strong>fast random access</strong> by index</li>
                        <li>The size is known and relatively fixed</li>
                        <li>Memory is limited (no extra pointers)</li>
                        <li>You're doing lots of reading, little insertion/deletion</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>Use Linked Lists when:</h4>
                    <ul>
                        <li>You need <strong>frequent insertions/deletions</strong></li>
                        <li>The size changes dynamically</li>
                        <li>You don't need random access</li>
                        <li>You're implementing queues, stacks, or other sequential structures</li>
                    </ul>
                </div>
            </section>
            
            <!-- ARRAY LISTS SECTION -->
            <section id="array-lists">
                <h2>üìà Dynamic Array Lists (Growable Arrays)</h2>
                
                <div class="definition">
                    <h3>The Problem with Fixed Arrays</h3>
                    <p>Standard arrays have a <strong>fixed capacity</strong>. What if we don't know the size in advance? What if we need to grow the array?</p>
                </div>
                
                <div class="card">
                    <h3>Solution: Dynamic Arrays</h3>
                    <p>When the array becomes full, we can:</p>
                    <ol>
                        <li>Create a <strong>new, larger array</strong></li>
                        <li><strong>Copy all elements</strong> from the old array to the new array</li>
                        <li>Replace the reference to point to the new array</li>
                    </ol>
                </div>
                
                <h3>Growth Strategies</h3>
                
                <div class="comparison-table">
                    <div class="comparison-card array-card">
                        <h3>Incremental Strategy</h3>
                        <p>Increase size by a <strong>constant c</strong></p>
                        <p><strong>New size = old size + c</strong></p>
                        <h4>Analysis:</h4>
                        <ul>
                            <li>Replace array k = n/c times</li>
                            <li>Total time: n + c + 2c + 3c + ... + kc</li>
                            <li>T(n) = O(n + k¬≤) = <span class="complexity o-n2">O(n¬≤)</span></li>
                            <li>Amortized time per push: <span class="complexity o-n">O(n)</span></li>
                        </ul>
                        <p><strong>‚ùå Not efficient!</strong></p>
                    </div>
                    
                    <div class="comparison-card list-card">
                        <h3>Doubling Strategy</h3>
                        <p><strong>Double the size</strong> each time</p>
                        <p><strong>New size = 2 √ó old size</strong></p>
                        <h4>Analysis:</h4>
                        <ul>
                            <li>Replace array k = log‚ÇÇ n times</li>
                            <li>Total time: n + 1 + 2 + 4 + 8 + ... + 2^k</li>
                            <li>T(n) = n + 2^(k+1) - 1 = <span class="complexity o-n">O(n)</span></li>
                            <li>Amortized time per push: <span class="complexity o-1">O(1)</span></li>
                        </ul>
                        <p><strong>‚úÖ Much better!</strong></p>
                    </div>
                </div>
                
                <h3>Implementation</h3>
                <div class="code-block">
<span class="keyword">public void</span> add(<span class="keyword">int</span> index, E element) {
    <span class="comment">// Check if array is full</span>
    <span class="keyword">if</span> (size == data.length) {
        <span class="comment">// Double the capacity!</span>
        E[] newData = (E[]) <span class="keyword">new</span> <span class="type">Object</span>[<span class="string">2</span> * data.length];
        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="string">0</span>; i < size; i++)
            newData[i] = data[i];
        data = newData;
    }
    
    <span class="comment">// Shift elements to make room</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = size; i > index; i--)
        data[i] = data[i-<span class="string">1</span>];
    
    data[index] = element;
    size++;
}
                </div>
                
                <div class="important">
                    <h3>üéØ Key Takeaway: Amortized Analysis</h3>
                    <p><strong>Amortized time</strong> is the average time per operation over a sequence of operations.</p>
                    <p>With the doubling strategy:</p>
                    <ul>
                        <li>Most insertions are cheap (O(1))</li>
                        <li>Occasionally we have an expensive operation (O(n)) when we resize</li>
                        <li>But resizing happens so infrequently that the <strong>average</strong> is still O(1)!</li>
                    </ul>
                </div>
                
                <h3>Java's ArrayList</h3>
                <div class="card">
                    <p>Java's <code>java.util.ArrayList</code> implements this dynamic array concept:</p>
                    <ul>
                        <li>Automatically grows as needed</li>
                        <li>Provides O(1) amortized insertion at end</li>
                        <li>Provides O(1) access by index</li>
                        <li>Still O(n) for insertion/deletion in the middle</li>
                    </ul>
                </div>
            </section>
            
            <!-- POSITIONAL LISTS SECTION -->
            <section id="positional">
                <h2>üìç Positional Lists</h2>
                
                <div class="definition">
                    <h3>What is a Positional List?</h3>
                    <p>A <strong>positional list</strong> is an ADT that provides a general abstraction of a sequence with the ability to identify the location of an element.</p>
                    <p>A <strong>position</strong> acts as a marker or token within the list, independent of the element's index.</p>
                </div>
                
                <div class="important">
                    <h4>üéØ Key Concepts</h4>
                    <ul>
                        <li>A position is <strong>unaffected by changes elsewhere</strong> in the list</li>
                        <li>Only becomes invalid if explicitly deleted</li>
                        <li>Supports efficient insertion/deletion at any position</li>
                        <li>Natural implementation: <strong>doubly linked list</strong></li>
                    </ul>
                </div>
                
                <h3>Position Interface</h3>
                <div class="code-block">
<span class="keyword">public interface</span> <span class="type">Position</span>&lt;E&gt; {
    <span class="comment">// Returns the element stored at this position</span>
    E getElement() <span class="keyword">throws</span> IllegalStateException;
}
                </div>
                
                <h3>Positional List ADT Methods</h3>
                
                <h4>Accessor Methods</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                            <th>Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>first()</code></td>
                            <td>Returns position of first element (or null if empty)</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>last()</code></td>
                            <td>Returns position of last element (or null if empty)</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>before(p)</code></td>
                            <td>Returns position immediately before p (or null)</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>after(p)</code></td>
                            <td>Returns position immediately after p (or null)</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>isEmpty()</code></td>
                            <td>Returns true if list contains no elements</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>size()</code></td>
                            <td>Returns number of elements in the list</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                    </tbody>
                </table>
                
                <h4>Update Methods</h4>
                <table>
                    <thead>
                        <tr>
                            <th>Method</th>
                            <th>Description</th>
                            <th>Complexity</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>addFirst(e)</code></td>
                            <td>Insert element at front, return its position</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>addLast(e)</code></td>
                            <td>Insert element at back, return its position</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>addBefore(p, e)</code></td>
                            <td>Insert element just before position p</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>addAfter(p, e)</code></td>
                            <td>Insert element just after position p</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>set(p, e)</code></td>
                            <td>Replace element at position p, return old element</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td><code>remove(p)</code></td>
                            <td>Remove and return element at position p</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                    </tbody>
                </table>
                
                <div class="example">
                    <h3>Example Usage</h3>
                    <div class="code-block">
<span class="type">PositionalList</span>&lt;<span class="type">String</span>&gt; list = <span class="keyword">new</span> LinkedPositionalList&lt;&gt;();

<span class="comment">// Build list: (A, B, C)</span>
<span class="type">Position</span>&lt;<span class="type">String</span>&gt; p1 = list.addLast(<span class="string">"A"</span>);
<span class="type">Position</span>&lt;<span class="type">String</span>&gt; p2 = list.addLast(<span class="string">"B"</span>);
<span class="type">Position</span>&lt;<span class="type">String</span>&gt; p3 = list.addLast(<span class="string">"C"</span>);

<span class="comment">// Insert before B: (A, X, B, C)</span>
<span class="type">Position</span>&lt;<span class="type">String</span>&gt; p4 = list.addBefore(p2, <span class="string">"X"</span>);

<span class="comment">// Access neighbors</span>
list.after(p1);    <span class="comment">// returns position of X</span>
list.before(p2);   <span class="comment">// returns position of X</span>

<span class="comment">// Remove X: (A, B, C)</span>
list.remove(p4);
                    </div>
                </div>
            </section>
            
            <!-- ITERATORS SECTION -->
            <section id="iterators">
                <h2>üîÑ Iterators</h2>
                
                <div class="definition">
                    <h3>What is an Iterator?</h3>
                    <p>An <strong>iterator</strong> is a software design pattern that abstracts the process of <strong>scanning through a sequence</strong> of elements, one element at a time.</p>
                </div>
                
                <h3>Iterator Interface</h3>
                <div class="code-block">
<span class="keyword">public interface</span> <span class="type">Iterator</span>&lt;E&gt; {
    <span class="comment">// Returns true if there is at least one more element</span>
    <span class="keyword">boolean</span> hasNext();
    
    <span class="comment">// Returns the next element in the sequence</span>
    E next();
    
    <span class="comment">// Optional: removes the last returned element</span>
    <span class="keyword">default void</span> remove() {
        <span class="keyword">throw new</span> UnsupportedOperationException(<span class="string">"remove"</span>);
    }
}
                </div>
                
                <h3>Iterable Interface</h3>
                <div class="card">
                    <p>Collections implement the <strong>Iterable</strong> interface, which provides a method to obtain an iterator:</p>
                    <div class="code-block">
<span class="keyword">public interface</span> <span class="type">Iterable</span>&lt;E&gt; {
    <span class="comment">// Returns an iterator over elements of type E</span>
    <span class="type">Iterator</span>&lt;E&gt; iterator();
}
                    </div>
                </div>
                
                <h3>Using Iterators</h3>
                
                <h4>Traditional Way</h4>
                <div class="code-block">
<span class="type">List</span>&lt;<span class="type">String</span>&gt; names = <span class="keyword">new</span> <span class="type">ArrayList</span>&lt;&gt;();
<span class="comment">// ... add elements ...</span>

<span class="comment">// Get an iterator</span>
<span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; iter = names.iterator();

<span class="comment">// Loop through elements</span>
<span class="keyword">while</span> (iter.hasNext()) {
    <span class="type">String</span> name = iter.next();
    System.out.println(name);
}
                </div>
                
                <h4>For-Each Loop (Syntactic Sugar)</h4>
                <div class="card">
                    <p>Java's for-each loop is <strong>syntactic sugar</strong> for iterator usage:</p>
                    <div class="code-block">
<span class="comment">// This elegant syntax...</span>
<span class="keyword">for</span> (<span class="type">String</span> name : names) {
    System.out.println(name);
}

<span class="comment">// ...is equivalent to this:</span>
<span class="type">Iterator</span>&lt;<span class="type">String</span>&gt; iter = names.iterator();
<span class="keyword">while</span> (iter.hasNext()) {
    <span class="type">String</span> name = iter.next();
    System.out.println(name);
}
                    </div>
                </div>
                
                <div class="important">
                    <h3>üéØ Key Benefits of Iterators</h3>
                    <ul>
                        <li><strong>Abstraction:</strong> Same interface for different data structures</li>
                        <li><strong>Flexibility:</strong> Can have multiple iterators on same collection</li>
                        <li><strong>Safety:</strong> Can remove elements safely during iteration</li>
                        <li><strong>Simplicity:</strong> For-each loop provides clean syntax</li>
                    </ul>
                </div>
                
                <h3>Implementing an Iterator</h3>
                <div class="example">
                    <h4>Example: Iterator for ArrayList</h4>
                    <div class="code-block">
<span class="keyword">private class</span> <span class="type">ArrayIterator</span> <span class="keyword">implements</span> <span class="type">Iterator</span>&lt;E&gt; {
    <span class="keyword">private int</span> current = <span class="string">0</span>;  <span class="comment">// index of next element</span>
    
    <span class="keyword">public boolean</span> hasNext() {
        <span class="keyword">return</span> current < size;
    }
    
    <span class="keyword">public</span> E next() {
        <span class="keyword">if</span> (!hasNext()) 
            <span class="keyword">throw new</span> NoSuchElementException();
        <span class="keyword">return</span> data[current++];
    }
}

<span class="comment">// In the ArrayList class</span>
<span class="keyword">public</span> <span class="type">Iterator</span>&lt;E&gt; iterator() {
    <span class="keyword">return new</span> ArrayIterator();
}
                    </div>
                </div>
            </section>
            
            <!-- SUMMARY SECTION -->
            <section id="summary">
                <h2>üìù Complete Summary</h2>
                
                <h3>Time Complexity Comparison</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Array</th>
                            <th>Singly Linked</th>
                            <th>Doubly Linked</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Access by index</td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-n">O(n)</span></td>
                        </tr>
                        <tr>
                            <td>Insert at head</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td>Insert at tail</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td>Remove at head</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td>Remove at tail</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-1">O(1)</span></td>
                        </tr>
                        <tr>
                            <td>Insert at middle</td>
                            <td><span class="complexity o-n">O(n)</span></td>
                            <td><span class="complexity o-n">O(n)</span>*</td>
                            <td><span class="complexity o-n">O(n)</span>*</td>
                        </tr>
                    </tbody>
                </table>
                <p style="font-size: 0.9em; margin-top: 10px;">* O(1) if position is already known</p>
                
                <h3>üéì Key Takeaways</h3>
                
                <div class="card">
                    <h4>1. Arrays</h4>
                    <ul>
                        <li>Best for: <strong>Random access</strong> and <strong>fixed-size</strong> collections</li>
                        <li>Weakness: <strong>Slow insertion/deletion</strong></li>
                        <li>Memory: Contiguous, good cache locality</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>2. Singly Linked Lists</h4>
                    <ul>
                        <li>Best for: <strong>Sequential access</strong>, frequent <strong>head operations</strong></li>
                        <li>Weakness: <strong>Can't efficiently remove at tail</strong>, no backward traversal</li>
                        <li>Memory: Scattered, extra space for next pointer</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>3. Doubly Linked Lists</h4>
                    <ul>
                        <li>Best for: <strong>Bidirectional traversal</strong>, operations at <strong>both ends</strong></li>
                        <li>Weakness: More memory (two pointers per node)</li>
                        <li>Memory: Scattered, extra space for prev and next pointers</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>4. Dynamic Arrays (ArrayList)</h4>
                    <ul>
                        <li>Combines array access speed with dynamic sizing</li>
                        <li>Doubling strategy gives <strong>O(1) amortized</strong> insertion at end</li>
                        <li>Best general-purpose list in Java</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>5. Positional Lists</h4>
                    <ul>
                        <li>Abstract positions independent of indices</li>
                        <li>Naturally implemented with doubly linked lists</li>
                        <li>All operations in <strong>O(1)</strong> time if position is known</li>
                    </ul>
                </div>
                
                <div class="card">
                    <h4>6. Iterators</h4>
                    <ul>
                        <li>Provide uniform way to traverse collections</li>
                        <li>Enable for-each loops</li>
                        <li>Allow multiple simultaneous traversals</li>
                    </ul>
                </div>
            </section>
            
            <!-- STUDY TIPS SECTION -->
            <section id="study-tips">
                <h2>üí° Study Tips & Practice Questions</h2>
                
                <div class="important">
                    <h3>üéØ What You Must Know</h3>
                    <ol>
                        <li>Time complexity of operations for each data structure</li>
                        <li>When to use arrays vs. linked lists</li>
                        <li>How to implement basic operations (insert, delete, traverse)</li>
                        <li>The difference between singly and doubly linked lists</li>
                        <li>How dynamic arrays work (doubling strategy)</li>
                        <li>What amortized analysis means</li>
                        <li>How iterators work and why they're useful</li>
                    </ol>
                </div>
                
                <h3>Practice Questions</h3>
                
                <div class="example">
                    <h4>Question 1: Array Operations</h4>
                    <p><strong>Q:</strong> Why is inserting an element in the middle of an array O(n)?</p>
                    <p><strong>A:</strong> Because we need to shift all elements after the insertion point one position to the right. In the worst case (inserting at index 0), we shift n elements.</p>
                </div>
                
                <div class="example">
                    <h4>Question 2: Linked List Advantage</h4>
                    <p><strong>Q:</strong> When is a linked list better than an array?</p>
                    <p><strong>A:</strong> When you need frequent insertions/deletions and don't need random access. Linked lists can insert/delete in O(1) time if you have the position, while arrays require O(n) time for shifting elements.</p>
                </div>
                
                <div class="example">
                    <h4>Question 3: Doubly vs. Singly Linked</h4>
                    <p><strong>Q:</strong> What's the main advantage of a doubly linked list over a singly linked list?</p>
                    <p><strong>A:</strong> Doubly linked lists can efficiently remove at the tail (O(1)) and traverse backward. Singly linked lists require O(n) time to remove at the tail because they must traverse to find the previous node.</p>
                </div>
                
                <div class="example">
                    <h4>Question 4: Dynamic Arrays</h4>
                    <p><strong>Q:</strong> Why is the doubling strategy for dynamic arrays better than incrementing by a constant?</p>
                    <p><strong>A:</strong> Doubling gives O(1) amortized time per insertion (total O(n) for n insertions), while incrementing by a constant gives O(n) amortized time (total O(n¬≤) for n insertions). Doubling reduces the frequency of expensive resize operations.</p>
                </div>
                
                <div class="example">
                    <h4>Question 5: Iterator Usage</h4>
                    <p><strong>Q:</strong> What does "iterable" mean in Java?</p>
                    <p><strong>A:</strong> A class is iterable if it implements the Iterable interface, meaning it provides an iterator() method that returns an Iterator object. This allows the class to be used in for-each loops.</p>
                </div>
            </section>
        </div>
        
        <footer>
            <p>üìö CS210 Data Structures Study Guide | Created for comprehensive exam preparation</p>
            <p>Good luck with your studies! üöÄ</p>
        </footer>
    </div>
</body>
</html>