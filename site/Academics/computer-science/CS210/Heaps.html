<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heaps & Priority Queues - Comprehensive Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .toc {
            background: #f8f9fa;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 30px;
            border-left: 5px solid #667eea;
        }

        .toc h2 {
            color: #667eea;
            margin-bottom: 15px;
        }

        .toc ul {
            list-style: none;
        }

        .toc li {
            margin: 10px 0;
        }

        .toc a {
            color: #764ba2;
            text-decoration: none;
            font-weight: 500;
            transition: all 0.3s;
            display: inline-block;
        }

        .toc a:hover {
            color: #667eea;
            transform: translateX(5px);
        }

        section {
            margin: 40px 0;
            padding: 30px;
            background: #fff;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        h2 {
            color: #667eea;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #667eea;
        }

        h3 {
            color: #764ba2;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .definition {
            background: #e3f2fd;
            padding: 20px;
            border-left: 5px solid #2196F3;
            border-radius: 5px;
            margin: 20px 0;
        }

        .key-concept {
            background: #f3e5f5;
            padding: 20px;
            border-left: 5px solid #9c27b0;
            border-radius: 5px;
            margin: 20px 0;
        }

        .important {
            background: #fff3e0;
            padding: 20px;
            border-left: 5px solid #ff9800;
            border-radius: 5px;
            margin: 20px 0;
        }

        .code-block {
            background: #263238;
            color: #aed581;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
        }

        .code-block .keyword {
            color: #c792ea;
        }

        .code-block .comment {
            color: #546e7a;
            font-style: italic;
        }

        .code-block .string {
            color: #c3e88d;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #e0e0e0;
        }

        tr:nth-child(even) {
            background: #f8f9fa;
        }

        tr:hover {
            background: #f0f0f0;
        }

        .complexity {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 0.9em;
        }

        .complexity.fast {
            background: #c8e6c9;
            color: #2e7d32;
        }

        .complexity.medium {
            background: #fff9c4;
            color: #f57f17;
        }

        .complexity.slow {
            background: #ffcdd2;
            color: #c62828;
        }

        .visualization {
            background: #fafafa;
            padding: 25px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .array-visual {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .array-cell {
            width: 50px;
            height: 50px;
            border: 2px solid #667eea;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            background: white;
            border-radius: 5px;
            position: relative;
        }

        .array-cell .index {
            position: absolute;
            top: -20px;
            font-size: 0.8em;
            color: #999;
        }

        .tree-visual {
            margin: 30px 0;
            text-align: center;
        }

        .example {
            background: #f5f5f5;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border: 2px dashed #667eea;
        }

        .example h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .operations-list {
            list-style: none;
            padding: 0;
        }

        .operations-list li {
            padding: 10px;
            margin: 8px 0;
            background: #f8f9fa;
            border-left: 4px solid #667eea;
            border-radius: 4px;
        }

        .operations-list li strong {
            color: #764ba2;
        }

        .note {
            background: #fff9c4;
            padding: 15px;
            border-left: 5px solid #fbc02d;
            border-radius: 5px;
            margin: 15px 0;
        }

        .note strong {
            color: #f57f17;
        }

        .pros-cons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .pros, .cons {
            padding: 20px;
            border-radius: 8px;
        }

        .pros {
            background: #e8f5e9;
            border-left: 5px solid #4caf50;
        }

        .cons {
            background: #ffebee;
            border-left: 5px solid #f44336;
        }

        .pros h4, .cons h4 {
            margin-top: 0;
        }

        ul.styled-list {
            margin-left: 20px;
        }

        ul.styled-list li {
            margin: 8px 0;
        }

        footer {
            background: #263238;
            color: white;
            text-align: center;
            padding: 20px;
        }

        @media (max-width: 768px) {
            .pros-cons {
                grid-template-columns: 1fr;
            }
            
            .array-visual {
                flex-direction: column;
                align-items: center;
            }
            
            header h1 {
                font-size: 2em;
            }
        }

        .quote {
            border-left: 5px solid #667eea;
            padding: 15px 20px;
            margin: 20px 0;
            background: #f8f9fa;
            font-style: italic;
            color: #555;
        }

        .highlight {
            background: linear-gradient(120deg, #84fab0 0%, #8fd3f4 100%);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Heaps & Priority Queues</h1>
            <p>A Comprehensive Study Guide for CS210</p>
        </header>

        <div class="content">
            <!-- Table of Contents -->
            <div class="toc">
                <h2>üìë Table of Contents</h2>
                <ul>
                    <li><a href="#intro">1. Introduction to Collections</a></li>
                    <li><a href="#priority-queue">2. Priority Queue ADT</a></li>
                    <li><a href="#applications">3. Priority Queue Applications</a></li>
                    <li><a href="#complete-binary-tree">4. Complete Binary Trees</a></li>
                    <li><a href="#heap-definition">5. Heap Definition & Properties</a></li>
                    <li><a href="#heap-operations">6. Heap Operations</a></li>
                    <li><a href="#implementation">7. Java Implementation</a></li>
                    <li><a href="#complexity">8. Time Complexity Analysis</a></li>
                    <li><a href="#heapsort">9. Heap Sort</a></li>
                    <li><a href="#practice">10. Practice Problems</a></li>
                </ul>
            </div>

            <!-- Section 1: Introduction -->
            <section id="intro">
                <h2>1. Introduction to Collections</h2>
                
                <div class="quote">
                    <strong>Fred Brooks:</strong> "Show me your code and conceal your data structures, and I shall continue to be mystified. Show me your data structures, and I won't usually need your code; it'll be obvious."
                </div>

                <p>A <span class="highlight">collection</span> is a data type that stores groups of items. Different collections have different key operations and are implemented with different data structures.</p>

                <h3>Common Collections</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Data Type</th>
                            <th>Key Operations</th>
                            <th>Data Structure</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Stack</strong></td>
                            <td>PUSH, POP</td>
                            <td>Linked list, resizing array</td>
                        </tr>
                        <tr>
                            <td><strong>Queue</strong></td>
                            <td>ENQUEUE, DEQUEUE</td>
                            <td>Linked list, resizing array</td>
                        </tr>
                        <tr>
                            <td><strong>Priority Queue</strong></td>
                            <td>INSERT, DELETE-MAX</td>
                            <td>Binary heap</td>
                        </tr>
                        <tr>
                            <td><strong>Symbol Table</strong></td>
                            <td>PUT, GET, DELETE</td>
                            <td>BST, hash table</td>
                        </tr>
                        <tr>
                            <td><strong>Set</strong></td>
                            <td>ADD, CONTAINS, DELETE</td>
                            <td>BST, hash table</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Section 2: Priority Queue -->
            <section id="priority-queue">
                <h2>2. Priority Queue ADT</h2>

                <div class="definition">
                    <h3>Definition</h3>
                    <p>A <strong>Priority Queue</strong> is a collection where you insert and delete items, but unlike a regular queue, <strong>you remove the largest (or smallest) item</strong>, not the item that was added first or last.</p>
                </div>

                <h3>Key Differences from Other Collections</h3>
                <ul class="styled-list">
                    <li><strong>Stack:</strong> Remove the item most recently added (LIFO)</li>
                    <li><strong>Queue:</strong> Remove the item least recently added (FIFO)</li>
                    <li><strong>Randomized Queue:</strong> Remove a random item</li>
                    <li><strong>Priority Queue:</strong> Remove the <span class="highlight">largest</span> (or smallest) item</li>
                </ul>

                <h3>Priority Queue API (Java)</h3>
                <div class="code-block">
<span class="keyword">public class</span> MaxPQ&lt;Key <span class="keyword">extends</span> Comparable&lt;Key&gt;&gt;
{
    <span class="comment">// Create an empty priority queue</span>
    MaxPQ()
    
    <span class="comment">// Create a priority queue with given keys</span>
    MaxPQ(Key[] a)
    
    <span class="comment">// Insert a key into the priority queue</span>
    <span class="keyword">void</span> insert(Key v)
    
    <span class="comment">// Return and remove the largest key</span>
    Key delMax()
    
    <span class="comment">// Is the priority queue empty?</span>
    <span class="keyword">boolean</span> isEmpty()
    
    <span class="comment">// Return the largest key (without removing)</span>
    Key max()
    
    <span class="comment">// Number of entries in the priority queue</span>
    <span class="keyword">int</span> size()
}
                </div>

                <div class="important">
                    <strong>‚ö†Ô∏è Important:</strong> The generic type <code>Key</code> must implement <code>Comparable&lt;Key&gt;</code> so that items can be ordered.
                </div>

                <h3>Example Operations</h3>
                <div class="example">
                    <h4>Example: Priority Queue Operations</h4>
                    <table>
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Argument</th>
                                <th>Return Value</th>
                                <th>Contents (unordered)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>insert</td>
                                <td>P</td>
                                <td>-</td>
                                <td>P</td>
                            </tr>
                            <tr>
                                <td>insert</td>
                                <td>Q</td>
                                <td>-</td>
                                <td>P Q</td>
                            </tr>
                            <tr>
                                <td>insert</td>
                                <td>E</td>
                                <td>-</td>
                                <td>P Q E</td>
                            </tr>
                            <tr>
                                <td>removeMax</td>
                                <td>-</td>
                                <td><strong>Q</strong></td>
                                <td>P E</td>
                            </tr>
                            <tr>
                                <td>insert</td>
                                <td>X</td>
                                <td>-</td>
                                <td>P E X</td>
                            </tr>
                            <tr>
                                <td>insert</td>
                                <td>A</td>
                                <td>-</td>
                                <td>P E X A</td>
                            </tr>
                            <tr>
                                <td>insert</td>
                                <td>M</td>
                                <td>-</td>
                                <td>P E X A M</td>
                            </tr>
                            <tr>
                                <td>removeMax</td>
                                <td>-</td>
                                <td><strong>X</strong></td>
                                <td>P E M A</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </section>

            <!-- Section 3: Applications -->
            <section id="applications">
                <h2>3. Priority Queue Applications</h2>

                <p>Priority queues generalize stacks, queues, and randomized queues, and have numerous real-world applications:</p>

                <div class="key-concept">
                    <h3>üåü Real-World Applications</h3>
                    <ul class="styled-list">
                        <li><strong>Event-driven simulation:</strong> Customers in a line, colliding particles</li>
                        <li><strong>Numerical computation:</strong> Reducing roundoff error</li>
                        <li><strong>Data compression:</strong> Huffman codes</li>
                        <li><strong>Graph searching:</strong> Dijkstra's algorithm, Prim's algorithm</li>
                        <li><strong>Number theory:</strong> Sum of powers</li>
                        <li><strong>Artificial intelligence:</strong> A* search</li>
                        <li><strong>Statistics:</strong> Online median in data stream</li>
                        <li><strong>Operating systems:</strong> Load balancing, interrupt handling</li>
                        <li><strong>Computer networks:</strong> Web cache</li>
                        <li><strong>Discrete optimization:</strong> Bin packing, scheduling</li>
                        <li><strong>Spam filtering:</strong> Bayesian spam filter</li>
                    </ul>
                </div>
            </section>

            <!-- Section 4: Complete Binary Tree -->
            <section id="complete-binary-tree">
                <h2>4. Complete Binary Trees</h2>

                <div class="definition">
                    <h3>Binary Tree</h3>
                    <p>A <strong>binary tree</strong> is either empty or a node with links to left and right binary trees (each node has at most 2 children).</p>
                </div>

                <div class="definition">
                    <h3>Complete Binary Tree</h3>
                    <p>A <strong>complete tree</strong> is perfectly balanced, except possibly for the bottom level. All levels are completely filled except possibly the last level, which is filled from left to right.</p>
                </div>

                <div class="visualization">
                    <h4>Complete Binary Tree Example (N = 16, height = 4)</h4>
                    <pre>
                    ‚óã
                   / \
                  ‚óã   ‚óã
                 / \ / \
                ‚óã ‚óã ‚óã ‚óã
               /\\/\\/\\/\
              ‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã‚óã
                    </pre>
                </div>

                <div class="key-concept">
                    <h3>üìê Important Property</h3>
                    <p><strong>Height of a complete tree with N nodes is ‚åälg N‚åã</strong></p>
                    <p>The height increases only when N is a power of 2.</p>
                    <p>This logarithmic height is what makes heaps efficient!</p>
                </div>

                <h3>Why Complete Binary Trees?</h3>
                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Advantages</h4>
                        <ul>
                            <li>Guaranteed logarithmic height</li>
                            <li>Can be stored efficiently in an array</li>
                            <li>No explicit links needed</li>
                            <li>Easy to navigate using array indices</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Constraints</h4>
                        <ul>
                            <li>Must maintain completeness property</li>
                            <li>Insertions must go at the end</li>
                            <li>Deletions require restructuring</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Section 5: Heap Definition -->
            <section id="heap-definition">
                <h2>5. Heap Definition & Properties</h2>

                <div class="definition">
                    <h3>Binary Heap</h3>
                    <p>A <strong>binary heap</strong> is an array representation of a <strong>heap-ordered</strong> complete binary tree.</p>
                </div>

                <h3>Two Key Properties</h3>
                <div class="important">
                    <h4>1. Heap-Order Property</h4>
                    <p>For every internal node <em>v</em> other than the root:</p>
                    <p style="text-align: center; font-size: 1.2em; margin: 10px 0;"><strong>key(v) ‚â• key(parent(v))</strong></p>
                    <p>This means: <span class="highlight">Parent's key is no smaller than children's keys</span></p>
                    <p>Or equivalently: Each node's key must be <strong>less than or equal</strong> to its parent's key.</p>
                </div>

                <div class="important">
                    <h4>2. Complete Binary Tree Property</h4>
                    <p>The tree must be a complete binary tree (as defined above).</p>
                </div>

                <h3>Types of Heaps</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Heap Type</th>
                            <th>Property</th>
                            <th>Root Contains</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Max Heap</strong></td>
                            <td>Parent ‚â• Children</td>
                            <td>Maximum element</td>
                        </tr>
                        <tr>
                            <td><strong>Min Heap</strong></td>
                            <td>Parent ‚â§ Children</td>
                            <td>Minimum element</td>
                        </tr>
                    </tbody>
                </table>

                <div class="note">
                    <strong>üìù Note:</strong> By default, when we say "heap" we typically mean a <strong>max heap</strong>. This study guide focuses on max heaps, but the concepts apply equally to min heaps with reversed comparisons.
                </div>

                <h3>Array Representation</h3>
                <div class="key-concept">
                    <h4>Array Indices for Navigation</h4>
                    <p>In a heap stored in array <code>a[]</code> starting at index 1:</p>
                    <ul class="styled-list">
                        <li><strong>Root:</strong> a[1]</li>
                        <li><strong>Parent of node at k:</strong> a[k/2]</li>
                        <li><strong>Left child of node at k:</strong> a[2k]</li>
                        <li><strong>Right child of node at k:</strong> a[2k+1]</li>
                    </ul>
                </div>

                <div class="visualization">
                    <h4>Heap Visualization (Max Heap)</h4>
                    <p><strong>Tree representation:</strong></p>
                    <pre>
           T (1)
          / \
        S(2) R(3)
       / \   / \
     P(4)N(5)O(6)A(7)
     /\  /\
   E I  H G
   8 9 10 11
                    </pre>
                    
                    <p><strong>Array representation:</strong></p>
                    <div class="array-visual">
                        <div class="array-cell" style="background: #ddd;"><div class="index">0</div>-</div>
                        <div class="array-cell" style="background: #ffeb3b;"><div class="index">1</div>T</div>
                        <div class="array-cell"><div class="index">2</div>S</div>
                        <div class="array-cell"><div class="index">3</div>R</div>
                        <div class="array-cell"><div class="index">4</div>P</div>
                        <div class="array-cell"><div class="index">5</div>N</div>
                        <div class="array-cell"><div class="index">6</div>O</div>
                        <div class="array-cell"><div class="index">7</div>A</div>
                        <div class="array-cell"><div class="index">8</div>E</div>
                        <div class="array-cell"><div class="index">9</div>I</div>
                        <div class="array-cell"><div class="index">10</div>H</div>
                        <div class="array-cell"><div class="index">11</div>G</div>
                    </div>
                    <p><em>Note: Index 0 is not used (we start at index 1)</em></p>
                </div>

                <div class="important">
                    <h4>üéØ Key Properties</h4>
                    <ul class="styled-list">
                        <li>The <strong>largest key</strong> is always at <code>a[1]</code> (the root)</li>
                        <li>We can navigate the tree using simple <strong>arithmetic on array indices</strong></li>
                        <li><strong>No explicit links</strong> (pointers) are needed!</li>
                        <li>Space efficient: only need array of size N+1</li>
                    </ul>
                </div>
            </section>

            <!-- Section 6: Heap Operations -->
            <section id="heap-operations">
                <h2>6. Heap Operations</h2>

                <h3>6.1 Insert Operation (Swim Up)</h3>
                
                <div class="definition">
                    <h4>Insert Algorithm</h4>
                    <ol class="styled-list">
                        <li>Add the new key at the end of the array (position N+1)</li>
                        <li>The new node becomes the new "last node" of the complete tree</li>
                        <li><strong>Swim up:</strong> Compare with parent and swap if necessary</li>
                        <li>Repeat until heap order is restored</li>
                    </ol>
                </div>

                <h4>Swim Helper Method</h4>
                <div class="code-block">
<span class="keyword">private void</span> swim(<span class="keyword">int</span> k) {
    <span class="comment">// While not at root AND child > parent</span>
    <span class="keyword">while</span> (k > 1 && less(k/2, k)) {
        exch(k, k/2);  <span class="comment">// Swap with parent</span>
        k = k/2;        <span class="comment">// Move up to parent</span>
    }
}
                </div>

                <h4>Insert Method</h4>
                <div class="code-block">
<span class="keyword">public void</span> insert(Key x) {
    pq[++N] = x;  <span class="comment">// Add at end and increment size</span>
    swim(N);      <span class="comment">// Restore heap order</span>
}
                </div>

                <div class="example">
                    <h4>Example: Insert 'S' into heap</h4>
                    <pre>
Before:              After adding:         After swim:
     T                    T                    S
    / \                  / \                  / \
   P   R                P   R                T   R
  / \                  / \ /                / \ /
 N   H                N  H S              N  H P
    
Heap: T P R N H    ‚Üí T P R N H S  ‚Üí  S T R N H P
                     (violates)       (restored)
                    </pre>
                </div>

                <div class="key-concept">
                    <h4>‚è±Ô∏è Time Complexity of Insert</h4>
                    <p><strong>At most 1 + lg N compares</strong></p>
                    <p>Why? In the worst case, we swim from the bottom to the top of the tree, and the height is ‚åälg N‚åã.</p>
                </div>

                <hr style="margin: 30px 0;">

                <h3>6.2 Delete Maximum Operation (Sink Down)</h3>
                
                <div class="definition">
                    <h4>Delete Max Algorithm</h4>
                    <ol class="styled-list">
                        <li>Save the root value (maximum) to return later</li>
                        <li>Exchange root with the last node (at position N)</li>
                        <li>Decrement N (remove last position)</li>
                        <li><strong>Sink down:</strong> Compare with children and swap with <em>larger</em> child if necessary</li>
                        <li>Repeat until heap order is restored</li>
                        <li>Return the saved maximum value</li>
                    </ol>
                </div>

                <h4>Sink Helper Method</h4>
                <div class="code-block">
<span class="keyword">private void</span> sink(<span class="keyword">int</span> k) {
    <span class="keyword">while</span> (2*k <= N) {  <span class="comment">// While has at least one child</span>
        <span class="keyword">int</span> j = 2*k;    <span class="comment">// Left child</span>
        
        <span class="comment">// Choose larger child</span>
        <span class="keyword">if</span> (j < N && less(j, j+1)) j++;
        
        <span class="comment">// If parent >= larger child, done</span>
        <span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;
        
        exch(k, j);  <span class="comment">// Swap with larger child</span>
        k = j;        <span class="comment">// Move down</span>
    }
}
                </div>

                <h4>Delete Max Method</h4>
                <div class="code-block">
<span class="keyword">public</span> Key delMax() {
    Key max = pq[1];      <span class="comment">// Get root (maximum)</span>
    exch(1, N--);         <span class="comment">// Exchange with last, decrement N</span>
    sink(1);              <span class="comment">// Restore heap order</span>
    pq[N+1] = <span class="keyword">null</span>;       <span class="comment">// Prevent loitering</span>
    <span class="keyword">return</span> max;
}
                </div>

                <div class="example">
                    <h4>Example: Delete maximum from heap</h4>
                    <pre>
Before:              After exchange:      After sink:
     T                    H                    S
    / \                  / \                  / \
   S   R                S   R                P   R
  / \ / \              / \ /                / \ /
 P  N O  A            P  N O  A            N  H O  A

Remove T  ‚Üí  Exchange with H  ‚Üí  Sink H down
(return T)   (violates order)    (restored)
                    </pre>
                </div>

                <div class="important">
                    <h4>‚ùì Why swap with the <em>larger</em> child?</h4>
                    <p>If we swapped with the smaller child, we might end up with a parent smaller than its other child, violating heap order. By swapping with the larger child, we ensure both children will be smaller than the promoted parent.</p>
                </div>

                <div class="key-concept">
                    <h4>‚è±Ô∏è Time Complexity of Delete Max</h4>
                    <p><strong>At most 2 lg N compares</strong></p>
                    <p>Why 2? At each level, we compare the two children (1 compare) and then compare with parent (1 more compare). Height is ‚åälg N‚åã.</p>
                </div>

                <div class="note">
                    <strong>üí° "Peter Principle":</strong> In swim, a node is promoted to its level of incompetence (can't go higher). In sink, there's a "power struggle" where the better subordinate gets promoted!
                </div>
            </section>

            <!-- Section 7: Implementation -->
            <section id="implementation">
                <h2>7. Complete Java Implementation</h2>

                <div class="code-block">
<span class="keyword">public class</span> MaxPQ&lt;Key <span class="keyword">extends</span> Comparable&lt;Key&gt;&gt; {
    <span class="keyword">private</span> Key[] pq;         <span class="comment">// Array to store heap</span>
    <span class="keyword">private int</span> N;            <span class="comment">// Number of elements</span>
    
    <span class="comment">// Constructor</span>
    <span class="keyword">public</span> MaxPQ(<span class="keyword">int</span> capacity) {
        pq = (Key[]) <span class="keyword">new</span> Comparable[capacity + 1];
    }
    
    <span class="comment">// Is the priority queue empty?</span>
    <span class="keyword">public boolean</span> isEmpty() {
        <span class="keyword">return</span> N == 0;
    }
    
    <span class="comment">// Number of elements</span>
    <span class="keyword">public int</span> size() {
        <span class="keyword">return</span> N;
    }
    
    <span class="comment">// Insert a key</span>
    <span class="keyword">public void</span> insert(Key key) {
        pq[++N] = key;
        swim(N);
    }
    
    <span class="comment">// Delete and return maximum</span>
    <span class="keyword">public</span> Key delMax() {
        Key max = pq[1];
        exch(1, N--);
        sink(1);
        pq[N+1] = <span class="keyword">null</span>;  <span class="comment">// Prevent loitering</span>
        <span class="keyword">return</span> max;
    }
    
    <span class="comment">/*******************************************
     * Helper functions for heap operations
     *******************************************/</span>
    
    <span class="keyword">private void</span> swim(<span class="keyword">int</span> k) {
        <span class="keyword">while</span> (k > 1 && less(k/2, k)) {
            exch(k, k/2);
            k = k/2;
        }
    }
    
    <span class="keyword">private void</span> sink(<span class="keyword">int</span> k) {
        <span class="keyword">while</span> (2*k <= N) {
            <span class="keyword">int</span> j = 2*k;
            <span class="keyword">if</span> (j < N && less(j, j+1)) j++;
            <span class="keyword">if</span> (!less(k, j)) <span class="keyword">break</span>;
            exch(k, j);
            k = j;
        }
    }
    
    <span class="comment">/*******************************************
     * Helper functions for comparisons and swaps
     *******************************************/</span>
    
    <span class="keyword">private boolean</span> less(<span class="keyword">int</span> i, <span class="keyword">int</span> j) {
        <span class="keyword">return</span> pq[i].compareTo(pq[j]) < 0;
    }
    
    <span class="keyword">private void</span> exch(<span class="keyword">int</span> i, <span class="keyword">int</span> j) {
        Key t = pq[i];
        pq[i] = pq[j];
        pq[j] = t;
    }
}
                </div>

                <div class="note">
                    <strong>üìù Implementation Notes:</strong>
                    <ul class="styled-list">
                        <li>Array indices start at 1 (index 0 is not used)</li>
                        <li>For simplicity, this uses fixed capacity (could be made resizing)</li>
                        <li>Generic type <code>Key</code> must implement <code>Comparable</code></li>
                        <li>Setting <code>pq[N+1] = null</code> prevents loitering (allows garbage collection)</li>
                    </ul>
                </div>
            </section>

            <!-- Section 8: Complexity -->
            <section id="complexity">
                <h2>8. Time Complexity Analysis</h2>

                <h3>Elementary Implementations vs Binary Heap</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Implementation</th>
                            <th>Insert</th>
                            <th>Delete Max</th>
                            <th>Get Max</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Unordered Array</strong></td>
                            <td><span class="complexity fast">1</span></td>
                            <td><span class="complexity slow">N</span></td>
                            <td><span class="complexity slow">N</span></td>
                        </tr>
                        <tr>
                            <td><strong>Ordered Array</strong></td>
                            <td><span class="complexity slow">N</span></td>
                            <td><span class="complexity fast">1</span></td>
                            <td><span class="complexity fast">1</span></td>
                        </tr>
                        <tr style="background: #e8f5e9;">
                            <td><strong>Binary Heap</strong></td>
                            <td><span class="complexity medium">log N</span></td>
                            <td><span class="complexity medium">log N</span></td>
                            <td><span class="complexity fast">1</span></td>
                        </tr>
                    </tbody>
                </table>

                <div class="key-concept">
                    <h3>üéØ Why Binary Heap is Optimal</h3>
                    <ul class="styled-list">
                        <li><strong>Logarithmic operations:</strong> Both insert and delete max are O(log N)</li>
                        <li><strong>Constant time max:</strong> Getting the maximum is O(1)</li>
                        <li><strong>Space efficient:</strong> Only O(N) space needed</li>
                        <li><strong>Simple implementation:</strong> Just an array with two helper functions</li>
                    </ul>
                </div>

                <h3>Detailed Analysis</h3>
                <div class="important">
                    <h4>Insert Operation</h4>
                    <ul class="styled-list">
                        <li><strong>Best case:</strong> O(1) - element already in correct position</li>
                        <li><strong>Worst case:</strong> O(log N) - swim from bottom to top</li>
                        <li><strong>Average case:</strong> O(log N)</li>
                    </ul>
                </div>

                <div class="important">
                    <h4>Delete Max Operation</h4>
                    <ul class="styled-list">
                        <li><strong>Best case:</strong> O(log N) - still need to check children</li>
                        <li><strong>Worst case:</strong> O(log N) - sink from top to bottom</li>
                        <li><strong>Average case:</strong> O(log N)</li>
                    </ul>
                </div>

                <div class="note">
                    <strong>üí° Why log N?</strong> Because the height of a complete binary tree with N nodes is ‚åälog‚ÇÇ N‚åã, and in the worst case, we traverse from one end to the other.
                </div>
            </section>

            <!-- Section 9: Heapsort -->
            <section id="heapsort">
                <h2>9. Heap Sort</h2>

                <div class="definition">
                    <h3>Heapsort Algorithm</h3>
                    <p><strong>Heapsort</strong> is a comparison-based sorting algorithm that uses a binary heap to sort an array in O(N log N) time using O(1) extra space.</p>
                </div>

                <h3>Algorithm Overview</h3>
                <ol class="styled-list">
                    <li><strong>Build heap:</strong> Rearrange array into a heap</li>
                    <li><strong>Sortdown:</strong> Repeatedly remove the maximum (root) and place at end</li>
                </ol>

                <h3>Using Priority Queue for Sorting</h3>
                <div class="code-block">
<span class="comment">// Simple approach using priority queue</span>
<span class="keyword">public static void</span> sort(Comparable[] a) {
    <span class="keyword">int</span> N = a.length;
    MaxPQ pq = <span class="keyword">new</span> MaxPQ(N);
    
    <span class="comment">// Phase 1: Insert all elements</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = 0; i < N; i++)
        pq.insert(a[i]);
    
    <span class="comment">// Phase 2: Remove in sorted order</span>
    <span class="keyword">for</span> (<span class="keyword">int</span> i = N-1; i >= 0; i--)
        a[i] = pq.delMax();
}
                </div>

                <h3>Time Complexity</h3>
                <div class="key-concept">
                    <h4>‚è±Ô∏è Runtime Analysis</h4>
                    <ul class="styled-list">
                        <li><strong>Building heap:</strong> O(N log N) with repeated inserts</li>
                        <li><strong>Removing all elements:</strong> O(N log N)</li>
                        <li><strong>Total:</strong> O(N log N)</li>
                        <li><strong>Space:</strong> O(N) for the heap</li>
                    </ul>
                </div>

                <h3>Comparison with Other Sorts</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Algorithm</th>
                            <th>Time Complexity</th>
                            <th>Space</th>
                            <th>Stable?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td>Insertion Sort</td>
                            <td><span class="complexity slow">O(N¬≤)</span></td>
                            <td><span class="complexity fast">O(1)</span></td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr>
                            <td>Selection Sort</td>
                            <td><span class="complexity slow">O(N¬≤)</span></td>
                            <td><span class="complexity fast">O(1)</span></td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td>Merge Sort</td>
                            <td><span class="complexity medium">O(N log N)</span></td>
                            <td><span class="complexity slow">O(N)</span></td>
                            <td>‚úÖ Yes</td>
                        </tr>
                        <tr style="background: #e8f5e9;">
                            <td><strong>Heap Sort</strong></td>
                            <td><span class="complexity medium">O(N log N)</span></td>
                            <td><span class="complexity fast">O(N)</span></td>
                            <td>‚ùå No</td>
                        </tr>
                        <tr>
                            <td>Quick Sort</td>
                            <td><span class="complexity medium">O(N log N)*</span></td>
                            <td><span class="complexity fast">O(log N)</span></td>
                            <td>‚ùå No</td>
                        </tr>
                    </tbody>
                </table>
                <p style="font-size: 0.9em; color: #666;">* Average case; worst case is O(N¬≤)</p>

                <div class="pros-cons">
                    <div class="pros">
                        <h4>‚úÖ Advantages of Heapsort</h4>
                        <ul>
                            <li>Guaranteed O(N log N) performance</li>
                            <li>In-place sorting (no extra array needed)</li>
                            <li>No worst-case quadratic behavior</li>
                            <li>Simple implementation</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ö†Ô∏è Disadvantages</h4>
                        <ul>
                            <li>Not stable</li>
                            <li>Poor cache performance</li>
                            <li>Slower than quicksort in practice</li>
                            <li>Not adaptive (doesn't benefit from partial order)</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- Section 10: Practice -->
            <section id="practice">
                <h2>10. Practice Problems & Key Concepts</h2>

                <h3>Practice Problem 1: Build a Max Heap</h3>
                <div class="example">
                    <h4>Problem</h4>
                    <p>Insert the following elements into an empty max heap in order: 2, 5, 16, 4, 10, 23, 39, 18, 26, 15</p>
                    
                    <h4>Solution Steps</h4>
                    <p>The solution requires building up the heap one element at a time, swimming up after each insertion. The final heap should be:</p>
                    <div class="visualization">
                        <pre>
           39
          /  \
        26    23
       / \   / \
     18  15 16  5
     / \ /
    2  4 10
                        </pre>
                        <p>Array: [-, 39, 26, 23, 18, 15, 16, 5, 2, 4, 10]</p>
                    </div>
                </div>

                <h3>Practice Problem 2: Delete Operations</h3>
                <div class="example">
                    <h4>Problem</h4>
                    <p>From the heap above, perform three deleteMax() operations. Show the heap after each deletion.</p>
                    
                    <h4>Hint</h4>
                    <p>Remember: Exchange root with last element, remove last, then sink down.</p>
                </div>

                <h3>Practice Problem 3: Is this a Heap?</h3>
                <div class="example">
                    <h4>Problem</h4>
                    <p>Determine if the following binary tree is a valid max heap:</p>
                    <pre>
        8
       / \
      30  12
     / \  / \
    60 40 50 60
                    </pre>
                    <h4>Answer</h4>
                    <p><strong>NO</strong> - The smallest element in a heap should always be found in the root node. Here, 8 is the root but it's smaller than its children (30 and 12), violating the heap-order property.</p>
                </div>

                <h3>üéØ Key Concepts to Remember</h3>
                <div class="important">
                    <ul class="styled-list">
                        <li><strong>Complete Binary Tree:</strong> All levels filled except possibly last, which fills left-to-right</li>
                        <li><strong>Heap-Order Property:</strong> Parent ‚â• Children (max heap) or Parent ‚â§ Children (min heap)</li>
                        <li><strong>Array Representation:</strong> Parent at k/2, children at 2k and 2k+1</li>
                        <li><strong>Root is at index 1:</strong> Makes math simpler (parent = k/2)</li>
                        <li><strong>Maximum always at root:</strong> O(1) access to max element</li>
                        <li><strong>Height is ‚åälog N‚åã:</strong> Guarantees logarithmic operations</li>
                        <li><strong>Swim up:</strong> Used after insert, compares with parent</li>
                        <li><strong>Sink down:</strong> Used after delete max, compares with larger child</li>
                        <li><strong>Both operations:</strong> O(log N) time complexity</li>
                        <li><strong>No explicit links needed:</strong> Array arithmetic handles navigation</li>
                    </ul>
                </div>

                <h3>üìö Study Tips</h3>
                <div class="note">
                    <ul class="styled-list">
                        <li><strong>Draw it out:</strong> Visualize heap operations by drawing trees</li>
                        <li><strong>Trace the code:</strong> Follow swim and sink operations step-by-step</li>
                        <li><strong>Understand the why:</strong> Know why we swap with larger child in sink</li>
                        <li><strong>Practice array indexing:</strong> Get comfortable with k/2, 2k, 2k+1</li>
                        <li><strong>Memorize complexities:</strong> Insert O(log N), Delete Max O(log N), Get Max O(1)</li>
                        <li><strong>Compare implementations:</strong> Understand trade-offs vs other data structures</li>
                    </ul>
                </div>

                <h3>Common Mistakes to Avoid</h3>
                <div class="important">
                    <ul class="styled-list">
                        <li>‚ùå Starting array at index 0 (makes parent/child math harder)</li>
                        <li>‚ùå Forgetting to set deleted elements to null (memory leak)</li>
                        <li>‚ùå Swapping with smaller child in sink (violates heap order)</li>
                        <li>‚ùå Not checking array bounds in sink</li>
                        <li>‚ùå Confusing max heap with min heap properties</li>
                        <li>‚ùå Thinking heap is sorted (it's only partially ordered)</li>
                    </ul>
                </div>
            </section>
        </div>

        <footer>
            <p>üìö CS210 - Data Structures and Algorithms</p>
            <p>Study Guide: Heaps & Priority Queues | Good luck with your studies! üöÄ</p>
        </footer>
    </div>
</body>
</html>