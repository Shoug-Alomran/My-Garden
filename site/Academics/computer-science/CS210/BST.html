<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Binary Search Trees - Comprehensive Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #8B0000 0%, #DC143C 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .nav {
            background: #2c3e50;
            padding: 15px;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .nav ul {
            list-style: none;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 20px;
        }

        .nav a {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background 0.3s;
        }

        .nav a:hover {
            background: #34495e;
        }

        .content {
            padding: 40px;
        }

        section {
            margin-bottom: 50px;
            scroll-margin-top: 70px;
        }

        h2 {
            color: #8B0000;
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid #DC143C;
        }

        h3 {
            color: #DC143C;
            font-size: 1.5em;
            margin: 25px 0 15px 0;
        }

        h4 {
            color: #555;
            font-size: 1.2em;
            margin: 20px 0 10px 0;
        }

        .definition-box {
            background: #fff3cd;
            border-left: 5px solid #ffc107;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .important-box {
            background: #f8d7da;
            border-left: 5px solid #dc3545;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .tip-box {
            background: #d1ecf1;
            border-left: 5px solid #17a2b8;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .success-box {
            background: #d4edda;
            border-left: 5px solid #28a745;
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }

        .code-block .keyword {
            color: #ff79c6;
        }

        .code-block .function {
            color: #50fa7b;
        }

        .code-block .comment {
            color: #6272a4;
            font-style: italic;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        th {
            background: #8B0000;
            color: white;
            padding: 15px;
            text-align: left;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        tr:hover {
            background: #f5f5f5;
        }

        ul, ol {
            margin: 15px 0 15px 30px;
        }

        li {
            margin: 8px 0;
        }

        .complexity {
            display: inline-block;
            padding: 5px 10px;
            border-radius: 5px;
            font-family: monospace;
            font-weight: bold;
        }

        .complexity.good {
            background: #d4edda;
            color: #155724;
        }

        .complexity.average {
            background: #fff3cd;
            color: #856404;
        }

        .complexity.bad {
            background: #f8d7da;
            color: #721c24;
        }

        .visual-example {
            background: #f8f9fa;
            padding: 30px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }

        .tree-diagram {
            font-family: monospace;
            white-space: pre;
            display: inline-block;
            text-align: left;
            background: white;
            padding: 20px;
            border-radius: 5px;
            border: 2px solid #ddd;
        }

        .operation-steps {
            counter-reset: step;
        }

        .operation-steps li {
            counter-increment: step;
            margin: 15px 0;
            padding-left: 40px;
            position: relative;
        }

        .operation-steps li::before {
            content: counter(step);
            position: absolute;
            left: 0;
            top: 0;
            background: #8B0000;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 30px;
        }

        .highlight {
            background: #ffeb3b;
            padding: 2px 5px;
            border-radius: 3px;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }

            header h1 {
                font-size: 1.8em;
            }

            .nav ul {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üìö Binary Search Trees</h1>
            <p>CS210 - Week 10 Study Guide</p>
            <p style="font-size: 0.9em; margin-top: 10px;">Sedgewick & Wayne - Algorithms 4th Edition</p>
        </header>

        <nav class="nav">
            <ul>
                <li><a href="#introduction">Introduction</a></li>
                <li><a href="#basics">BST Basics</a></li>
                <li><a href="#operations">Operations</a></li>
                <li><a href="#deletion">Deletion</a></li>
                <li><a href="#analysis">Analysis</a></li>
                <li><a href="#implementation">Implementation</a></li>
                <li><a href="#summary">Summary</a></li>
            </ul>
        </nav>

        <div class="content">
            <!-- Introduction Section -->
            <section id="introduction">
                <h2>üéØ Introduction to Binary Search Trees</h2>
                
                <div class="definition-box">
                    <h3>What is a Binary Search Tree (BST)?</h3>
                    <p>A BST is a <strong>binary tree in symmetric order</strong>. This means:</p>
                    <ul>
                        <li>Each node contains a key and an associated value</li>
                        <li>Every node's key is <strong>larger than all keys in its left subtree</strong></li>
                        <li>Every node's key is <strong>smaller than all keys in its right subtree</strong></li>
                    </ul>
                </div>

                <h3>Binary Tree Structure</h3>
                <p>A binary tree is either:</p>
                <ul>
                    <li><strong>Empty</strong> (null)</li>
                    <li>A node with references to <strong>two disjoint binary trees</strong> (left and right subtrees)</li>
                </ul>

                <div class="visual-example">
                    <h4>BST Anatomy</h4>
                    <div class="tree-diagram">
        E (root)
       / \
      /   \
     A     S
      \   / \
       C R   X
        / \
       H   
        \
         M
                    </div>
                    <p style="margin-top: 15px;"><strong>Note:</strong> Keys smaller than E are on the left, keys larger than E are on the right</p>
                </div>
            </section>

            <!-- BST Basics Section -->
            <section id="basics">
                <h2>üèóÔ∏è BST Fundamentals</h2>

                <h3>Node Structure</h3>
                <div class="code-block">
<span class="keyword">private class</span> Node {
    <span class="keyword">private</span> Key key;           <span class="comment">// sorted by key</span>
    <span class="keyword">private</span> Value val;         <span class="comment">// associated value</span>
    <span class="keyword">private</span> Node left, right;  <span class="comment">// left and right subtrees</span>
    
    <span class="keyword">public</span> <span class="function">Node</span>(Key key, Value val) {
        <span class="keyword">this</span>.key = key;
        <span class="keyword">this</span>.val = val;
    }
}
                </div>

                <div class="important-box">
                    <h4>‚ö†Ô∏è Key Requirements</h4>
                    <p>The <strong>Key</strong> type must implement <code>Comparable</code> interface for ordering operations.</p>
                    <p>Keys must be <strong>unique</strong> and support comparison operations.</p>
                </div>

                <h3>BST Properties</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Property</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Symmetric Order</strong></td>
                            <td>Left subtree < Node < Right subtree</td>
                        </tr>
                        <tr>
                            <td><strong>Root</strong></td>
                            <td>Top node of the tree</td>
                        </tr>
                        <tr>
                            <td><strong>Leaf</strong></td>
                            <td>Node with no children (both links null)</td>
                        </tr>
                        <tr>
                            <td><strong>Parent</strong></td>
                            <td>Node that has a link to another node</td>
                        </tr>
                        <tr>
                            <td><strong>Depth</strong></td>
                            <td>Number of links from root to node</td>
                        </tr>
                        <tr>
                            <td><strong>Height</strong></td>
                            <td>Maximum depth of any node</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- Operations Section -->
            <section id="operations">
                <h2>‚öôÔ∏è BST Operations</h2>

                <h3>1. Search Operation</h3>
                <div class="tip-box">
                    <h4>Search Algorithm</h4>
                    <p><strong>Rule:</strong> If less, go left; if greater, go right; if equal, search hit!</p>
                </div>

                <div class="code-block">
<span class="keyword">public</span> Value <span class="function">get</span>(Key key) {
    Node x = root;
    <span class="keyword">while</span> (x != <span class="keyword">null</span>) {
        <span class="keyword">int</span> cmp = key.compareTo(x.key);
        <span class="keyword">if</span>      (cmp &lt; 0) x = x.left;   <span class="comment">// go left</span>
        <span class="keyword">else if</span> (cmp &gt; 0) x = x.right;  <span class="comment">// go right</span>
        <span class="keyword">else</span>              <span class="keyword">return</span> x.val;   <span class="comment">// found!</span>
    }
    <span class="keyword">return null</span>;  <span class="comment">// not found</span>
}
                </div>

                <div class="success-box">
                    <h4>‚úÖ Search Complexity</h4>
                    <p><strong>Cost:</strong> Number of compares = 1 + depth of node</p>
                    <p><strong>Best case:</strong> <span class="complexity good">O(log n)</span> for balanced tree</p>
                    <p><strong>Worst case:</strong> <span class="complexity bad">O(n)</span> for degenerate tree</p>
                </div>

                <h3>2. Insert Operation</h3>
                <div class="tip-box">
                    <h4>Insert Algorithm</h4>
                    <p><strong>Rule:</strong> If less, go left; if greater, go right; if null, insert!</p>
                </div>

                <div class="code-block">
<span class="keyword">public void</span> <span class="function">put</span>(Key key, Value val) {
    root = put(root, key, val);
}

<span class="keyword">private</span> Node <span class="function">put</span>(Node x, Key key, Value val) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return new</span> Node(key, val);  <span class="comment">// insert here</span>
    
    <span class="keyword">int</span> cmp = key.compareTo(x.key);
    <span class="keyword">if</span>      (cmp &lt; 0) x.left  = put(x.left,  key, val);
    <span class="keyword">else if</span> (cmp &gt; 0) x.right = put(x.right, key, val);
    <span class="keyword">else</span>              x.val   = val;  <span class="comment">// update value</span>
    
    <span class="keyword">return</span> x;  <span class="comment">// reset links on recursive path</span>
}
                </div>

                <h4>Insert Example: Adding G to a BST</h4>
                <div class="visual-example">
                    <div class="tree-diagram">
Before:              After:
    S                    S
   / \                  / \
  E   X                E   X
 / \                  / \
A   R                A   R
     \                   / \
      H                 H
       \                 \
        M                 M
                         /
                        G  ‚Üê NEW
                    </div>
                    <ol class="operation-steps">
                        <li>Start at root S (G < S, go left)</li>
                        <li>Compare with E (G > E, go right)</li>
                        <li>Compare with R (G < R, go left)</li>
                        <li>Compare with H (G < H, go left)</li>
                        <li>H.left is null ‚Üí Insert G here!</li>
                    </ol>
                </div>

                <h3>3. Finding Minimum/Maximum</h3>
                <div class="code-block">
<span class="comment">// Minimum: go left until reaching null</span>
<span class="keyword">private</span> Node <span class="function">min</span>(Node x) {
    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x;
    <span class="keyword">return</span> min(x.left);
}

<span class="comment">// Maximum: go right until reaching null</span>
<span class="keyword">private</span> Node <span class="function">max</span>(Node x) {
    <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x;
    <span class="keyword">return</span> max(x.right);
}
                </div>
            </section>

            <!-- Deletion Section -->
            <section id="deletion">
                <h2>üóëÔ∏è BST Deletion (Hibbard Deletion)</h2>

                <div class="important-box">
                    <h4>‚ö†Ô∏è Deletion Complexity</h4>
                    <p>Deletion is the most complex operation in BSTs. There are <strong>three cases</strong> to handle.</p>
                </div>

                <h3>Case 0: No Children (Leaf Node)</h3>
                <div class="success-box">
                    <p><strong>Solution:</strong> Simply delete the node by setting the parent link to null.</p>
                </div>
                <div class="visual-example">
                    <div class="tree-diagram">
Delete C:
    E               E
   / \             / \
  A   S    ‚Üí      A   S
   \               
    C (DELETE)     (removed)
                    </div>
                </div>

                <h3>Case 1: One Child</h3>
                <div class="success-box">
                    <p><strong>Solution:</strong> Replace the node with its child (bypass the node).</p>
                </div>
                <div class="visual-example">
                    <div class="tree-diagram">
Delete R:
    E               E
   / \             / \
  A   S    ‚Üí      A   S
     / \             / \
    R   X           H   X
     \               \
      H               M
       \
        M
                    </div>
                </div>

                <h3>Case 2: Two Children (Most Complex)</h3>
                <div class="important-box">
                    <h4>Hibbard Deletion Algorithm</h4>
                    <ol class="operation-steps">
                        <li>Find the node <code>t</code> to delete</li>
                        <li>Find successor <code>x</code> = minimum node in <code>t</code>'s right subtree</li>
                        <li>Delete the minimum in <code>t</code>'s right subtree</li>
                        <li>Replace <code>t</code> with <code>x</code>:
                            <ul style="margin-top: 10px;">
                                <li>Set <code>x.left = t.left</code></li>
                                <li>Set <code>x.right = deleteMin(t.right)</code></li>
                            </ul>
                        </li>
                    </ol>
                </div>

                <div class="visual-example">
                    <h4>Example: Deleting E (has 2 children)</h4>
                    <div class="tree-diagram">
Step 1: Find successor (min of right subtree)
    E ‚Üê DELETE          Successor = H (min in right subtree)
   / \
  A   S
 / \ / \
C  H R  X
    \
     M

Step 2: Delete minimum from right subtree
    E
   / \
  A   S
 /   / \
C   R   X
     \
      M

Step 3: Replace E with H
    H ‚Üê NEW ROOT
   / \
  A   S
 /   / \
C   R   X
     \
      M
                    </div>
                </div>

                <h3>Delete Minimum Helper Function</h3>
                <div class="code-block">
<span class="keyword">private</span> Node <span class="function">deleteMin</span>(Node x) {
    <span class="keyword">if</span> (x.left == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;  <span class="comment">// replace with right child</span>
    x.left = deleteMin(x.left);  <span class="comment">// recurse left</span>
    x.count = 1 + size(x.left) + size(x.right);  <span class="comment">// update count</span>
    <span class="keyword">return</span> x;
}
                </div>

                <h3>Complete Delete Implementation</h3>
                <div class="code-block">
<span class="keyword">public void</span> <span class="function">delete</span>(Key key) {
    root = delete(root, key);
}

<span class="keyword">private</span> Node <span class="function">delete</span>(Node x, Key key) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return null</span>;
    
    <span class="keyword">int</span> cmp = key.compareTo(x.key);
    <span class="keyword">if</span>      (cmp &lt; 0) x.left  = delete(x.left,  key);
    <span class="keyword">else if</span> (cmp &gt; 0) x.right = delete(x.right, key);
    <span class="keyword">else</span> {  <span class="comment">// found node to delete</span>
        <span class="comment">// Case 0 & 1: no right child or no left child</span>
        <span class="keyword">if</span> (x.right == <span class="keyword">null</span>) <span class="keyword">return</span> x.left;
        <span class="keyword">if</span> (x.left  == <span class="keyword">null</span>) <span class="keyword">return</span> x.right;
        
        <span class="comment">// Case 2: two children - use Hibbard deletion</span>
        Node t = x;
        x = min(t.right);              <span class="comment">// find successor</span>
        x.right = deleteMin(t.right);  <span class="comment">// delete successor from right</span>
        x.left = t.left;               <span class="comment">// attach left subtree</span>
    }
    x.count = size(x.left) + size(x.right) + 1;
    <span class="keyword">return</span> x;
}
                </div>

                <div class="important-box">
                    <h4>‚ö†Ô∏è Hibbard Deletion Problem</h4>
                    <p><strong>Unsatisfactory solution:</strong> Not symmetric!</p>
                    <p><strong>Consequence:</strong> Trees become unbalanced after many deletions</p>
                    <p><strong>Performance degradation:</strong> ‚àöN per operation (instead of log N)</p>
                    <p><strong>Open problem:</strong> Simple and efficient delete for BSTs remains unsolved!</p>
                </div>

                <h3>Lazy Deletion Alternative</h3>
                <div class="tip-box">
                    <h4>Tombstone Approach</h4>
                    <ul>
                        <li>Set the node's value to null</li>
                        <li>Leave key in tree to guide searches</li>
                        <li>Don't consider it equal during search</li>
                    </ul>
                    <p><strong>Problem:</strong> Memory overhead increases over time (tombstone overload)</p>
                    <p><strong>Cost:</strong> ~2 ln N' where N' = total keys ever inserted</p>
                </div>
            </section>

            <!-- Analysis Section -->
            <section id="analysis">
                <h2>üìä Performance Analysis</h2>

                <h3>Tree Shape Matters!</h3>
                <div class="visual-example">
                    <div class="tree-diagram">
Best Case (Balanced):    Typical Case:       Worst Case (Degenerate):
       H                      S                    A
      / \                    / \                    \
     C   S                  E   X                    C
    / \ / \                / \                        \
   A E R X               A   R                         E
                          \   \                         \
                           C   H                         H
                                \                         \
                                 M                         M
                                                            \
Height: log N                log N               Height: N    R
O(log n)                    O(log n)                O(n)      \
                                                                S
                                                                 \
                                                                  X
                    </div>
                </div>

                <h3>Mathematical Analysis</h3>
                <div class="success-box">
                    <h4>Random Insertion (Average Case)</h4>
                    <p><strong>Proposition:</strong> If N distinct keys are inserted in random order:</p>
                    <ul>
                        <li>Expected number of compares: <span class="complexity good">~2 ln N ‚âà 1.39 log‚ÇÇ N</span></li>
                        <li>Expected tree height: <span class="complexity good">~4.311 ln N</span> (Reed, 2003)</li>
                    </ul>
                    <p><strong>Proof:</strong> 1-1 correspondence with quicksort partitioning</p>
                </div>

                <div class="important-box">
                    <h4>Worst Case</h4>
                    <ul>
                        <li>Height: <span class="complexity bad">N - 1</span> (linked list)</li>
                        <li>Occurs when keys inserted in sorted order</li>
                        <li>Probability: <strong>Exponentially small</strong> for random insertions</li>
                    </ul>
                </div>

                <h3>Complexity Summary Table</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>Best Case</th>
                            <th>Average Case</th>
                            <th>Worst Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Search</strong></td>
                            <td><span class="complexity good">log N</span></td>
                            <td><span class="complexity good">1.39 log N</span></td>
                            <td><span class="complexity bad">N</span></td>
                        </tr>
                        <tr>
                            <td><strong>Insert</strong></td>
                            <td><span class="complexity good">log N</span></td>
                            <td><span class="complexity good">1.39 log N</span></td>
                            <td><span class="complexity bad">N</span></td>
                        </tr>
                        <tr>
                            <td><strong>Delete</strong></td>
                            <td><span class="complexity good">log N</span></td>
                            <td><span class="complexity average">‚àöN</span></td>
                            <td><span class="complexity bad">N</span></td>
                        </tr>
                        <tr>
                            <td><strong>Min/Max</strong></td>
                            <td><span class="complexity good">log N</span></td>
                            <td><span class="complexity good">1.39 log N</span></td>
                            <td><span class="complexity bad">N</span></td>
                        </tr>
                    </tbody>
                </table>

                <div class="important-box">
                    <h4>‚ö†Ô∏è Delete Performance Degradation</h4>
                    <p>After many deletions using Hibbard deletion, trees become unbalanced!</p>
                    <p>All operations degrade to <span class="complexity average">‚àöN</span> on average</p>
                </div>
            </section>

            <!-- Implementation Section -->
            <section id="implementation">
                <h2>üíª Complete BST Implementation</h2>

                <h3>Class Structure</h3>
                <div class="code-block">
<span class="keyword">public class</span> BST&lt;Key <span class="keyword">extends</span> Comparable&lt;Key&gt;, Value&gt; {
    <span class="keyword">private</span> Node root;  <span class="comment">// root of BST</span>
    
    <span class="keyword">private class</span> Node {
        <span class="keyword">private</span> Key key;
        <span class="keyword">private</span> Value val;
        <span class="keyword">private</span> Node left, right;
        <span class="keyword">private int</span> count;  <span class="comment">// number of nodes in subtree</span>
        
        <span class="keyword">public</span> <span class="function">Node</span>(Key key, Value val) {
            <span class="keyword">this</span>.key = key;
            <span class="keyword">this</span>.val = val;
            <span class="keyword">this</span>.count = 1;
        }
    }
    
    <span class="keyword">public void</span> <span class="function">put</span>(Key key, Value val) { <span class="comment">/* see above */</span> }
    <span class="keyword">public</span> Value <span class="function">get</span>(Key key) { <span class="comment">/* see above */</span> }
    <span class="keyword">public void</span> <span class="function">delete</span>(Key key) { <span class="comment">/* see above */</span> }
    <span class="keyword">public</span> Iterable&lt;Key&gt; <span class="function">iterator</span>() { <span class="comment">/* inorder traversal */</span> }
}
                </div>

                <h3>Additional Useful Methods</h3>
                <div class="code-block">
<span class="comment">// Size: number of nodes in tree</span>
<span class="keyword">public int</span> <span class="function">size</span>() {
    <span class="keyword">return</span> size(root);
}

<span class="keyword">private int</span> <span class="function">size</span>(Node x) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> 0;
    <span class="keyword">return</span> x.count;
}

<span class="comment">// Height: maximum depth</span>
<span class="keyword">public int</span> <span class="function">height</span>() {
    <span class="keyword">return</span> height(root);
}

<span class="keyword">private int</span> <span class="function">height</span>(Node x) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span> -1;
    <span class="keyword">return</span> 1 + Math.max(height(x.left), height(x.right));
}

<span class="comment">// Floor: largest key ‚â§ given key</span>
<span class="keyword">public</span> Key <span class="function">floor</span>(Key key) {
    Node x = floor(root, key);
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return null</span>;
    <span class="keyword">return</span> x.key;
}

<span class="keyword">private</span> Node <span class="function">floor</span>(Node x, Key key) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return null</span>;
    <span class="keyword">int</span> cmp = key.compareTo(x.key);
    <span class="keyword">if</span> (cmp == 0) <span class="keyword">return</span> x;
    <span class="keyword">if</span> (cmp &lt; 0) <span class="keyword">return</span> floor(x.left, key);
    Node t = floor(x.right, key);
    <span class="keyword">if</span> (t != <span class="keyword">null</span>) <span class="keyword">return</span> t;
    <span class="keyword">else return</span> x;
}
                </div>

                <h3>Tree Traversals</h3>
                <div class="code-block">
<span class="comment">// Inorder: Left ‚Üí Node ‚Üí Right (gives sorted order!)</span>
<span class="keyword">private void</span> <span class="function">inorder</span>(Node x) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;
    inorder(x.left);
    System.out.println(x.key);
    inorder(x.right);
}

<span class="comment">// Preorder: Node ‚Üí Left ‚Üí Right</span>
<span class="keyword">private void</span> <span class="function">preorder</span>(Node x) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;
    System.out.println(x.key);
    preorder(x.left);
    preorder(x.right);
}

<span class="comment">// Postorder: Left ‚Üí Right ‚Üí Node</span>
<span class="keyword">private void</span> <span class="function">postorder</span>(Node x) {
    <span class="keyword">if</span> (x == <span class="keyword">null</span>) <span class="keyword">return</span>;
    postorder(x.left);
    postorder(x.right);
    System.out.println(x.key);
}
                </div>

                <div class="tip-box">
                    <h4>üí° Traversal Tip</h4>
                    <p><strong>Inorder traversal of a BST produces keys in sorted order!</strong></p>
                    <p>This is why it's called "symmetric order" - the inorder traversal respects the ordering.</p>
                </div>
            </section>

            <!-- Summary Section -->
            <section id="summary">
                <h2>üìù Summary & Comparison</h2>

                <h3>Symbol Table Implementation Comparison</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Implementation</th>
                            <th>Search (Worst)</th>
                            <th>Insert (Worst)</th>
                            <th>Delete (Worst)</th>
                            <th>Search (Avg)</th>
                            <th>Insert (Avg)</th>
                            <th>Delete (Avg)</th>
                            <th>Ordered?</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Sequential Search</strong><br>(Unordered List)</td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N/2</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N/2</span></td>
                            <td>‚ùå</td>
                        </tr>
                        <tr>
                            <td><strong>Binary Search</strong><br>(Ordered Array)</td>
                            <td><span class="complexity good">log N</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity good">log N</span></td>
                            <td><span class="complexity bad">N/2</span></td>
                            <td><span class="complexity bad">N/2</span></td>
                            <td>‚úÖ</td>
                        </tr>
                        <tr>
                            <td><strong>BST</strong></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity bad">N</span></td>
                            <td><span class="complexity good">1.39 log N</span></td>
                            <td><span class="complexity good">1.39 log N</span></td>
                            <td><span class="complexity average">‚àöN</span></td>
                            <td>‚úÖ</td>
                        </tr>
                    </tbody>
                </table>

                <h3>Key Takeaways</h3>
                <div class="success-box">
                    <h4>‚úÖ BST Advantages</h4>
                    <ul>
                        <li>Efficient search and insert: <strong>O(log N)</strong> on average</li>
                        <li>Supports ordered operations (min, max, floor, ceiling, rank)</li>
                        <li>Inorder traversal gives sorted order</li>
                        <li>Dynamic structure (no need to specify size upfront)</li>
                        <li>Simple recursive implementation</li>
                    </ul>
                </div>

                <div class="important-box">
                    <h4>‚ö†Ô∏è BST Limitations</h4>
                    <ul>
                        <li>No performance guarantee: can degenerate to <strong>O(N)</strong></li>
                        <li>Shape depends on insertion order</li>
                        <li>Delete operation degrades performance to <strong>‚àöN</strong></li>
                        <li>Not suitable when guaranteed performance is required</li>
                    </ul>
                </div>

                <div class="tip-box">
                    <h4>üöÄ What's Next?</h4>
                    <p><strong>Balanced BSTs</strong> solve the performance guarantee problem!</p>
                    <ul>
                        <li><strong>2-3 Trees</strong>: Guaranteed log N performance</li>
                        <li><strong>Red-Black Trees</strong>: Practical implementation of balanced BSTs</li>
                        <li><strong>AVL Trees</strong>: Strictly balanced trees</li>
                        <li><strong>B-Trees</strong>: For disk-based storage</li>
                    </ul>
                    <p>Next lecture will cover how to <strong>guarantee logarithmic performance</strong> for all operations!</p>
                </div>

                <h3>Quick Reference Card</h3>
                <div class="visual-example">
                    <h4>BST Operations Cheat Sheet</h4>
                    <table style="background: white;">
                        <thead>
                            <tr>
                                <th>Operation</th>
                                <th>Algorithm</th>
                                <th>Complexity (Avg)</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><strong>Search</strong></td>
                                <td>Compare, go left/right, repeat</td>
                                <td><span class="complexity good">O(log N)</span></td>
                            </tr>
                            <tr>
                                <td><strong>Insert</strong></td>
                                <td>Search, insert at null link</td>
                                <td><span class="complexity good">O(log N)</span></td>
                            </tr>
                            <tr>
                                <td><strong>Delete (0 children)</strong></td>
                                <td>Set parent link to null</td>
                                <td><span class="complexity good">O(log N)</span></td>
                            </tr>
                            <tr>
                                <td><strong>Delete (1 child)</strong></td>
                                <td>Replace with child</td>
                                <td><span class="complexity good">O(log N)</span></td>
                            </tr>
                            <tr>
                                <td><strong>Delete (2 children)</strong></td>
                                <td>Replace with successor (Hibbard)</td>
                                <td><span class="complexity average">O(‚àöN)</span></td>
                            </tr>
                            <tr>
                                <td><strong>Min/Max</strong></td>
                                <td>Go all left/right</td>
                                <td><span class="complexity good">O(log N)</span></td>
                            </tr>
                            <tr>
                                <td><strong>Floor/Ceiling</strong></td>
                                <td>Search with fallback logic</td>
                                <td><span class="complexity good">O(log N)</span></td>
                            </tr>
                        </tbody>
                    </table>
                </div>

                <h3>Study Tips</h3>
                <div class="tip-box">
                    <h4>üìö How to Master BSTs</h4>
                    <ol class="operation-steps">
                        <li><strong>Draw trees!</strong> Practice drawing insertion and deletion by hand</li>
                        <li><strong>Trace algorithms:</strong> Follow the recursive calls step by step</li>
                        <li><strong>Compare cases:</strong> Best vs average vs worst - understand when each occurs</li>
                        <li><strong>Implement from scratch:</strong> Code it without looking at notes</li>
                        <li><strong>Analyze complexity:</strong> Always count comparisons and consider tree height</li>
                    </ol>
                </div>

                <h3>Common Exam Questions</h3>
                <div class="important-box">
                    <h4>üéì Practice Problems</h4>
                    <ul>
                        <li>Draw the BST resulting from inserting keys in order: 5, 2, 8, 1, 3, 7, 9</li>
                        <li>Show step-by-step deletion of a node with 2 children</li>
                        <li>What is the worst-case height of a BST with N nodes?</li>
                        <li>Why does Hibbard deletion degrade performance?</li>
                        <li>Compare BST vs Binary Search on arrays - when to use each?</li>
                        <li>Write recursive code for BST traversals (inorder, preorder, postorder)</li>
                    </ul>
                </div>
            </section>
        </div>

        <footer>
            <p><strong>CS210 - Binary Search Trees Study Guide</strong></p>
            <p>Based on Sedgewick & Wayne, Algorithms 4th Edition</p>
            <p style="margin-top: 15px; font-size: 0.9em;">üìñ Keep studying! Practice makes perfect! üöÄ</p>
        </footer>
    </div>
</body>
</html>