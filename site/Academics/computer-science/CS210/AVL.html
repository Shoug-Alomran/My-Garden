<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AVL Trees - Comprehensive Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #333;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 40px;
            text-align: center;
        }

        header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        header p {
            font-size: 1.2em;
            opacity: 0.9;
        }

        .content {
            padding: 40px;
        }

        .section {
            margin-bottom: 40px;
            padding: 30px;
            background: #f8f9fa;
            border-radius: 10px;
            border-left: 5px solid #667eea;
        }

        .section h2 {
            color: #667eea;
            margin-bottom: 20px;
            font-size: 2em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .section h3 {
            color: #764ba2;
            margin: 20px 0 15px 0;
            font-size: 1.5em;
        }

        .definition {
            background: #e3f2fd;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #2196F3;
        }

        .key-point {
            background: #fff3e0;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #ff9800;
        }

        .formula {
            background: #f3e5f5;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.2em;
            border-left: 4px solid #9c27b0;
        }

        .example {
            background: #e8f5e9;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            border-left: 4px solid #4caf50;
        }

        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .comparison-table th {
            background: #667eea;
            color: white;
            padding: 15px;
            text-align: left;
        }

        .comparison-table td {
            padding: 12px 15px;
            border-bottom: 1px solid #ddd;
        }

        .comparison-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .comparison-table tr:hover {
            background: #e3f2fd;
        }

        code {
            background: #f4f4f4;
            padding: 3px 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
            color: #d63384;
        }

        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            line-height: 1.5;
        }

        .rotation-types {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .rotation-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            border-top: 4px solid #667eea;
        }

        .rotation-card h4 {
            color: #667eea;
            margin-bottom: 10px;
        }

        ul, ol {
            margin-left: 20px;
            margin-top: 10px;
        }

        li {
            margin-bottom: 8px;
        }

        .highlight {
            background: yellow;
            padding: 2px 5px;
            border-radius: 3px;
        }

        .complexity-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 20px;
            font-weight: bold;
            margin: 5px;
        }

        .complexity-good {
            background: #4caf50;
            color: white;
        }

        .complexity-bad {
            background: #f44336;
            color: white;
        }

        .tree-diagram {
            text-align: center;
            padding: 20px;
            background: white;
            border-radius: 8px;
            margin: 20px 0;
            font-family: monospace;
            font-size: 0.9em;
        }

        .note {
            background: #fff9c4;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #fbc02d;
        }

        .important {
            background: #ffebee;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            border-left: 4px solid #f44336;
            font-weight: bold;
        }

        @media (max-width: 768px) {
            .content {
                padding: 20px;
            }
            
            header h1 {
                font-size: 1.8em;
            }
            
            .rotation-types {
                grid-template-columns: 1fr;
            }
        }
    </style>
  <script src="/javascripts/standalone-theme.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>üå≥ AVL Trees Study Guide</h1>
            <p>Self-Balancing Binary Search Trees</p>
        </header>

        <div class="content">
            <!-- Introduction -->
            <div class="section">
                <h2>üìö Introduction to AVL Trees</h2>
                
                <div class="definition">
                    <h3>What is an AVL Tree?</h3>
                    <p>An <strong>AVL tree</strong> is a <span class="highlight">self-balancing binary search tree</span> named after its inventors Adelson-Velsky and Landis. It maintains a balanced structure by ensuring that for every internal node, the heights of its two children differ by at most 1.</p>
                </div>

                <div class="key-point">
                    <strong>Key Property:</strong> For every internal node v, the heights of the children can differ by <strong>at most 1</strong>.
                    <br><br>
                    Mathematically: <code>|height(left) - height(right)| ‚â§ 1</code>
                </div>

                <h3>Why AVL Trees?</h3>
                <ul>
                    <li><strong>Guaranteed Performance:</strong> Operations are always O(log n)</li>
                    <li><strong>No Worst Case:</strong> Unlike regular BST which can degrade to O(n)</li>
                    <li><strong>Automatic Balancing:</strong> Self-adjusts after insertions and deletions</li>
                    <li><strong>Efficient Searching:</strong> Maintains logarithmic height</li>
                </ul>
            </div>

            <!-- AVL Tree Properties -->
            <div class="section">
                <h2>üéØ AVL Tree Properties</h2>

                <div class="key-point">
                    <h3>Balance Factor</h3>
                    <p>The balance factor of a node is calculated as:</p>
                    <div class="formula">
                        Balance Factor = height(left subtree) - height(right subtree)
                    </div>
                    <p>Valid balance factors: <code>-1, 0, +1</code></p>
                    <ul>
                        <li><strong>+1:</strong> Left subtree is one level taller</li>
                        <li><strong>0:</strong> Both subtrees have equal height</li>
                        <li><strong>-1:</strong> Right subtree is one level taller</li>
                        <li><strong>+2 or -2:</strong> ‚ö†Ô∏è Tree is unbalanced! (needs rotation)</li>
                    </ul>
                </div>

                <h3>Height of AVL Tree</h3>
                <div class="formula">
                    h &lt; 2log(n) + 2
                    <br><br>
                    Therefore: h = O(log n)
                </div>

                <div class="note">
                    <strong>Important Proof Concept:</strong>
                    <br>Let n(h) = minimum number of nodes in an AVL tree of height h
                    <br>‚Ä¢ n(1) = 1
                    <br>‚Ä¢ n(2) = 2
                    <br>‚Ä¢ n(h) = 1 + n(h-1) + n(h-2)
                    <br><br>
                    Since n(h-1) &gt; n(h-2), we get n(h) &gt; 2n(h-2)
                    <br>By induction: n(h) &gt; 2^(h/2-1)
                    <br>Taking logarithms: h &lt; 2log n(h) + 2
                </div>
            </div>

            <!-- Rotations -->
            <div class="section">
                <h2>üîÑ Tree Rotations</h2>

                <div class="important">
                    Rotations are the fundamental operations used to restore balance in an AVL tree. There are 4 types of rotations based on the structure of imbalance.
                </div>

                <h3>When to Use Rotations?</h3>
                <ul>
                    <li>When balance factor becomes +2 or -2</li>
                    <li>After insertion or deletion operations</li>
                    <li>To maintain the AVL property</li>
                </ul>

                <div class="rotation-types">
                    <div class="rotation-card">
                        <h4>1Ô∏è‚É£ Single Right Rotation (LL Case)</h4>
                        <p><strong>When:</strong> Left-Left imbalance (same sign)</p>
                        <p><strong>Pattern:</strong> Left subtree is taller, and imbalance is in left child's left subtree</p>
                        <div class="tree-diagram">
                            z (imbalanced)<br>
                            ‚Üô<br>
                            y<br>
                            ‚Üô<br>
                            x<br>
                            <br>
                            ‚¨á Right Rotation<br>
                            <br>
                            &nbsp;&nbsp;y<br>
                            ‚Üô&nbsp;‚Üò<br>
                            x&nbsp;&nbsp;&nbsp;z
                        </div>
                    </div>

                    <div class="rotation-card">
                        <h4>2Ô∏è‚É£ Single Left Rotation (RR Case)</h4>
                        <p><strong>When:</strong> Right-Right imbalance (same sign)</p>
                        <p><strong>Pattern:</strong> Right subtree is taller, and imbalance is in right child's right subtree</p>
                        <div class="tree-diagram">
                            z (imbalanced)<br>
                            &nbsp;&nbsp;‚Üò<br>
                            &nbsp;&nbsp;y<br>
                            &nbsp;&nbsp;‚Üò<br>
                            &nbsp;&nbsp;x<br>
                            <br>
                            ‚¨á Left Rotation<br>
                            <br>
                            &nbsp;&nbsp;y<br>
                            ‚Üô&nbsp;‚Üò<br>
                            z&nbsp;&nbsp;&nbsp;x
                        </div>
                    </div>

                    <div class="rotation-card">
                        <h4>3Ô∏è‚É£ Left-Right Rotation (LR Case)</h4>
                        <p><strong>When:</strong> Left-Right imbalance (opposite signs)</p>
                        <p><strong>Pattern:</strong> Left subtree is taller, but imbalance is in left child's right subtree</p>
                        <div class="tree-diagram">
                            z<br>
                            ‚Üô<br>
                            y<br>
                            &nbsp;‚Üò<br>
                            &nbsp;x<br>
                            <br>
                            ‚¨á Left then Right<br>
                            <br>
                            &nbsp;&nbsp;x<br>
                            ‚Üô&nbsp;‚Üò<br>
                            y&nbsp;&nbsp;&nbsp;z
                        </div>
                    </div>

                    <div class="rotation-card">
                        <h4>4Ô∏è‚É£ Right-Left Rotation (RL Case)</h4>
                        <p><strong>When:</strong> Right-Left imbalance (opposite signs)</p>
                        <p><strong>Pattern:</strong> Right subtree is taller, but imbalance is in right child's left subtree</p>
                        <div class="tree-diagram">
                            z<br>
                            &nbsp;‚Üò<br>
                            &nbsp;y<br>
                            ‚Üô<br>
                            x<br>
                            <br>
                            ‚¨á Right then Left<br>
                            <br>
                            &nbsp;&nbsp;x<br>
                            ‚Üô&nbsp;‚Üò<br>
                            z&nbsp;&nbsp;&nbsp;y
                        </div>
                    </div>
                </div>

                <div class="note">
                    <strong>üí° Quick Rule:</strong>
                    <ul>
                        <li><strong>Same Sign</strong> (both left or both right) ‚Üí Single Rotation</li>
                        <li><strong>Opposite Signs</strong> (left-right or right-left) ‚Üí Double Rotation</li>
                    </ul>
                </div>

                <h3>Trinode Restructuring</h3>
                <div class="key-point">
                    <p>A general approach to handle all rotation cases:</p>
                    <ol>
                        <li>Let (a, b, c) be the inorder listing of nodes x, y, z</li>
                        <li>Perform rotations to make <strong>b</strong> the topmost node</li>
                        <li>a becomes the left child, c becomes the right child</li>
                        <li>Subtrees T‚ÇÄ, T‚ÇÅ, T‚ÇÇ, T‚ÇÉ are distributed appropriately</li>
                    </ol>
                </div>
            </div>

            <!-- Insertion -->
            <div class="section">
                <h2>‚ûï Insertion in AVL Trees</h2>

                <h3>Algorithm Steps</h3>
                <ol>
                    <li><strong>Insert as in BST:</strong> Find the correct position and insert the new node</li>
                    <li><strong>Update Heights:</strong> Travel up from the inserted node, updating heights</li>
                    <li><strong>Check Balance:</strong> At each ancestor node, check the balance factor</li>
                    <li><strong>Perform Rotation:</strong> If unbalanced (|BF| = 2), perform appropriate rotation</li>
                    <li><strong>Continue Upward:</strong> Continue checking until root is reached</li>
                </ol>

                <div class="example">
                    <h3>üìù Example: Inserting 54</h3>
                    <p>Consider an AVL tree with nodes: 44, 17, 78, 32, 50, 88, 48, 62</p>
                    <p>After inserting 54:</p>
                    <ul>
                        <li>Node 62 becomes unbalanced (balance factor = -2)</li>
                        <li>Pattern: Right-Left (RL case)</li>
                        <li>Solution: Right rotation at 62, then restructure</li>
                        <li>Result: Balanced tree with 54 in correct position</li>
                    </ul>
                </div>

                <div class="important">
                    <strong>Key Insight:</strong> Only <strong>ONE</strong> rotation is needed for insertion! The rotation fixes all imbalances created by the insertion.
                </div>

                <h3>Complexity Analysis</h3>
                <div class="formula">
                    Time Complexity: O(log n)
                </div>
                <ul>
                    <li>Finding insertion point: O(log n)</li>
                    <li>Updating heights: O(log n)</li>
                    <li>Single rotation: O(1)</li>
                    <li>Total: O(log n)</li>
                </ul>
            </div>

            <!-- Deletion -->
            <div class="section">
                <h2>‚ûñ Deletion in AVL Trees</h2>

                <h3>Algorithm Steps</h3>
                <ol>
                    <li><strong>Delete as in BST:</strong> Remove the node using standard BST deletion</li>
                    <li><strong>Start from Parent:</strong> Begin at the parent of the deleted node</li>
                    <li><strong>Update Heights:</strong> Recalculate heights going upward</li>
                    <li><strong>Check Balance:</strong> Check balance factor at each node</li>
                    <li><strong>Perform Rotations:</strong> If unbalanced, perform appropriate rotation</li>
                    <li><strong>Continue to Root:</strong> Must check ALL the way to the root</li>
                </ol>

                <div class="important">
                    <strong>‚ö†Ô∏è Critical Difference from Insertion:</strong>
                    <br>Deletion may require <strong>MULTIPLE rotations</strong> as you travel up to the root! Each rotation might create a new imbalance higher up.
                </div>

                <div class="example">
                    <h3>üìù Example: Deleting 32</h3>
                    <p>From a tree with nodes: 44, 17, 62, 32, 50, 78, 48, 54, 88</p>
                    <ol>
                        <li>Delete node 32 (leaf node)</li>
                        <li>Parent 17 becomes unbalanced</li>
                        <li>Perform rotation at 17</li>
                        <li>Check parent nodes up to root</li>
                        <li>Perform additional rotations if needed</li>
                    </ol>
                </div>

                <h3>BST Deletion Cases</h3>
                <ul>
                    <li><strong>Case 1:</strong> Node has no children (leaf) ‚Üí Simply remove</li>
                    <li><strong>Case 2:</strong> Node has one child ‚Üí Replace node with its child</li>
                    <li><strong>Case 3:</strong> Node has two children ‚Üí Replace with inorder successor/predecessor</li>
                </ul>

                <h3>Complexity Analysis</h3>
                <div class="formula">
                    Time Complexity: O(log n)
                </div>
                <ul>
                    <li>Finding node: O(log n)</li>
                    <li>Deleting node: O(1)</li>
                    <li>Rebalancing (multiple rotations): O(log n)</li>
                    <li>Total: O(log n)</li>
                </ul>
            </div>

            <!-- Performance Comparison -->
            <div class="section">
                <h2>‚ö° Performance Analysis</h2>

                <table class="comparison-table">
                    <thead>
                        <tr>
                            <th>Operation</th>
                            <th>AVL Tree (Average)</th>
                            <th>AVL Tree (Worst)</th>
                            <th>BST (Average)</th>
                            <th>BST (Worst)</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Search</strong></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                        </tr>
                        <tr>
                            <td><strong>Insertion</strong></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                        </tr>
                        <tr>
                            <td><strong>Deletion</strong></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-good">O(log n)</span></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                        </tr>
                        <tr>
                            <td><strong>Traversal</strong></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                            <td><span class="complexity-badge complexity-bad">O(n)</span></td>
                        </tr>
                    </tbody>
                </table>

                <div class="key-point">
                    <h3>Space Complexity</h3>
                    <p><span class="complexity-badge complexity-good">O(n)</span> - AVL trees store n nodes plus height information at each node</p>
                </div>

                <div class="note">
                    <strong>üí° Why AVL Trees are Better:</strong>
                    <ul>
                        <li><strong>Predictable:</strong> No worst-case O(n) operations</li>
                        <li><strong>Balanced:</strong> Always maintains logarithmic height</li>
                        <li><strong>Efficient:</strong> All operations guaranteed O(log n)</li>
                        <li><strong>Reliable:</strong> Performance doesn't depend on insertion order</li>
                    </ul>
                </div>
            </div>

            <!-- Java Implementation -->
            <div class="section">
                <h2>üíª Key Implementation Concepts</h2>

                <h3>Node Structure</h3>
                <div class="code-block">public class AVLNode {
    int key;
    int height;
    AVLNode left, right;
    
    public AVLNode(int key) {
        this.key = key;
        this.height = 1;  // New node is initially at height 1
    }
}</div>

                <h3>Essential Functions</h3>

                <h4>1. Height Calculation</h4>
                <div class="code-block">protected int height(Position p) {
    return tree.getAux(p);  // Stored as auxiliary data
}

protected void recomputeHeight(Position p) {
    int h = 1 + Math.max(height(left(p)), height(right(p)));
    tree.setAux(p, h);
}</div>

                <h4>2. Balance Factor Check</h4>
                <div class="code-block">protected boolean isBalanced(Position p) {
    return Math.abs(height(left(p)) - height(right(p))) <= 1;
}</div>

                <h4>3. Taller Child Selection</h4>
                <div class="code-block">protected Position tallerChild(Position p) {
    if (height(left(p)) > height(right(p))) 
        return left(p);    // Left is taller
    if (height(left(p)) < height(right(p))) 
        return right(p);   // Right is taller
    // Equal height: match parent's orientation
    if (p == left(parent(p))) 
        return left(p);    // Return aligned child
    else 
        return right(p);
}</div>

                <h4>4. Rebalancing After Insertion</h4>
                <div class="code-block">protected void rebalanceInsert(Position p) {
    rebalance(p);  // Check balance and fix if needed
}

protected void rebalance(Position p) {
    int oldHeight, newHeight;
    do {
        oldHeight = height(p);
        if (!isBalanced(p)) {
            // Perform trinode restructuring
            p = restructure(tallerChild(tallerChild(p)));
            recomputeHeight(left(p));
            recomputeHeight(right(p));
        }
        recomputeHeight(p);
        newHeight = height(p);
        p = parent(p);
    } while (oldHeight != newHeight && p != null);
}</div>

                <h4>5. Rebalancing After Deletion</h4>
                <div class="code-block">protected void rebalanceDelete(Position p) {
    if (!isRoot(p))
        rebalance(parent(p));  // Must check from parent up to root
}</div>
            </div>

            <!-- Study Tips -->
            <div class="section">
                <h2>üìñ Study Tips & Common Mistakes</h2>

                <h3>‚úÖ Key Concepts to Master</h3>
                <ul>
                    <li>Understanding balance factor calculation</li>
                    <li>Identifying which rotation to use (same vs opposite signs)</li>
                    <li>Recognizing that insertion needs only ONE rotation</li>
                    <li>Remembering that deletion may need MULTIPLE rotations</li>
                    <li>Height calculation after rotations</li>
                    <li>Trinode restructuring process</li>
                </ul>

                <h3>‚ö†Ô∏è Common Mistakes to Avoid</h3>
                <div class="important">
                    <ol>
                        <li><strong>Forgetting to update heights</strong> after rotations</li>
                        <li><strong>Stopping at first rotation</strong> during deletion (must go to root!)</li>
                        <li><strong>Wrong rotation selection</strong> - remember same sign = single, opposite = double</li>
                        <li><strong>Not maintaining BST property</strong> during rotations</li>
                        <li><strong>Calculating balance factor incorrectly</strong> (it's left - right, not right - left)</li>
                    </ol>
                </div>

                <h3>üéØ Practice Problems</h3>
                <div class="example">
                    <ol>
                        <li>Insert nodes 45, 70, 35, 3, 74, 25, 81, 4 into an empty AVL tree. Show all rotations.</li>
                        <li>Delete node 25 from the tree created above. Show all rebalancing steps.</li>
                        <li>Given a tree of height h, prove the minimum number of nodes is approximately Fibonacci(h+2).</li>
                        <li>Compare AVL trees with Red-Black trees - when would you use each?</li>
                    </ol>
                </div>

                <h3>üîç Quick Reference</h3>
                <div class="note">
                    <strong>Rotation Decision Tree:</strong>
                    <pre>
Is node unbalanced (|BF| = 2)?
‚îú‚îÄ NO ‚Üí Continue checking parent
‚îî‚îÄ YES ‚Üí Which subtree is taller?
    ‚îú‚îÄ Left (BF = +2)
    ‚îÇ   ‚îú‚îÄ Left child's left subtree taller ‚Üí LL: Single Right Rotation
    ‚îÇ   ‚îî‚îÄ Left child's right subtree taller ‚Üí LR: Double Rotation (Left-Right)
    ‚îî‚îÄ Right (BF = -2)
        ‚îú‚îÄ Right child's right subtree taller ‚Üí RR: Single Left Rotation
        ‚îî‚îÄ Right child's left subtree taller ‚Üí RL: Double Rotation (Right-Left)
                    </pre>
                </div>
            </div>

            <!-- Summary -->
            <div class="section">
                <h2>üìã Summary</h2>

                <div class="key-point">
                    <h3>AVL Tree Advantages</h3>
                    <ul>
                        <li>‚úÖ Guaranteed O(log n) for search, insert, delete</li>
                        <li>‚úÖ More strictly balanced than Red-Black trees</li>
                        <li>‚úÖ Better search performance (fewer comparisons)</li>
                        <li>‚úÖ Predictable performance regardless of input order</li>
                    </ul>
                </div>

                <div class="key-point">
                    <h3>AVL Tree Disadvantages</h3>
                    <ul>
                        <li>‚ùå More rotations during insertion/deletion than Red-Black trees</li>
                        <li>‚ùå Extra space for height storage at each node</li>
                        <li>‚ùå More complex implementation than simple BST</li>
                        <li>‚ùå Slightly slower insertions/deletions compared to Red-Black trees</li>
                    </ul>
                </div>

                <div class="important">
                    <h3>üéì Remember for Exams</h3>
                    <ul>
                        <li>Height of AVL tree with n nodes: <strong>h = O(log n)</strong></li>
                        <li>Balance factor range: <strong>-1, 0, +1</strong></li>
                        <li>All operations: <strong>O(log n)</strong></li>
                        <li>Space complexity: <strong>O(n)</strong></li>
                        <li>Insertion: <strong>1 rotation max</strong></li>
                        <li>Deletion: <strong>O(log n) rotations possible</strong></li>
                        <li>Rotation time: <strong>O(1)</strong></li>
                    </ul>
                </div>
            </div>

        </div>
    </div>
</body>
</html>